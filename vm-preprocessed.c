# 1 "vm.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 361 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "vm.c" 2
# 11 "vm.c"
# 1 "./internal.h" 1
# 15 "./internal.h"
# 1 "./include/ruby.h" 1
# 33 "./include/ruby.h"
# 1 "./include/ruby/ruby.h" 1
# 24 "./include/ruby/ruby.h"
# 1 ".ext/include/x86_64-darwin17/ruby/config.h" 1
# 25 "./include/ruby/ruby.h" 2

# 1 "./include/ruby/defines.h" 1
# 113 "./include/ruby/defines.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 64 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/_stdio.h" 1 3 4
# 68 "/usr/include/_stdio.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 587 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 588 "/usr/include/sys/cdefs.h" 2 3 4
# 653 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 654 "/usr/include/sys/cdefs.h" 2 3 4
# 69 "/usr/include/_stdio.h" 2 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 206 "/usr/include/Availability.h" 3 4
# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 207 "/usr/include/Availability.h" 2 3 4
# 70 "/usr/include/_stdio.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 33 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 32 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;

typedef union {
  char __mbstate8[128];
  long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;

typedef long int __darwin_ptrdiff_t;

typedef long unsigned int __darwin_size_t;

typedef __builtin_va_list __darwin_va_list;

typedef int __darwin_wchar_t;

typedef __darwin_wchar_t __darwin_rune_t;

typedef int __darwin_wint_t;

typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 55 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;

typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
  void (*__routine)(void *);
  void *__arg;
  struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
  long __sig;
  char __opaque[56];
};

struct _opaque_pthread_cond_t {
  long __sig;
  char __opaque[40];
};

struct _opaque_pthread_condattr_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_mutex_t {
  long __sig;
  char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_once_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
  long __sig;
  char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
  long __sig;
  char __opaque[16];
};

struct _opaque_pthread_t {
  long __sig;
  struct __darwin_pthread_handler_rec *__cleanup_stack;
  char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/usr/include/sys/_types.h" 2 3 4
# 28 "/usr/include/_types.h" 2 3 4
# 40 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 72 "/usr/include/_stdio.h" 2 3 4

# 1 "/usr/include/sys/_types/_va_list.h" 1 3 4
# 31 "/usr/include/sys/_types/_va_list.h" 3 4
# 1 "/usr/include/machine/types.h" 1 3 4
# 35 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 76 "/usr/include/i386/types.h" 3 4
# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 77 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 78 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 79 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 80 "/usr/include/i386/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/usr/include/i386/types.h" 2 3 4

typedef int64_t register_t;

# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/usr/include/machine/types.h" 1 3 4
# 31 "/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 93 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/usr/include/i386/types.h" 2 3 4

typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;

typedef u_int64_t syscall_arg_t;
# 36 "/usr/include/machine/types.h" 2 3 4
# 32 "/usr/include/sys/_types/_va_list.h" 2 3 4
typedef __darwin_va_list va_list;
# 76 "/usr/include/_stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 77 "/usr/include/_stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_null.h" 1 3 4
# 78 "/usr/include/_stdio.h" 2 3 4

# 1 "/usr/include/sys/stdio.h" 1 3 4
# 39 "/usr/include/sys/stdio.h" 3 4
int renameat(int, const char *, int, const char *)
    __attribute__((availability(macosx, introduced = 10.10)));

int renamex_np(const char *, const char *, unsigned int)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
# 80 "/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/usr/include/_stdio.h" 3 4
struct __sbuf {
  unsigned char *_base;
  int _size;
};

struct __sFILEX;
# 126 "/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;

  void *_cookie;
  int (*_Nullable _close)(void *);
  int (*_Nullable _read)(void *, char *, int);
  fpos_t (*_Nullable _seek)(void *, fpos_t, int);
  int (*_Nullable _write)(void *, const char *, int);

  struct __sbuf _ub;
  struct __sFILEX *_extra;
  int _ur;

  unsigned char _ubuf[3];
  unsigned char _nbuf[1];

  struct __sbuf _lb;

  int _blksize;
  fpos_t _offset;
} FILE;
# 65 "/usr/include/stdio.h" 2 3 4

extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
# 142 "/usr/include/stdio.h" 3 4
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *restrict, fpos_t *);
char *fgets(char *restrict, int, FILE *);

FILE *fopen(const char *restrict __filename,
            const char *restrict __mode) __asm("_"
                                               "fopen"
                                               "$DARWIN_EXTSN");

int fprintf(FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char *restrict, FILE *restrict) __asm("_"
                                                      "fputs");
size_t fread(void *restrict __ptr, size_t __size, size_t __nitems,
             FILE *restrict __stream);
FILE *freopen(const char *restrict, const char *restrict,
              FILE *restrict) __asm("_"
                                    "freopen");
int fscanf(FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *restrict __ptr, size_t __size, size_t __nitems,
              FILE *restrict __stream) __asm("_"
                                             "fwrite");
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char *restrict, ...)
    __attribute__((__format__(__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename(const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char *restrict, ...)
    __attribute__((__format__(__scanf__, 1, 2)));
void setbuf(FILE *restrict, char *restrict);
int setvbuf(FILE *restrict, char *restrict, int, size_t);
int sprintf(char *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)))
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use snprintf instead.")));
int sscanf(const char *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable,
                                message = "Use mkstemp(3) instead.")))

__attribute__((
    deprecated("This function is provided for compatibility reasons only.  Due "
               "to security concerns inherent in the design of tmpnam(3), it "
               "is highly recommended that you use mkstemp(3) instead.")))

char *
tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE *restrict, const char *restrict, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int vprintf(const char *restrict, va_list)
    __attribute__((__format__(__printf__, 1, 0)));
int vsprintf(char *restrict, const char *restrict, va_list)
    __attribute__((__format__(__printf__, 2, 0)))
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use vsnprintf instead.")));
# 208 "/usr/include/stdio.h" 3 4
char *ctermid(char *);

FILE *fdopen(int, const char *) __asm("_"
                                      "fdopen"
                                      "$DARWIN_EXTSN");

int fileno(FILE *);
# 232 "/usr/include/stdio.h" 3 4
int pclose(FILE *) __attribute__((__availability__(
    swift, unavailable, message = "Use posix_spawn APIs or NSTask instead.")));

FILE *popen(const char *, const char *) __asm("_"
                                              "popen"
                                              "$DARWIN_EXTSN")
    __attribute__((
        __availability__(swift, unavailable,
                         message = "Use posix_spawn APIs or NSTask instead.")));
# 253 "/usr/include/stdio.h" 3 4
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int __swbuf(int, FILE *);
# 264 "/usr/include/stdio.h" 3 4
inline __attribute__((__always_inline__)) int __sputc(int _c, FILE *_p) {
  if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
    return (*_p->_p++ = _c);
  else
    return (__swbuf(_c, _p));
}
# 290 "/usr/include/stdio.h" 3 4
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

int getw(FILE *);
int putw(int, FILE *);

__attribute__((__availability__(swift, unavailable,
                                message = "Use mkstemp(3) instead.")))

__attribute__((
    deprecated("This function is provided for compatibility reasons only.  Due "
               "to security concerns inherent in the design of tempnam(3), it "
               "is highly recommended that you use mkstemp(3) instead.")))

char *
tempnam(const char *__dir, const char *__prefix) __asm("_"
                                                       "tempnam");
# 328 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 329 "/usr/include/stdio.h" 2 3 4

int fseeko(FILE *__stream, off_t __offset, int __whence);
off_t ftello(FILE *__stream);

int snprintf(char *restrict __str, size_t __size, const char *restrict __format,
             ...) __attribute__((__format__(__printf__, 3, 4)));
int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int vscanf(const char *restrict __format, va_list)
    __attribute__((__format__(__scanf__, 1, 0)));
int vsnprintf(char *restrict __str, size_t __size,
              const char *restrict __format, va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
# 353 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 354 "/usr/include/stdio.h" 2 3 4

int dprintf(int, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)))
    __attribute__((availability(macosx, introduced = 10.7)));
int vdprintf(int, const char *restrict, va_list)
    __attribute__((__format__(__printf__, 2, 0)))
    __attribute__((availability(macosx, introduced = 10.7)));
ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp,
                 int __delimiter, FILE *restrict __stream)
    __attribute__((availability(macosx, introduced = 10.7)));
ssize_t getline(char **restrict __linep, size_t *restrict __linecapp,
                FILE *restrict __stream)
    __attribute__((availability(macosx, introduced = 10.7)));
FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
    __attribute__((availability(macos, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep)
    __attribute__((availability(macos, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
# 371 "/usr/include/stdio.h" 3 4
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **restrict, const char *restrict, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);

FILE *funopen(const void *, int (*_Nullable)(void *, char *, int),
              int (*_Nullable)(void *, const char *, int),
              fpos_t (*_Nullable)(void *, fpos_t, int),
              int (*_Nullable)(void *));
# 411 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/secure/_stdio.h" 1 3 4
# 31 "/usr/include/secure/_stdio.h" 3 4
# 1 "/usr/include/secure/_common.h" 1 3 4
# 32 "/usr/include/secure/_stdio.h" 2 3 4
# 42 "/usr/include/secure/_stdio.h" 3 4
extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict,
                         ...);
# 52 "/usr/include/secure/_stdio.h" 3 4
extern int __snprintf_chk(char *restrict, size_t, int, size_t,
                          const char *restrict, ...);

extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict,
                          va_list);

extern int __vsnprintf_chk(char *restrict, size_t, int, size_t,
                           const char *restrict, va_list);
# 412 "/usr/include/stdio.h" 2 3 4
# 114 "./include/ruby/defines.h" 2

# 1 "/usr/include/sys/types.h" 1 3 4
# 72 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 73 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/machine/endian.h" 1 3 4
# 35 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/i386/endian.h" 1 3 4
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
# 130 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline __uint16_t _OSSwapInt16(__uint16_t _data) {
  return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline __uint32_t _OSSwapInt32(__uint32_t _data) {

  return __builtin_bswap32(_data);
}

static inline __uint64_t _OSSwapInt64(__uint64_t _data) {
  return __builtin_bswap64(_data);
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 36 "/usr/include/machine/endian.h" 2 3 4
# 82 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_char.h" 3 4
typedef unsigned char u_char;
# 85 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_short.h" 3 4
typedef unsigned short u_short;
# 86 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int.h" 3 4
typedef unsigned int u_int;
# 87 "/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;

typedef unsigned short ushort;
typedef unsigned int uint;

typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t *qaddr_t;

# 1 "/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char *caddr_t;
# 100 "/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;

# 1 "/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 104 "/usr/include/sys/types.h" 2 3 4

typedef u_int32_t fixpt_t;

# 1 "/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 109 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 110 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 111 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 112 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 113 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 116 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 119 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 120 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 121 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 122 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 123 "/usr/include/sys/types.h" 2 3 4

typedef int32_t segsz_t;
typedef int32_t swblk_t;

# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 129 "/usr/include/sys/types.h" 2 3 4
# 162 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 163 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 166 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 168 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 169 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_rsize_t.h" 3 4
typedef __darwin_size_t rsize_t;
# 172 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 173 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
# 49 "/usr/include/sys/_types/_fd_def.h" 3 4
typedef struct fd_set {
  __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0)
                          ? ((1024) / ((sizeof(__int32_t) * 8)))
                          : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

static __inline int __darwin_fd_isset(int _n, const struct fd_set *_p) {
  return (_p->fds_bits[(unsigned long)_n / (sizeof(__int32_t) * 8)] &
          ((__int32_t)(((unsigned long)1)
                       << ((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 182 "/usr/include/sys/types.h" 2 3 4

typedef __int32_t fd_mask;

# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 195 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
# 196 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 197 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 198 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 199 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 202 "/usr/include/sys/types.h" 2 3 4
# 212 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 213 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 214 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 215 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 216 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 217 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 218 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 219 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 220 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 221 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 225 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 230 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 231 "/usr/include/sys/types.h" 2 3 4
# 116 "./include/ruby/defines.h" 2

# 1 "/usr/include/sys/stat.h" 1 3 4
# 78 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/usr/include/sys/_types/_timespec.h" 3 4
struct timespec {
  __darwin_time_t tv_sec;
  long tv_nsec;
};
# 79 "/usr/include/sys/stat.h" 2 3 4
# 110 "/usr/include/sys/stat.h" 3 4
struct ostat {
  __uint16_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  __uint16_t st_uid;
  __uint16_t st_gid;
  __uint16_t st_rdev;
  __int32_t st_size;
  struct timespec st_atimespec;
  struct timespec st_mtimespec;
  struct timespec st_ctimespec;
  __int32_t st_blksize;
  __int32_t st_blocks;
  __uint32_t st_flags;
  __uint32_t st_gen;
};
# 182 "/usr/include/sys/stat.h" 3 4
struct stat {
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  __darwin_ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  struct timespec st_atimespec;
  struct timespec st_mtimespec;
  struct timespec st_ctimespec;
  struct timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};
# 221 "/usr/include/sys/stat.h" 3 4
struct stat64 {
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  __darwin_ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  struct timespec st_atimespec;
  struct timespec st_mtimespec;
  struct timespec st_ctimespec;
  struct timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};
# 241 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 242 "/usr/include/sys/stat.h" 2 3 4
# 355 "/usr/include/sys/stat.h" 3 4
int chmod(const char *, mode_t) __asm("_"
                                      "chmod");
int fchmod(int, mode_t) __asm("_"
                              "fchmod");
int fstat(int, struct stat *) __asm("_"
                                    "fstat"
                                    "$INODE64");
int lstat(const char *, struct stat *) __asm("_"
                                             "lstat"
                                             "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_"
                                            "stat"
                                            "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);

int fchmodat(int, const char *, mode_t, int)
    __attribute__((availability(macosx, introduced = 10.10)));
int fstatat(int, const char *, struct stat *, int) __asm("_"
                                                         "fstatat"
                                                         "$INODE64")
    __attribute__((availability(macosx, introduced = 10.10)));
int mkdirat(int, const char *, mode_t)
    __attribute__((availability(macosx, introduced = 10.10)));

int futimens(int __fd, const struct timespec __times[2])
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
int utimensat(int __fd, const char *__path, const struct timespec __times[2],
              int __flag)
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));

# 1 "/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_filesec_t.h" 3 4
struct _filesec;
typedef struct _filesec *filesec_t;
# 381 "/usr/include/sys/stat.h" 2 3 4

int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_"
                                                   "fstatx_np"
                                                   "$INODE64");
int lchflags(const char *, __uint32_t)
    __attribute__((availability(macosx, introduced = 10.5)));
int lchmod(const char *, mode_t)
    __attribute__((availability(macosx, introduced = 10.5)));
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_"
                                                            "lstatx_np"
                                                            "$INODE64");
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_"
                                                           "statx_np"
                                                           "$INODE64");
int umaskx_np(filesec_t)
    __attribute__((availability(macosx, introduced = 10.4, deprecated = 10.6)));

int fstatx64_np(int, struct stat64 *, filesec_t)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
int lstatx64_np(const char *, struct stat64 *, filesec_t)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
int statx64_np(const char *, struct stat64 *, filesec_t)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
int fstat64(int, struct stat64 *)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
int lstat64(const char *, struct stat64 *)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
int stat64(const char *, struct stat64 *)
    __attribute__((availability(macosx, introduced = 10.5, deprecated = 10.6)));
# 119 "./include/ruby/defines.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 65 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum { P_ALL, P_PID, P_PGID } idtype_t;
# 109 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 82 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/signal.h" 1 3 4
# 32 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/usr/include/machine/signal.h" 2 3 4
# 83 "/usr/include/sys/signal.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/usr/include/machine/_mcontext.h" 3 4
# 1 "/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/usr/include/i386/_mcontext.h" 3 4
# 1 "/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/usr/include/mach/machine/_structs.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 46 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state {
  unsigned int __eax;
  unsigned int __ebx;
  unsigned int __ecx;
  unsigned int __edx;
  unsigned int __edi;
  unsigned int __esi;
  unsigned int __ebp;
  unsigned int __esp;
  unsigned int __ss;
  unsigned int __eflags;
  unsigned int __eip;
  unsigned int __cs;
  unsigned int __ds;
  unsigned int __es;
  unsigned int __fs;
  unsigned int __gs;
};
# 92 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control {
  unsigned short __invalid : 1, __denorm : 1, __zdiv : 1, __ovrfl : 1,
      __undfl : 1, __precis : 1, : 2, __pc : 2,

      __rc : 2,

      : 1, : 3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 150 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status {
  unsigned short __invalid : 1, __denorm : 1, __zdiv : 1, __ovrfl : 1,
      __undfl : 1, __precis : 1, __stkflt : 1, __errsumm : 1, __c0 : 1,
      __c1 : 1, __c2 : 1, __tos : 3, __c3 : 1, __busy : 1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 194 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg {
  char __mmst_reg[10];
  char __mmst_rsrv[6];
};
# 213 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg {
  char __xmm_reg[16];
};
# 229 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_ymm_reg {
  char __ymm_reg[32];
};
# 245 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_zmm_reg {
  char __zmm_reg[64];
};
# 259 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_opmask_reg {
  char __opmask_reg[8];
};
# 281 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
};

struct __darwin_i386_avx_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
};

struct __darwin_i386_avx512_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
};
# 575 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint32_t __faultvaddr;
};
# 595 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32 {
  unsigned int __dr0;
  unsigned int __dr1;
  unsigned int __dr2;
  unsigned int __dr3;
  unsigned int __dr4;
  unsigned int __dr5;
  unsigned int __dr6;
  unsigned int __dr7;
};
# 627 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64 {
  __uint64_t __rax;
  __uint64_t __rbx;
  __uint64_t __rcx;
  __uint64_t __rdx;
  __uint64_t __rdi;
  __uint64_t __rsi;
  __uint64_t __rbp;
  __uint64_t __rsp;
  __uint64_t __r8;
  __uint64_t __r9;
  __uint64_t __r10;
  __uint64_t __r11;
  __uint64_t __r12;
  __uint64_t __r13;
  __uint64_t __r14;
  __uint64_t __r15;
  __uint64_t __rip;
  __uint64_t __rflags;
  __uint64_t __cs;
  __uint64_t __fs;
  __uint64_t __gs;
};
# 682 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
};

struct __darwin_x86_avx_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
};

struct __darwin_x86_avx512_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
  struct __darwin_ymm_reg __fpu_zmmh8;
  struct __darwin_ymm_reg __fpu_zmmh9;
  struct __darwin_ymm_reg __fpu_zmmh10;
  struct __darwin_ymm_reg __fpu_zmmh11;
  struct __darwin_ymm_reg __fpu_zmmh12;
  struct __darwin_ymm_reg __fpu_zmmh13;
  struct __darwin_ymm_reg __fpu_zmmh14;
  struct __darwin_ymm_reg __fpu_zmmh15;
  struct __darwin_zmm_reg __fpu_zmm16;
  struct __darwin_zmm_reg __fpu_zmm17;
  struct __darwin_zmm_reg __fpu_zmm18;
  struct __darwin_zmm_reg __fpu_zmm19;
  struct __darwin_zmm_reg __fpu_zmm20;
  struct __darwin_zmm_reg __fpu_zmm21;
  struct __darwin_zmm_reg __fpu_zmm22;
  struct __darwin_zmm_reg __fpu_zmm23;
  struct __darwin_zmm_reg __fpu_zmm24;
  struct __darwin_zmm_reg __fpu_zmm25;
  struct __darwin_zmm_reg __fpu_zmm26;
  struct __darwin_zmm_reg __fpu_zmm27;
  struct __darwin_zmm_reg __fpu_zmm28;
  struct __darwin_zmm_reg __fpu_zmm29;
  struct __darwin_zmm_reg __fpu_zmm30;
  struct __darwin_zmm_reg __fpu_zmm31;
};
# 1140 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64 {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint64_t __faultvaddr;
};
# 1160 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64 {
  __uint64_t __dr0;
  __uint64_t __dr1;
  __uint64_t __dr2;
  __uint64_t __dr3;
  __uint64_t __dr4;
  __uint64_t __dr5;
  __uint64_t __dr6;
  __uint64_t __dr7;
};
# 1188 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_cpmu_state64 {
  __uint64_t __ctrs[16];
};
# 34 "/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/usr/include/i386/_mcontext.h" 2 3 4

struct __darwin_mcontext32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_float_state __fs;
};

struct __darwin_mcontext_avx32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx_state __fs;
};

struct __darwin_mcontext_avx512_32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx512_state __fs;
};
# 97 "/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_float_state64 __fs;
};

struct __darwin_mcontext_avx64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx_state64 __fs;
};

struct __darwin_mcontext_avx512_64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx512_state64 __fs;
};
# 156 "/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack {
  void *ss_sp;
  __darwin_size_t ss_size;
  int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/usr/include/sys/_types/_ucontext.h" 2 3 4

struct __darwin_ucontext {
  int uc_onstack;
  __darwin_sigset_t uc_sigmask;
  struct __darwin_sigaltstack uc_stack;
  struct __darwin_ucontext *uc_link;
  __darwin_size_t uc_mcsize;
  struct __darwin_mcontext64 *uc_mcontext;

  struct __darwin_mcontext64 __mcontext_data;
};

typedef struct __darwin_ucontext ucontext_t;
# 152 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/usr/include/sys/signal.h" 2 3 4

union sigval {

  int sival_int;
  void *sival_ptr;
};

struct sigevent {
  int sigev_notify;
  int sigev_signo;
  union sigval sigev_value;
  void (*sigev_notify_function)(union sigval);
  pthread_attr_t *sigev_notify_attributes;
};

typedef struct __siginfo {
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  void *si_addr;
  union sigval si_value;
  long si_band;
  unsigned long __pad[7];
} siginfo_t;
# 269 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
};

struct __sigaction {
  union __sigaction_u __sigaction_u;
  void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
  sigset_t sa_mask;
  int sa_flags;
};

struct sigaction {
  union __sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};
# 331 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 348 "/usr/include/sys/signal.h" 3 4
struct sigvec {
  void (*sv_handler)(int);
  int sv_mask;
  int sv_flags;
};
# 367 "/usr/include/sys/signal.h" 3 4
struct sigstack {
  char *ss_sp;
  int ss_onstack;
};
# 390 "/usr/include/sys/signal.h" 3 4
void (*signal(int, void (*)(int)))(int);
# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 72 "/usr/include/sys/resource.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdint.h" 1 3 4
# 63 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 23 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/usr/include/stdint.h" 2 3 4

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 58 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/usr/include/stdint.h" 2 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdint.h" 2 3 4
# 73 "/usr/include/sys/resource.h" 2 3 4

# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/usr/include/sys/_types/_timeval.h" 3 4
struct timeval {
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};
# 81 "/usr/include/sys/resource.h" 2 3 4

typedef __uint64_t rlim_t;
# 152 "/usr/include/sys/resource.h" 3 4
struct rusage {
  struct timeval ru_utime;
  struct timeval ru_stime;
# 163 "/usr/include/sys/resource.h" 3 4
  long ru_maxrss;

  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};
# 193 "/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
  uint64_t ri_logical_writes;
  uint64_t ri_lifetime_max_phys_footprint;
  uint64_t ri_instructions;
  uint64_t ri_cycles;
  uint64_t ri_billed_energy;
  uint64_t ri_serviced_energy;

  uint64_t ri_unused[2];
};

typedef struct rusage_info_v4 rusage_info_current;
# 365 "/usr/include/sys/resource.h" 3 4
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};
# 393 "/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
  uint32_t wm_flags;
  int32_t wm_rate;
};
# 425 "/usr/include/sys/resource.h" 3 4
int getpriority(int, id_t);

int getiopolicy_np(int, int)
    __attribute__((availability(macosx, introduced = 10.5)));

int getrlimit(int, struct rlimit *) __asm("_"
                                          "getrlimit");
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int)
    __attribute__((availability(macosx, introduced = 10.5)));

int setrlimit(int, const struct rlimit *) __asm("_"
                                                "setrlimit");
# 111 "/usr/include/sys/wait.h" 2 3 4
# 194 "/usr/include/sys/wait.h" 3 4
union wait {
  int w_status;

  struct {

    unsigned int w_Termsig : 7, w_Coredump : 1, w_Retcode : 8, w_Filler : 16;

  } w_T;

  struct {

    unsigned int w_Stopval : 8, w_Stopsig : 8, w_Filler : 16;

  } w_S;
};
# 248 "/usr/include/sys/wait.h" 3 4
pid_t wait(int *) __asm("_"
                        "wait");
pid_t waitpid(pid_t, int *, int) __asm("_"
                                       "waitpid");

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_"
                                                   "waitid");

pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);
# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 32 "/usr/include/alloca.h" 3 4
void *alloca(size_t);
# 68 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 77 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 78 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 34 "/usr/include/sys/_types/_wchar_t.h" 3 4
typedef __darwin_wchar_t wchar_t;
# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long quot;
  long rem;
} ldiv_t;

typedef struct {
  long long quot;
  long long rem;
} lldiv_t;
# 117 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 136 "/usr/include/stdlib.h" 3 4
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (*_Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
              size_t __width,
              int (*_Nonnull __compar)(const void *, const void *));
void *calloc(size_t __count, size_t __size)
    __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1, 2)));
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t __size) __attribute__((__warn_unused_result__))
__attribute__((alloc_size(1)));
int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t);
int mbtowc(wchar_t *restrict, const char *restrict, size_t);
int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
    __attribute__((availability(macosx, introduced = 10.6)));
void qsort(void *__base, size_t __nel, size_t __width,
           int (*_Nonnull __compar)(const void *, const void *));
int rand(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
void *realloc(void *__ptr, size_t __size)
    __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
void srand(unsigned)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
double strtod(const char *, char **) __asm("_"
                                           "strtod");
float strtof(const char *, char **) __asm("_"
                                          "strtof");
long strtol(const char *__str, char **__endptr, int __base);
long double strtold(const char *, char **);

long long strtoll(const char *__str, char **__endptr, int __base);

unsigned long strtoul(const char *__str, char **__endptr, int __base);

unsigned long long strtoull(const char *__str, char **__endptr, int __base);
# 192 "/usr/include/stdlib.h" 3 4
__attribute__((__availability__(
    swift, unavailable, message = "Use posix_spawn APIs or NSTask instead.")))
__attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable))) int
system(const char *) __asm("_"
                           "system");

size_t wcstombs(char *restrict, const wchar_t *restrict, size_t);
int wctomb(char *, wchar_t);

void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *restrict, int *restrict);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *restrict, int *restrict);
char *gcvt(double, int, char *);
int getsubopt(char **, char *const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);

long jrand48(unsigned short[3])
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
long nrand48(unsigned short[3])
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);

int ptsname_r(int fildes, char *buffer, size_t buflen)
    __attribute__((availability(macos, introduced = 10.13.4)))
    __attribute__((availability(ios, introduced = 11.3)))
    __attribute__((availability(tvos, introduced = 11.3)))
    __attribute__((availability(watchos, introduced = 4.3)));

int putenv(char *) __asm("_"
                         "putenv");
long random(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
int rand_r(unsigned *)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));

char *realpath(const char *restrict, char *restrict) __asm("_"
                                                           "realpath"
                                                           "$DARWIN_EXTSN");

unsigned short *seed48(unsigned short[3]);
int setenv(const char *__name, const char *__value,
           int __overwrite) __asm("_"
                                  "setenv");

void setkey(const char *) __asm("_"
                                "setkey");

char *setstate(const char *);
void srand48(long);

void srandom(unsigned);

int unlockpt(int);

int unsetenv(const char *) __asm("_"
                                 "unsetenv");
# 270 "/usr/include/stdlib.h" 3 4
uint32_t arc4random(void);
void arc4random_addrandom(unsigned char *, int)
    __attribute__((availability(macosx, introduced = 10.0)))
    __attribute__((availability(macosx, deprecated = 10.12,
                                message = "use arc4random_stir")))
    __attribute__((availability(ios, introduced = 2.0)))
    __attribute__((availability(ios, deprecated = 10.0,
                                message = "use arc4random_stir")))
    __attribute__((availability(tvos, introduced = 2.0)))
    __attribute__((availability(tvos, deprecated = 10.0,
                                message = "use arc4random_stir")))
    __attribute__((availability(watchos, introduced = 1.0)))
    __attribute__((availability(watchos, deprecated = 3.0,
                                message = "use arc4random_stir")));
void arc4random_buf(void *__buf, size_t __nbytes)
    __attribute__((availability(macosx, introduced = 10.7)));
void arc4random_stir(void);
uint32_t arc4random_uniform(uint32_t __upper_bound)
    __attribute__((availability(macosx, introduced = 10.7)));

int atexit_b(void (^_Nonnull)(void))
    __attribute__((availability(macosx, introduced = 10.6)));
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
                size_t __width,
                int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_"
                           "daemon"
                           "$1050")
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.5,
                                message = "Use posix_spawn APIs instead.")))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double[], int);
const char *getprogname(void);

int heapsort(void *__base, size_t __nel, size_t __width,
             int (*_Nonnull __compar)(const void *, const void *));

int heapsort_b(void *__base, size_t __nel, size_t __width,
               int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
              int (*_Nonnull __compar)(const void *, const void *));

int mergesort_b(void *__base, size_t __nel, size_t __width,
                int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort(void *__base, size_t __nel, size_t __width,
           int (*_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
             int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort_r(void *__base, size_t __nel, size_t __width, void *,
             int (*_Nonnull __compar)(void *, const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
             int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void qsort_r(void *__base, size_t __nel, size_t __width, void *,
             int (*_Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel,
              const unsigned char *__table, unsigned __endbyte);
void setprogname(const char *);
int sradixsort(const unsigned char **__base, int __nel,
               const unsigned char *__table, unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));

long long strtoq(const char *__str, char **__endptr, int __base);
unsigned long long strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;
void *valloc(size_t) __attribute__((alloc_size(1)));
# 122 "./include/ruby/defines.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 1 3 4
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/__stddef_max_align_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/__stddef_max_align_t.h" 3 4
typedef long double max_align_t;
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 2 3 4
# 123 "./include/ruby/defines.h" 2
# 132 "./include/ruby/defines.h"
# 1 "/usr/include/string.h" 1 3 4
# 70 "/usr/include/string.h" 3 4
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_"
                                   "strerror");
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
# 104 "/usr/include/string.h" 3 4
char *strtok_r(char *__str, const char *__sep, char **__lasts);
# 116 "/usr/include/string.h" 3 4
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
# 130 "/usr/include/string.h" 3 4
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
char *strndup(const char *__s1, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
size_t strnlen(const char *__s1, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
char *strsignal(int __sig);
# 145 "/usr/include/string.h" 3 4
errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
    __attribute__((availability(macosx, introduced = 10.9)));
# 155 "/usr/include/string.h" 3 4
void *memmem(const void *__big, size_t __big_len, const void *__little,
             size_t __little_len)
    __attribute__((availability(macosx, introduced = 10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);

void swab(const void *restrict, void *restrict, ssize_t);

__attribute__((availability(macosx, introduced = 10.12.1)))
__attribute__((availability(ios, introduced = 10.1)))
__attribute__((availability(tvos, introduced = 10.0.1)))
__attribute__((availability(watchos, introduced = 3.1))) int
timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);

# 1 "/usr/include/strings.h" 1 3 4
# 70 "/usr/include/strings.h" 3 4
int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
char *index(const char *, int);
char *rindex(const char *, int);

int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);

int ffsl(long) __attribute__((availability(macosx, introduced = 10.5)));
int ffsll(long long) __attribute__((availability(macosx, introduced = 10.9)));
int fls(int) __attribute__((availability(macosx, introduced = 10.5)));
int flsl(long) __attribute__((availability(macosx, introduced = 10.5)));
int flsll(long long) __attribute__((availability(macosx, introduced = 10.9)));

# 1 "/usr/include/string.h" 1 3 4
# 93 "/usr/include/strings.h" 2 3 4

# 1 "/usr/include/secure/_strings.h" 1 3 4
# 98 "/usr/include/strings.h" 2 3 4
# 181 "/usr/include/string.h" 2 3 4
# 190 "/usr/include/string.h" 3 4
# 1 "/usr/include/secure/_string.h" 1 3 4
# 191 "/usr/include/string.h" 2 3 4
# 133 "./include/ruby/defines.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/inttypes.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/inttypes.h" 3 4
# 1 "/usr/include/inttypes.h" 1 3 4
# 227 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 228 "/usr/include/inttypes.h" 2 3 4

__attribute__((availability(macosx, introduced = 10.4))) extern intmax_t
imaxabs(intmax_t j);

typedef struct {
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx, introduced = 10.4))) extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);

__attribute__((availability(macosx, introduced = 10.4))) extern intmax_t
strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base);

__attribute__((availability(macosx, introduced = 10.4))) extern uintmax_t
strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base);

__attribute__((availability(macosx, introduced = 10.4))) extern intmax_t
wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr,
          int __base);

__attribute__((availability(macosx, introduced = 10.4))) extern uintmax_t
wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr,
          int __base);
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/inttypes.h" 2 3 4
# 139 "./include/ruby/defines.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdalign.h" 1 3 4
# 145 "./include/ruby/defines.h" 2

# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 84 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/usr/include/sys/unistd.h" 2 3 4
# 122 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/usr/include/sys/unistd.h" 2 3 4
# 132 "/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
  unsigned int ad_name_offset;
  int ad_flags;
  int ad_pad[2];
};
# 187 "/usr/include/sys/unistd.h" 3 4
int getattrlistbulk(int, void *, void *, size_t, uint64_t)
    __attribute__((availability(macosx, introduced = 10.10)));
int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
    __attribute__((availability(macosx, introduced = 10.10)));
int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
# 207 "/usr/include/sys/unistd.h" 3 4
int faccessat(int, const char *, int, int)
    __attribute__((availability(macosx, introduced = 10.10)));
int fchownat(int, const char *, uid_t, gid_t, int)
    __attribute__((availability(macosx, introduced = 10.10)));
int linkat(int, const char *, int, const char *, int)
    __attribute__((availability(macosx, introduced = 10.10)));
ssize_t readlinkat(int, const char *, char *, size_t)
    __attribute__((availability(macosx, introduced = 10.10)));
int symlinkat(const char *, int, const char *)
    __attribute__((availability(macosx, introduced = 10.10)));
int unlinkat(int, const char *, int)
    __attribute__((availability(macosx, introduced = 10.10)));
# 73 "/usr/include/unistd.h" 2 3 4
# 429 "/usr/include/unistd.h" 3 4
void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_"
                     "close");

int dup(int);
int dup2(int, int);
int execl(const char *__path, const char *__arg0, ...)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int execle(const char *__path, const char *__arg0, ...)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int execlp(const char *__file, const char *__arg0, ...)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int execv(const char *__path, char *const *__argv)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int execve(const char *__file, char *const *__argv, char *const *__envp)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int execvp(const char *__file, char *const *__argv)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
pid_t fork(void) __attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)));
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);

int getgroups(int, gid_t[]) __asm("_"
                                  "getgroups"
                                  "$DARWIN_EXTSN");

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_"
                      "pause");

int pipe(int[2]);

ssize_t read(int, void *, size_t) __asm("_"
                                        "read");

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int sleep(unsigned int) __asm("_"
                                       "sleep");

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);

int ttyname_r(int, char *, size_t) __asm("_"
                                         "ttyname_r");

int unlink(const char *);

ssize_t write(int __fd, const void *__buf, size_t __nbyte) __asm("_"
                                                                 "write");
# 506 "/usr/include/unistd.h" 3 4
size_t confstr(int, char *, size_t) __asm("_"
                                          "confstr");

int getopt(int, char *const[], const char *) __asm("_"
                                                   "getopt");

extern char *optarg;
extern int optind, opterr, optopt;
# 536 "/usr/include/unistd.h" 3 4
__attribute__((deprecated)) __attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)))

void *
brk(const void *);
int chroot(const char *);

char *crypt(const char *, const char *);

void encrypt(char *, int) __asm("_"
                                "encrypt");

int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);

int getdtablesize(void);
int getpagesize(void) __attribute__((const));
char *getpass(const char *);

char *getwd(char *);

int lchown(const char *, uid_t, gid_t) __asm("_"
                                             "lchown");

int lockf(int, int, off_t) __asm("_"
                                 "lockf");

int nice(int) __asm("_"
                    "nice");

ssize_t pread(int __fd, void *__buf, size_t __nbyte,
              off_t __offset) __asm("_"
                                    "pread");

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte,
               off_t __offset) __asm("_"
                                     "pwrite");

__attribute__((deprecated)) __attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)))

void *
sbrk(int);

pid_t setpgrp(void) __asm("_"
                          "setpgrp");

int setregid(gid_t, gid_t) __asm("_"
                                 "setregid");

int setreuid(uid_t, uid_t) __asm("_"
                                 "setreuid");

void swab(const void *restrict, void *restrict, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_"
                             "usleep");
pid_t fork(void) __attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)));

int fsync(int) __asm("_"
                     "fsync");

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
# 624 "/usr/include/unistd.h" 3 4
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char *restrict, char *restrict, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
# 638 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 114 "/usr/include/sys/select.h" 3 4
int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict,
            const struct timespec *restrict, const sigset_t *restrict)

    __asm("_"
          "pselect"
          "$DARWIN_EXTSN")

        ;

# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict,
           struct timeval *restrict)

    __asm("_"
          "select"
          "$DARWIN_EXTSN")

        ;
# 130 "/usr/include/sys/select.h" 2 3 4
# 639 "/usr/include/unistd.h" 2 3 4

# 1 "/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_uuid_t.h" 3 4
typedef __darwin_uuid_t uuid_t;
# 643 "/usr/include/unistd.h" 2 3 4

void _Exit(int) __attribute__((noreturn));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
void endusershell(void);
int execvP(const char *__file, const char *__searchpath, char *const *__argv)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);

# 1 "/usr/include/gethostuuid.h" 1 3 4
# 39 "/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *)
    __attribute__((availability(macosx, introduced = 10.5)));
# 659 "/usr/include/unistd.h" 2 3 4

mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode)
    __attribute__((availability(macosx, introduced = 10.8)));
int mkpathat_np(int dfd, const char *path, mode_t omode)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int mkostemp(char *path, int oflags)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
int mkostemps(char *path, int slen, int oflags)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
    __attribute__((availability(macosx, unavailable)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
char *mkdtempat_np(int dfd, char *path)
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
int mkstempsat_np(int dfd, char *path, int slen)
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
int mkostempsat_np(int dfd, char *path, int slen, int oflags)
    __attribute__((availability(macosx, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);

__attribute__((deprecated(
    "Use of per-thread security contexts is error-prone and discouraged."))) int
    pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np(uid_t *, gid_t *);

int reboot(int);
int revoke(const char *);

__attribute__((deprecated)) int rcmd(char **, int, const char *, const char *,
                                     const char *, int *);
__attribute__((deprecated)) int rcmd_af(char **, int, const char *,
                                        const char *, const char *, int *, int);
__attribute__((deprecated)) int rresvport(int *);
__attribute__((deprecated)) int rresvport_af(int *, int);
__attribute__((deprecated)) int iruserok(unsigned long, int, const char *,
                                         const char *);
__attribute__((deprecated)) int iruserok_sa(const void *, int, int,
                                            const char *, const char *);
__attribute__((deprecated)) int ruserok(const char *, int, const char *,
                                        const char *);

int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_"
                                "setkey");

int setlogin(const char *);
void *setmode(const char *) __asm("_"
                                  "setmode");
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
__attribute__((availability(ios,deprecated=10.0,message="syscall(2) is unsupported; " "please switch to a supported interface. For SYS_kdebug_trace use kdebug_signpost().")))

__attribute__((availability(macosx,deprecated=10.12,message="syscall(2) is unsupported; " "please switch to a supported interface. For SYS_kdebug_trace use kdebug_signpost().")))

int syscall(int, ...);

extern char *suboptarg;
int getsubopt(char **, char *const *, char **);

int fgetattrlist(int, void *, void *, size_t, unsigned int)
    __attribute__((availability(macosx, introduced = 10.6)));
int fsetattrlist(int, void *, void *, size_t, unsigned int)
    __attribute__((availability(macosx, introduced = 10.6)));
int getattrlist(const char *, void *, void *, size_t,
                unsigned int) __asm("_"
                                    "getattrlist");
int setattrlist(const char *, void *, void *, size_t,
                unsigned int) __asm("_"
                                    "setattrlist");
int exchangedata(const char *, const char *, unsigned int)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int getdirentriesattr(int, void *, void *, size_t, unsigned int *,
                      unsigned int *, unsigned int *, unsigned int)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
# 772 "/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *,
             unsigned int, unsigned int, struct searchstate *)
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int fsctl(const char *, unsigned long, void *, unsigned int);
int ffsctl(int, unsigned long, void *, unsigned int)
    __attribute__((availability(macosx, introduced = 10.6)));

int fsync_volume_np(int, int)
    __attribute__((availability(macosx, introduced = 10.8)));
int sync_volume_np(const char *, int)
    __attribute__((availability(macosx, introduced = 10.8)));

extern int optreset;
# 148 "./include/ruby/defines.h" 2
# 158 "./include/ruby/defines.h"
# 1 "./include/ruby/missing.h" 1
# 22 "./include/ruby/missing.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 1 3 4
# 23 "./include/ruby/missing.h" 2
# 1 "/usr/include/math.h" 1 3 4
# 44 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 111 "/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 144 "/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 188 "/usr/include/math.h" 3 4
inline __attribute__((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__((__always_inline__)) int __inline_isfinited(double);
inline __attribute__((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__((__always_inline__)) int __inline_isinff(float);
inline __attribute__((__always_inline__)) int __inline_isinfd(double);
inline __attribute__((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__((__always_inline__)) int __inline_isnanf(float);
inline __attribute__((__always_inline__)) int __inline_isnand(double);
inline __attribute__((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__((__always_inline__)) int __inline_isnormald(double);
inline __attribute__((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__((__always_inline__)) int __inline_signbitf(float);
inline __attribute__((__always_inline__)) int __inline_signbitd(double);
inline __attribute__((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__((__always_inline__)) int __inline_isfinitef(float __x) {
  return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isfinited(double __x) {
  return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__((__always_inline__)) int
__inline_isfinitel(long double __x) {
  return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isinff(float __x) {
  return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isinfd(double __x) {
  return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__((__always_inline__)) int __inline_isinfl(long double __x) {
  return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isnanf(float __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnand(double __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnanl(long double __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_signbitf(float __x) {
  union {
    float __f;
    unsigned int __u;
  } __u;
  __u.__f = __x;
  return (int)(__u.__u >> 31);
}
inline __attribute__((__always_inline__)) int __inline_signbitd(double __x) {
  union {
    double __f;
    unsigned long long __u;
  } __u;
  __u.__f = __x;
  return (int)(__u.__u >> 63);
}

inline __attribute__((__always_inline__)) int
__inline_signbitl(long double __x) {
  union {
    long double __ld;
    struct {
      unsigned long long __m;
      unsigned short __sexp;
    } __p;
  } __u;
  __u.__ld = __x;
  return (int)(__u.__p.__sexp >> 15);
}

inline __attribute__((__always_inline__)) int __inline_isnormalf(float __x) {
  return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__((__always_inline__)) int __inline_isnormald(double __x) {
  return __inline_isfinited(__x) &&
         __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__((__always_inline__)) int
__inline_isnormall(long double __x) {
  return __inline_isfinitel(__x) &&
         __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 322 "/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);

extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);

extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);

extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 565 "/usr/include/math.h" 3 4
extern float __inff(void)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));
extern double __inf(void)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));
extern long double __infl(void)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern float __nan(void)
    __attribute__((availability(macosx, introduced = 10.0)));

extern float lgammaf_r(float, int *)
    __attribute__((availability(macosx, introduced = 10.6)));
extern double lgamma_r(double, int *)
    __attribute__((availability(macosx, introduced = 10.6)));
extern long double lgammal_r(long double, int *)
    __attribute__((availability(macosx, introduced = 10.6)));
# 597 "/usr/include/math.h" 3 4
extern float __exp10f(float)
    __attribute__((availability(macosx, introduced = 10.9)));
extern double __exp10(double)
    __attribute__((availability(macosx, introduced = 10.9)));

inline __attribute__((__always_inline__)) void
__sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void
__sincos(double __x, double *__sinp, double *__cosp);
# 614 "/usr/include/math.h" 3 4
extern float __cospif(float)
    __attribute__((availability(macosx, introduced = 10.9)));
extern double __cospi(double)
    __attribute__((availability(macosx, introduced = 10.9)));
extern float __sinpif(float)
    __attribute__((availability(macosx, introduced = 10.9)));
extern double __sinpi(double)
    __attribute__((availability(macosx, introduced = 10.9)));
extern float __tanpif(float)
    __attribute__((availability(macosx, introduced = 10.9)));
extern double __tanpi(double)
    __attribute__((availability(macosx, introduced = 10.9)));
# 645 "/usr/include/math.h" 3 4
inline __attribute__((__always_inline__)) void
__sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void
__sincospi(double __x, double *__sinp, double *__cosp);

struct __float2 {
  float __sinval;
  float __cosval;
};
struct __double2 {
  double __sinval;
  double __cosval;
};

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__((__always_inline__)) void
__sincosf(float __x, float *__sinp, float *__cosp) {
  const struct __float2 __stret = __sincosf_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincos(double __x, double *__sinp, double *__cosp) {
  const struct __double2 __stret = __sincos_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincospif(float __x, float *__sinp, float *__cosp) {
  const struct __float2 __stret = __sincospif_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincospi(double __x, double *__sinp, double *__cosp) {
  const struct __double2 __stret = __sincospi_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

extern double j0(double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double j1(double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double jn(int, double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double y0(double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double y1(double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double yn(int, double)
    __attribute__((availability(macosx, introduced = 10.0)));
extern double scalb(double, double);
extern int signgam;
# 751 "/usr/include/math.h" 3 4
extern long int rinttol(double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern long int roundtol(double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern double drem(double, double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern int finite(double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern double gamma(double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

extern double significand(double)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));

struct exception {
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
};

extern int matherr(struct exception *)
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.9)));
# 24 "./include/ruby/missing.h" 2
# 80 "./include/ruby/missing.h"
#pragma GCC visibility push(default)
# 97 "./include/ruby/missing.h"
extern int eaccess(const char *, int);
# 259 "./include/ruby/missing.h"
extern void setproctitle(const char *fmt, ...);

extern void explicit_bzero(void *b, size_t len);

#pragma GCC visibility pop
# 159 "./include/ruby/defines.h" 2
# 196 "./include/ruby/defines.h"
#pragma GCC visibility push(default)
# 211 "./include/ruby/defines.h"
void *ruby_xmalloc(size_t);
void *ruby_xmalloc2(size_t, size_t);
void *ruby_xcalloc(size_t, size_t);
void *ruby_xrealloc(void *, size_t);
void *ruby_xrealloc2(void *, size_t, size_t);
void ruby_xfree(void *);
# 496 "./include/ruby/defines.h"
#pragma GCC visibility pop
# 30 "./include/ruby/ruby.h" 2
# 71 "./include/ruby/ruby.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdarg.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 72 "./include/ruby/ruby.h" 2

#pragma GCC visibility push(default)
# 101 "./include/ruby/ruby.h"
typedef unsigned long VALUE;
typedef unsigned long ID;
# 117 "./include/ruby/ruby.h"
typedef char ruby_check_sizeof_int[4 == sizeof(int) ? 1 : -1];
typedef char ruby_check_sizeof_long[8 == sizeof(long) ? 1 : -1];

typedef char ruby_check_sizeof_long_long[8 == sizeof(long long) ? 1 : -1];

typedef char ruby_check_sizeof_voidp[8 == sizeof(void *) ? 1 : -1];
# 212 "./include/ruby/ruby.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/limits.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 64 "/usr/include/limits.h" 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4

# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/limits.h" 2 3 4
# 213 "./include/ruby/ruby.h" 2
# 266 "./include/ruby/ruby.h"
VALUE rb_int2inum(intptr_t);

VALUE rb_uint2inum(uintptr_t);

VALUE rb_ll2inum(long long);

VALUE rb_ull2inum(unsigned long long);
# 334 "./include/ruby/ruby.h"
__attribute__((__noreturn__)) void rb_out_of_int(long num);

static inline int rb_long2int_inline(long n) {
  int i = (int)n;
  if ((long)i != n)
    rb_out_of_int(n);

  return i;
}
# 378 "./include/ruby/ruby.h"
static inline long rb_fix2long(VALUE x) {
  return ((long)(((long)(x)) >> (int)(1)));
}

static inline unsigned long rb_fix2ulong(VALUE x) {
  return ((unsigned long)((long)(((long)(x)) >> (int)(1))));
}
# 403 "./include/ruby/ruby.h"
ID rb_sym2id(VALUE);
VALUE rb_id2sym(ID);
# 435 "./include/ruby/ruby.h"
enum ruby_special_consts {

  RUBY_Qfalse = 0x00,
  RUBY_Qtrue = 0x14,
  RUBY_Qnil = 0x08,
  RUBY_Qundef = 0x34,

  RUBY_IMMEDIATE_MASK = 0x07,
  RUBY_FIXNUM_FLAG = 0x01,
  RUBY_FLONUM_MASK = 0x03,
  RUBY_FLONUM_FLAG = 0x02,
  RUBY_SYMBOL_FLAG = 0x0c,
# 459 "./include/ruby/ruby.h"
  RUBY_SPECIAL_SHIFT = 8
};
# 485 "./include/ruby/ruby.h"
enum ruby_value_type {
  RUBY_T_NONE = 0x00,

  RUBY_T_OBJECT = 0x01,
  RUBY_T_CLASS = 0x02,
  RUBY_T_MODULE = 0x03,
  RUBY_T_FLOAT = 0x04,
  RUBY_T_STRING = 0x05,
  RUBY_T_REGEXP = 0x06,
  RUBY_T_ARRAY = 0x07,
  RUBY_T_HASH = 0x08,
  RUBY_T_STRUCT = 0x09,
  RUBY_T_BIGNUM = 0x0a,
  RUBY_T_FILE = 0x0b,
  RUBY_T_DATA = 0x0c,
  RUBY_T_MATCH = 0x0d,
  RUBY_T_COMPLEX = 0x0e,
  RUBY_T_RATIONAL = 0x0f,

  RUBY_T_NIL = 0x11,
  RUBY_T_TRUE = 0x12,
  RUBY_T_FALSE = 0x13,
  RUBY_T_SYMBOL = 0x14,
  RUBY_T_FIXNUM = 0x15,
  RUBY_T_UNDEF = 0x16,

  RUBY_T_IMEMO = 0x1a,
  RUBY_T_NODE = 0x1b,
  RUBY_T_ICLASS = 0x1c,
  RUBY_T_ZOMBIE = 0x1d,

  RUBY_T_MASK = 0x1f
};
# 550 "./include/ruby/ruby.h"
static inline int rb_type(VALUE obj);
# 591 "./include/ruby/ruby.h"
void rb_check_type(VALUE, int);

VALUE rb_str_to_str(VALUE);
VALUE rb_string_value(volatile VALUE *);
char *rb_string_value_ptr(volatile VALUE *);
char *rb_string_value_cstr(volatile VALUE *);

void rb_check_safe_obj(VALUE);
# 616 "./include/ruby/ruby.h"
VALUE rb_str_export(VALUE);

VALUE rb_str_export_locale(VALUE);

VALUE rb_get_path(VALUE);

VALUE rb_get_path_no_checksafe(VALUE);

void rb_secure(int);
int rb_safe_level(void);
void rb_set_safe_level(int);
# 660 "./include/ruby/ruby.h"
void rb_set_safe_level_force(int);
void rb_secure_update(VALUE);
__attribute__((__noreturn__)) void rb_insecure_operation(void);

VALUE rb_errinfo(void);
void rb_set_errinfo(VALUE);

long rb_num2long(VALUE);
unsigned long rb_num2ulong(VALUE);
static inline long rb_num2long_inline(VALUE x) {
  if ((((int)(long)(x)) & RUBY_FIXNUM_FLAG))
    return ((long)(((long)(x)) >> (int)(1)));
  else
    return rb_num2long(x);
}

static inline unsigned long rb_num2ulong_inline(VALUE x) {
  if ((((int)(long)(x)) & RUBY_FIXNUM_FLAG))
    return ((unsigned long)((long)(((long)(x)) >> (int)(1))));
  else
    return rb_num2ulong(x);
}

long rb_num2int(VALUE);
long rb_fix2int(VALUE);

static inline int rb_num2int_inline(VALUE x) {
  if ((((int)(long)(x)) & RUBY_FIXNUM_FLAG))
    return (int)rb_fix2int(x);
  else
    return (int)rb_num2int(x);
}

unsigned long rb_num2uint(VALUE);

unsigned long rb_fix2uint(VALUE);
# 719 "./include/ruby/ruby.h"
short rb_num2short(VALUE);
unsigned short rb_num2ushort(VALUE);
short rb_fix2short(VALUE);
unsigned short rb_fix2ushort(VALUE);

static inline short rb_num2short_inline(VALUE x) {
  if ((((int)(long)(x)) & RUBY_FIXNUM_FLAG))
    return rb_fix2short(x);
  else
    return rb_num2short(x);
}

long long rb_num2ll(VALUE);
unsigned long long rb_num2ull(VALUE);
static inline long long rb_num2ll_inline(VALUE x) {
  if ((((int)(long)(x)) & RUBY_FIXNUM_FLAG))
    return ((long)(((long)(x)) >> (int)(1)));
  else
    return rb_num2ll(x);
}
# 772 "./include/ruby/ruby.h"
double rb_num2dbl(VALUE);

VALUE rb_uint2big(uintptr_t);
VALUE rb_int2big(intptr_t);

VALUE rb_newobj(void);
VALUE rb_newobj_of(VALUE, VALUE);
VALUE rb_obj_setup(VALUE obj, VALUE klass, VALUE type);
# 838 "./include/ruby/ruby.h"
__extension__

    enum ruby_fl_type {
      RUBY_FL_WB_PROTECTED = (1 << 5),
      RUBY_FL_PROMOTED0 = (1 << 5),
      RUBY_FL_PROMOTED1 = (1 << 6),
      RUBY_FL_PROMOTED = RUBY_FL_PROMOTED0 | RUBY_FL_PROMOTED1,
      RUBY_FL_FINALIZE = (1 << 7),
      RUBY_FL_TAINT = (1 << 8),
      RUBY_FL_UNTRUSTED = RUBY_FL_TAINT,
      RUBY_FL_EXIVAR = (1 << 10),
      RUBY_FL_FREEZE = (1 << 11),

      RUBY_FL_USHIFT = 12,

      RUBY_FL_USER0 = (1 << (RUBY_FL_USHIFT + 0)),
      RUBY_FL_USER1 = (1 << (RUBY_FL_USHIFT + 1)),
      RUBY_FL_USER2 = (1 << (RUBY_FL_USHIFT + 2)),
      RUBY_FL_USER3 = (1 << (RUBY_FL_USHIFT + 3)),
      RUBY_FL_USER4 = (1 << (RUBY_FL_USHIFT + 4)),
      RUBY_FL_USER5 = (1 << (RUBY_FL_USHIFT + 5)),
      RUBY_FL_USER6 = (1 << (RUBY_FL_USHIFT + 6)),
      RUBY_FL_USER7 = (1 << (RUBY_FL_USHIFT + 7)),
      RUBY_FL_USER8 = (1 << (RUBY_FL_USHIFT + 8)),
      RUBY_FL_USER9 = (1 << (RUBY_FL_USHIFT + 9)),
      RUBY_FL_USER10 = (1 << (RUBY_FL_USHIFT + 10)),
      RUBY_FL_USER11 = (1 << (RUBY_FL_USHIFT + 11)),
      RUBY_FL_USER12 = (1 << (RUBY_FL_USHIFT + 12)),
      RUBY_FL_USER13 = (1 << (RUBY_FL_USHIFT + 13)),
      RUBY_FL_USER14 = (1 << (RUBY_FL_USHIFT + 14)),
      RUBY_FL_USER15 = (1 << (RUBY_FL_USHIFT + 15)),
      RUBY_FL_USER16 = (1 << (RUBY_FL_USHIFT + 16)),
      RUBY_FL_USER17 = (1 << (RUBY_FL_USHIFT + 17)),
      RUBY_FL_USER18 = (1 << (RUBY_FL_USHIFT + 18)),

      RUBY_FL_USER19 = (1 << (RUBY_FL_USHIFT + 19)),

      RUBY_ELTS_SHARED = RUBY_FL_USER2,
      RUBY_FL_DUPPED = (RUBY_T_MASK | RUBY_FL_EXIVAR | RUBY_FL_TAINT),
      RUBY_FL_SINGLETON = RUBY_FL_USER0
    };

struct __attribute__((__aligned__(8))) RBasic {
  VALUE flags;
  const VALUE klass;
};

VALUE rb_obj_hide(VALUE obj);
VALUE rb_obj_reveal(VALUE obj, VALUE klass);
# 908 "./include/ruby/ruby.h"
enum ruby_robject_flags {
  ROBJECT_EMBED_LEN_MAX = 3,
  ROBJECT_EMBED = RUBY_FL_USER1,

  ROBJECT_ENUM_END
};

struct RObject {
  struct RBasic basic;
  union {
    struct {
      uint32_t numiv;
      VALUE *ivptr;
      void *iv_index_tbl;
    } heap;
    VALUE ary[ROBJECT_EMBED_LEN_MAX];
  } as;
};
# 947 "./include/ruby/ruby.h"
enum ruby_rmodule_flags {
  RMODULE_IS_OVERLAID = RUBY_FL_USER2,
  RMODULE_IS_REFINEMENT = RUBY_FL_USER3,
  RMODULE_INCLUDED_INTO_REFINEMENT = RUBY_FL_USER4,

  RMODULE_ENUM_END
};

__attribute__((__pure__)) double rb_float_value(VALUE);
VALUE rb_float_new(double);
VALUE rb_float_new_in_heap(double);
# 970 "./include/ruby/ruby.h"
enum ruby_rstring_flags {
  RSTRING_NOEMBED = RUBY_FL_USER1,
  RSTRING_EMBED_LEN_MASK = (RUBY_FL_USER2 | RUBY_FL_USER3 | RUBY_FL_USER4 |
                            RUBY_FL_USER5 | RUBY_FL_USER6),
  RSTRING_EMBED_LEN_SHIFT = (RUBY_FL_USHIFT + 2),
  RSTRING_EMBED_LEN_MAX = (int)((sizeof(VALUE) * 3) / sizeof(char) - 1),
  RSTRING_FSTR = RUBY_FL_USER17,

  RSTRING_ENUM_END
};

struct RString {
  struct RBasic basic;
  union {
    struct {
      long len;
      char *ptr;
      union {
        long capa;
        VALUE shared;
      } aux;
    } heap;
    char ary[RSTRING_EMBED_LEN_MAX + 1];
  } as;
};
# 1020 "./include/ruby/ruby.h"
enum ruby_rarray_flags {
  RARRAY_EMBED_LEN_MAX = 3,
  RARRAY_EMBED_FLAG = RUBY_FL_USER1,

  RARRAY_EMBED_LEN_MASK = (RUBY_FL_USER4 | RUBY_FL_USER3),
  RARRAY_EMBED_LEN_SHIFT = (RUBY_FL_USHIFT + 3),

  RARRAY_TRANSIENT_FLAG = RUBY_FL_USER13,

  RARRAY_ENUM_END
};

struct RArray {
  struct RBasic basic;
  union {
    struct {
      long len;
      union {
        long capa;
        VALUE shared;
      } aux;
      const VALUE *ptr;
    } heap;
    const VALUE ary[RARRAY_EMBED_LEN_MAX];
  } as;
};
# 1069 "./include/ruby/ruby.h"
VALUE *rb_ary_ptr_use_start(VALUE ary);
void rb_ary_ptr_use_end(VALUE ary);
# 1093 "./include/ruby/ruby.h"
struct RRegexp {
  struct RBasic basic;
  struct re_pattern_buffer *ptr;
  const VALUE src;
  unsigned long usecnt;
};

size_t rb_hash_size_num(VALUE hash);
# 1115 "./include/ruby/ruby.h"
struct RFile {
  struct RBasic basic;
  struct rb_io_t *fptr;
};

struct RData {
  struct RBasic basic;
  void (*dmark)(void *);
  void (*dfree)(void *);
  void *data;
};

typedef struct rb_data_type_struct rb_data_type_t;

struct rb_data_type_struct {
  const char *wrap_struct_name;
  struct {
    void (*dmark)(void *);
    void (*dfree)(void *);
    size_t (*dsize)(const void *);
    void *reserved[2];

  } function;
  const rb_data_type_t *parent;
  void *data;

  VALUE flags;
};

struct RTypedData {
  struct RBasic basic;
  const rb_data_type_t *type;
  VALUE typed_flag;
  void *data;
};
# 1164 "./include/ruby/ruby.h"
typedef void (*RUBY_DATA_FUNC)(void *);
# 1173 "./include/ruby/ruby.h"
VALUE rb_data_object_wrap(VALUE, void *, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
VALUE rb_data_object_zalloc(VALUE, size_t, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
VALUE rb_data_typed_object_wrap(VALUE klass, void *datap,
                                const rb_data_type_t *);
VALUE rb_data_typed_object_zalloc(VALUE klass, size_t size,
                                  const rb_data_type_t *type);
int rb_typeddata_inherited_p(const rb_data_type_t *child,
                             const rb_data_type_t *parent);
int rb_typeddata_is_kind_of(VALUE, const rb_data_type_t *);
void *rb_check_typeddata(VALUE, const rb_data_type_t *);
# 1240 "./include/ruby/ruby.h"
int rb_big_sign(VALUE);
# 1359 "./include/ruby/ruby.h"
void rb_freeze_singleton_class(VALUE klass);

static inline void rb_obj_freeze_inline(VALUE x) {
  if ((!(((VALUE)(x)&RUBY_IMMEDIATE_MASK) ||
         !!(((VALUE)(x) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
       (int)(((struct RBasic *)(x))->flags & RUBY_T_MASK) != RUBY_T_NODE)) {
    (void)(((struct RBasic *)(x))->flags |= RUBY_FL_FREEZE);
    if ((((struct RBasic *)(x))->klass) &&
        !(((struct RBasic *)(x))->flags & RUBY_FL_SINGLETON)) {
      rb_freeze_singleton_class(x);
    }
  }
}
# 1380 "./include/ruby/ruby.h"
__attribute__((__deprecated__)) static inline VALUE
rb_data_object_wrap_warning(VALUE, void *, RUBY_DATA_FUNC, RUBY_DATA_FUNC);

__attribute__((__deprecated__)) static inline void *
    rb_data_object_get_warning(VALUE);

static inline VALUE rb_data_object_wrap_warning(VALUE klass, void *ptr,
                                                RUBY_DATA_FUNC mark,
                                                RUBY_DATA_FUNC free) {
  return rb_data_object_wrap(klass, ptr, mark, free);
}
# 1400 "./include/ruby/ruby.h"
static inline void *rb_data_object_get(VALUE obj) {
  rb_check_type((VALUE)(obj), (RUBY_T_DATA));
  return ((struct RData *)obj)->data;
}

static inline void *rb_data_object_get_warning(VALUE obj) {
  return rb_data_object_get(obj);
}

static inline VALUE rb_data_object_make(VALUE klass, RUBY_DATA_FUNC mark_func,
                                        RUBY_DATA_FUNC free_func, void **datap,
                                        size_t size) {
  VALUE result =
      rb_data_object_zalloc((klass), (size), (RUBY_DATA_FUNC)(mark_func),
                            (RUBY_DATA_FUNC)(free_func));
  (void)((*datap) = (void *)(((struct RData *)(result))->data));
  ;
  return result;
}

static inline VALUE rb_data_typed_object_make(VALUE klass,
                                              const rb_data_type_t *type,
                                              void **datap, size_t size) {
  VALUE result = rb_data_typed_object_zalloc(klass, size, type);
  (void)((*datap) = (void *)(((struct RData *)(result))->data));
  ;
  return result;
}

__attribute__((__deprecated__("by "
                              "rb_data_object_wrap"))) static inline VALUE
rb_data_object_alloc(VALUE, void *, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
static inline VALUE rb_data_object_alloc(VALUE klass, void *data,
                                         RUBY_DATA_FUNC dmark,
                                         RUBY_DATA_FUNC dfree) {
  return rb_data_object_wrap(klass, data, dmark, dfree);
}

__attribute__((__deprecated__("by "
                              "rb_data_typed_object_wrap"))) static inline VALUE
rb_data_typed_object_alloc(VALUE, void *, const rb_data_type_t *);
static inline VALUE rb_data_typed_object_alloc(VALUE klass, void *datap,
                                               const rb_data_type_t *type) {
  return rb_data_typed_object_wrap(klass, datap, type);
}
# 1464 "./include/ruby/ruby.h"
void rb_gc_writebarrier(VALUE a, VALUE b);
void rb_gc_writebarrier_unprotect(VALUE obj);
# 1498 "./include/ruby/ruby.h"
static inline VALUE rb_obj_wb_unprotect(VALUE x,
                                        const char *filename
                                        __attribute__((unused)),
                                        int line __attribute__((unused))) {

  rb_gc_writebarrier_unprotect(x);

  return x;
}

static inline VALUE rb_obj_written(VALUE a, VALUE oldv __attribute__((unused)),
                                   VALUE b,
                                   const char *filename __attribute__((unused)),
                                   int line __attribute__((unused))) {

  if (!(((VALUE)(b)&RUBY_IMMEDIATE_MASK) ||
        !!(((VALUE)(b) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    rb_gc_writebarrier(a, b);
  }

  return a;
}

static inline VALUE rb_obj_write(VALUE a, VALUE *slot, VALUE b,
                                 const char *filename __attribute__((unused)),
                                 int line __attribute__((unused))) {

  *slot = b;

  rb_obj_written(a, ((VALUE)RUBY_Qundef), b, filename, line);

  return a;
}
# 1590 "./include/ruby/ruby.h"
static inline VALUE rb_long2num_inline(long v) {
  if ((((v) < (9223372036854775807L >> 1) + 1) &&
       ((v) >= (((long)(-9223372036854775807L - 1L)) >> (int)(1)))))
    return (((VALUE)(v)) << 1 | RUBY_FIXNUM_FLAG);
  else
    return rb_int2big(v);
}

static inline VALUE rb_ulong2num_inline(unsigned long v) {
  if (((v) < (9223372036854775807L >> 1) + 1))
    return (((VALUE)(v)) << 1 | RUBY_FIXNUM_FLAG);
  else
    return rb_uint2big(v);
}

static inline char rb_num2char_inline(VALUE x) {
  if ((((RUBY_T_STRING) == RUBY_T_FIXNUM)
           ? (((int)(long)(x)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_STRING) == RUBY_T_TRUE)
                 ? ((x) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_STRING) == RUBY_T_FALSE)
                       ? ((x) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_STRING) == RUBY_T_NIL)
                             ? ((x) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                   ? ((x) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_STRING) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(x) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   x)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(x) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(x))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_STRING) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(x)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         x)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(x) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)(x))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        x)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(x) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(x))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_STRING))) &&
      ((!(((struct RBasic *)(x))->flags & RSTRING_NOEMBED)
            ? (long)((((struct RBasic *)(x))->flags >>
                      RSTRING_EMBED_LEN_SHIFT) &
                     (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT))
            : ((struct RString *)(x))->as.heap.len) >= 1))
    return (!(((struct RBasic *)(x))->flags & RSTRING_NOEMBED)
                ? ((struct RString *)(x))->as.ary
                : ((struct RString *)(x))->as.heap.ptr)[0];
  else
    return (char)(rb_num2int_inline(x) & 0xff);
}
# 1665 "./include/ruby/ruby.h"
void *rb_alloc_tmp_buffer(volatile VALUE *store, long len);
void *rb_alloc_tmp_buffer_with_count(volatile VALUE *store, size_t len,
                                     size_t count);
void rb_free_tmp_buffer(volatile VALUE *store);
__attribute__((__noreturn__)) void ruby_malloc_size_overflow(size_t, size_t);

static inline int rb_mul_size_overflow(size_t a, size_t b, size_t max,
                                       size_t *c) {

  __extension__

      unsigned __int128 c2 = (unsigned __int128)a * (unsigned __int128)b;
  if (c2 > max)
    return 1;
  *c = (size_t)c2;

  return 0;
}
static inline void *rb_alloc_tmp_buffer2(volatile VALUE *store, long count,
                                         size_t elsize) {
  size_t cnt = (size_t)count;
  if (elsize == sizeof(VALUE)) {
    if ((__builtin_expect(!!(cnt > 9223372036854775807L / sizeof(VALUE)), 0))) {
      ruby_malloc_size_overflow(cnt, elsize);
    }
  } else {
    size_t size, max = 9223372036854775807L - sizeof(VALUE) + 1;
    if ((__builtin_expect(!!(rb_mul_size_overflow(cnt, elsize, max, &size)),
                          0))) {
      ruby_malloc_size_overflow(cnt, elsize);
    }
    cnt = (size + sizeof(VALUE) - 1) / sizeof(VALUE);
  }
  return rb_alloc_tmp_buffer_with_count(store, cnt * sizeof(VALUE), cnt);
}
# 1735 "./include/ruby/ruby.h"
void rb_obj_infect(VALUE victim, VALUE carrier);

typedef int ruby_glob_func(const char *, VALUE, void *);
void rb_glob(const char *, void (*)(const char *, VALUE, void *), VALUE);
int ruby_glob(const char *, int, ruby_glob_func *, VALUE);
int ruby_brace_glob(const char *, int, ruby_glob_func *, VALUE);

VALUE rb_define_class(const char *, VALUE);
VALUE rb_define_module(const char *);
VALUE rb_define_class_under(VALUE, const char *, VALUE);
VALUE rb_define_module_under(VALUE, const char *);

void rb_include_module(VALUE, VALUE);
void rb_extend_object(VALUE, VALUE);
void rb_prepend_module(VALUE, VALUE);

struct rb_global_variable;

typedef VALUE rb_gvar_getter_t(ID id, void *data,
                               struct rb_global_variable *gvar);
typedef void rb_gvar_setter_t(VALUE val, ID id, void *data,
                              struct rb_global_variable *gvar);
typedef void rb_gvar_marker_t(VALUE *var);

VALUE rb_gvar_undef_getter(ID id, void *data, struct rb_global_variable *gvar);
void rb_gvar_undef_setter(VALUE val, ID id, void *data,
                          struct rb_global_variable *gvar);
void rb_gvar_undef_marker(VALUE *var);

VALUE rb_gvar_val_getter(ID id, void *data, struct rb_global_variable *gvar);
void rb_gvar_val_setter(VALUE val, ID id, void *data,
                        struct rb_global_variable *gvar);
void rb_gvar_val_marker(VALUE *var);

VALUE rb_gvar_var_getter(ID id, void *data, struct rb_global_variable *gvar);
void rb_gvar_var_setter(VALUE val, ID id, void *data,
                        struct rb_global_variable *gvar);
void rb_gvar_var_marker(VALUE *var);

__attribute__((__noreturn__)) void
rb_gvar_readonly_setter(VALUE val, ID id, void *data,
                        struct rb_global_variable *gvar);

void rb_define_variable(const char *, VALUE *);
void rb_define_virtual_variable(const char *, VALUE (*)(), void (*)());
void rb_define_hooked_variable(const char *, VALUE *, VALUE (*)(), void (*)());
void rb_define_readonly_variable(const char *, const VALUE *);
void rb_define_const(VALUE, const char *, VALUE);
void rb_define_global_const(const char *, VALUE);

void rb_define_method(VALUE, const char *, VALUE (*)(), int);
void rb_define_module_function(VALUE, const char *, VALUE (*)(), int);
void rb_define_global_function(const char *, VALUE (*)(), int);

void rb_undef_method(VALUE, const char *);
void rb_define_alias(VALUE, const char *, const char *);
void rb_define_attr(VALUE, const char *, int, int);

void rb_global_variable(VALUE *);
void rb_gc_register_mark_object(VALUE);
void rb_gc_register_address(VALUE *);
void rb_gc_unregister_address(VALUE *);

ID rb_intern(const char *);
ID rb_intern2(const char *, long);
ID rb_intern_str(VALUE str);
const char *rb_id2name(ID);
ID rb_check_id(volatile VALUE *);
ID rb_to_id(VALUE);
VALUE rb_id2str(ID);
VALUE rb_sym2str(VALUE);
VALUE rb_to_symbol(VALUE name);
VALUE rb_check_symbol(volatile VALUE *namep);
# 1854 "./include/ruby/ruby.h"
const char *rb_class2name(VALUE);
const char *rb_obj_classname(VALUE);

void rb_p(VALUE);

VALUE rb_eval_string(const char *);
VALUE rb_eval_string_protect(const char *, int *);
VALUE rb_eval_string_wrap(const char *, int *);
VALUE rb_funcall(VALUE, ID, int, ...);
VALUE rb_funcallv(VALUE, ID, int, const VALUE *);
VALUE rb_funcallv_public(VALUE, ID, int, const VALUE *);

VALUE rb_funcall_passing_block(VALUE, ID, int, const VALUE *);
VALUE rb_funcall_with_block(VALUE, ID, int, const VALUE *, VALUE);
int rb_scan_args(int, const VALUE *, const char *, ...);
VALUE rb_call_super(int, const VALUE *);
VALUE rb_current_receiver(void);
int rb_get_kwargs(VALUE keyword_hash, const ID *table, int required,
                  int optional, VALUE *);
VALUE rb_extract_keywords(VALUE *orighash);

VALUE rb_gv_set(const char *, VALUE);
VALUE rb_gv_get(const char *);
VALUE rb_iv_get(VALUE, const char *);
VALUE rb_iv_set(VALUE, const char *, VALUE);

VALUE rb_equal(VALUE, VALUE);

VALUE *rb_ruby_verbose_ptr(void);
VALUE *rb_ruby_debug_ptr(void);

enum rb_io_wait_readwrite { RB_IO_WAIT_READABLE, RB_IO_WAIT_WRITABLE };

__attribute__((__noreturn__)) void rb_raise(VALUE, const char *, ...)
    __attribute__((format(printf, 2, 3)));
__attribute__((__noreturn__)) void rb_fatal(const char *, ...)
    __attribute__((format(printf, 1, 2)));
__attribute__((__noreturn__)) void rb_bug(const char *, ...)
    __attribute__((format(printf, 1, 2)));
__attribute__((__noreturn__)) void rb_bug_errno(const char *, int);
__attribute__((__noreturn__)) void rb_sys_fail(const char *);
__attribute__((__noreturn__)) void rb_sys_fail_str(VALUE);
__attribute__((__noreturn__)) void rb_mod_sys_fail(VALUE, const char *);
__attribute__((__noreturn__)) void rb_mod_sys_fail_str(VALUE, VALUE);
__attribute__((__noreturn__)) void
rb_readwrite_sys_fail(enum rb_io_wait_readwrite, const char *);
__attribute__((__noreturn__)) void rb_iter_break(void);
__attribute__((__noreturn__)) void rb_iter_break_value(VALUE);
__attribute__((__noreturn__)) void rb_exit(int);
__attribute__((__noreturn__)) void rb_notimplement(void);
VALUE rb_syserr_new(int, const char *);
VALUE rb_syserr_new_str(int n, VALUE arg);
__attribute__((__noreturn__)) void rb_syserr_fail(int, const char *);
__attribute__((__noreturn__)) void rb_syserr_fail_str(int, VALUE);
__attribute__((__noreturn__)) void rb_mod_syserr_fail(VALUE, int, const char *);
__attribute__((__noreturn__)) void rb_mod_syserr_fail_str(VALUE, int, VALUE);
__attribute__((__noreturn__)) void
rb_readwrite_syserr_fail(enum rb_io_wait_readwrite, int, const char *);

void rb_warning(const char *, ...) __attribute__((format(printf, 1, 2)));
void rb_compile_warning(const char *, int, const char *, ...)
    __attribute__((format(printf, 3, 4)));
void rb_sys_warning(const char *, ...) __attribute__((format(printf, 1, 2)));

void rb_warn(const char *, ...) __attribute__((format(printf, 1, 2)));
void rb_compile_warn(const char *, int, const char *, ...)
    __attribute__((format(printf, 3, 4)));

typedef VALUE rb_block_call_func(VALUE yielded_arg, VALUE callback_arg,
                                 int argc, const VALUE *argv, VALUE blockarg);

typedef VALUE (*rb_block_call_func_t)();

VALUE rb_each(VALUE);
VALUE rb_yield(VALUE);
VALUE rb_yield_values(int n, ...);
VALUE rb_yield_values2(int n, const VALUE *argv);
VALUE rb_yield_splat(VALUE);
VALUE rb_yield_block(VALUE, VALUE, int, const VALUE *, VALUE);
int rb_block_given_p(void);
void rb_need_block(void);
VALUE rb_iterate(VALUE (*)(VALUE), VALUE, VALUE (*)(), VALUE);
VALUE rb_block_call(VALUE, ID, int, const VALUE *, rb_block_call_func_t, VALUE);
VALUE rb_rescue(VALUE (*)(), VALUE, VALUE (*)(), VALUE);
VALUE rb_rescue2(VALUE (*)(), VALUE, VALUE (*)(), VALUE, ...);
VALUE rb_ensure(VALUE (*)(), VALUE, VALUE (*)(), VALUE);
VALUE rb_catch(const char *, VALUE (*)(), VALUE);
VALUE rb_catch_obj(VALUE, VALUE (*)(), VALUE);
__attribute__((__noreturn__)) void rb_throw(const char *, VALUE);
__attribute__((__noreturn__)) void rb_throw_obj(VALUE, VALUE);

VALUE rb_require(const char *);

extern VALUE rb_mKernel;
extern VALUE rb_mComparable;
extern VALUE rb_mEnumerable;
extern VALUE rb_mErrno;
extern VALUE rb_mFileTest;
extern VALUE rb_mGC;
extern VALUE rb_mMath;
extern VALUE rb_mProcess;
extern VALUE rb_mWaitReadable;
extern VALUE rb_mWaitWritable;

extern VALUE rb_cBasicObject;
extern VALUE rb_cObject;
extern VALUE rb_cArray;

extern VALUE rb_cBinding;
extern VALUE rb_cClass;
extern VALUE rb_cCont;
extern VALUE rb_cData;
extern VALUE rb_cDir;
extern VALUE rb_cEncoding;
extern VALUE rb_cEnumerator;
extern VALUE rb_cFalseClass;
extern VALUE rb_cFile;

extern VALUE rb_cComplex;
extern VALUE rb_cFloat;
extern VALUE rb_cHash;
extern VALUE rb_cIO;
extern VALUE rb_cInteger;
extern VALUE rb_cMatch;
extern VALUE rb_cMethod;
extern VALUE rb_cModule;
extern VALUE rb_cNameErrorMesg;
extern VALUE rb_cNilClass;
extern VALUE rb_cNumeric;
extern VALUE rb_cProc;
extern VALUE rb_cRandom;
extern VALUE rb_cRange;
extern VALUE rb_cRational;
extern VALUE rb_cRegexp;
extern VALUE rb_cStat;
extern VALUE rb_cString;
extern VALUE rb_cStruct;
extern VALUE rb_cSymbol;
extern VALUE rb_cThread;
extern VALUE rb_cTime;
extern VALUE rb_cTrueClass;
extern VALUE rb_cUnboundMethod;

extern VALUE rb_eException;
extern VALUE rb_eStandardError;
extern VALUE rb_eSystemExit;
extern VALUE rb_eInterrupt;
extern VALUE rb_eSignal;
extern VALUE rb_eFatal;
extern VALUE rb_eArgError;
extern VALUE rb_eEOFError;
extern VALUE rb_eIndexError;
extern VALUE rb_eStopIteration;
extern VALUE rb_eKeyError;
extern VALUE rb_eRangeError;
extern VALUE rb_eIOError;
extern VALUE rb_eRuntimeError;
extern VALUE rb_eFrozenError;
extern VALUE rb_eSecurityError;
extern VALUE rb_eSystemCallError;
extern VALUE rb_eThreadError;
extern VALUE rb_eTypeError;
extern VALUE rb_eZeroDivError;
extern VALUE rb_eNotImpError;
extern VALUE rb_eNoMemError;
extern VALUE rb_eNoMethodError;
extern VALUE rb_eFloatDomainError;
extern VALUE rb_eLocalJumpError;
extern VALUE rb_eSysStackError;
extern VALUE rb_eRegexpError;
extern VALUE rb_eEncodingError;
extern VALUE rb_eEncCompatError;

extern VALUE rb_eScriptError;
extern VALUE rb_eNameError;
extern VALUE rb_eSyntaxError;
extern VALUE rb_eLoadError;

extern VALUE rb_eMathDomainError;

extern VALUE rb_stdin, rb_stdout, rb_stderr;

static inline VALUE rb_class_of(VALUE obj) {
  if (((VALUE)(obj)&RUBY_IMMEDIATE_MASK)) {
    if ((((int)(long)(obj)) & RUBY_FIXNUM_FLAG))
      return rb_cInteger;
    if (((((int)(long)(obj)) & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG))
      return rb_cFloat;
    if (obj == ((VALUE)RUBY_Qtrue))
      return rb_cTrueClass;
    if ((((VALUE)(obj) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
         RUBY_SYMBOL_FLAG))
      return rb_cSymbol;
  } else if (!!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
    if (obj == ((VALUE)RUBY_Qnil))
      return rb_cNilClass;
    if (obj == ((VALUE)RUBY_Qfalse))
      return rb_cFalseClass;
  }
  return ((struct RBasic *)(obj))->klass;
}

static inline int rb_type(VALUE obj) {
  if (((VALUE)(obj)&RUBY_IMMEDIATE_MASK)) {
    if ((((int)(long)(obj)) & RUBY_FIXNUM_FLAG))
      return RUBY_T_FIXNUM;
    if (((((int)(long)(obj)) & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG))
      return RUBY_T_FLOAT;
    if (obj == ((VALUE)RUBY_Qtrue))
      return RUBY_T_TRUE;
    if ((((VALUE)(obj) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
         RUBY_SYMBOL_FLAG))
      return RUBY_T_SYMBOL;
    if (obj == ((VALUE)RUBY_Qundef))
      return RUBY_T_UNDEF;
  } else if (!!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
    if (obj == ((VALUE)RUBY_Qnil))
      return RUBY_T_NIL;
    if (obj == ((VALUE)RUBY_Qfalse))
      return RUBY_T_FALSE;
  }
  return (int)(((struct RBasic *)(obj))->flags & RUBY_T_MASK);
}
# 2104 "./include/ruby/ruby.h"
# 1 "./include/ruby/intern.h" 1
# 35 "./include/ruby/intern.h"
# 1 "./include/ruby/st.h" 1
# 19 "./include/ruby/st.h"
#pragma GCC visibility push(default)

typedef unsigned long st_data_t;
# 48 "./include/ruby/st.h"
typedef struct st_table st_table;

typedef st_data_t st_index_t;

typedef int st_compare_func(st_data_t, st_data_t);
typedef st_index_t st_hash_func(st_data_t);

typedef char
    st_check_for_sizeof_st_index_t[8 == (int)sizeof(st_index_t) ? 1 : -1];

struct st_hash_type {
  int (*compare)();
  st_index_t (*hash)();
};
# 75 "./include/ruby/st.h"
typedef struct st_table_entry st_table_entry;

struct st_table_entry;

struct st_table {

  unsigned char entry_power, bin_power, size_ind;

  unsigned int rebuilds_num;
  const struct st_hash_type *type;

  st_index_t num_entries;

  st_index_t *bins;

  st_index_t entries_start, entries_bound;

  st_table_entry *entries;
};

enum st_retval { ST_CONTINUE, ST_STOP, ST_DELETE, ST_CHECK };

st_table *st_init_table(const struct st_hash_type *);
st_table *st_init_table_with_size(const struct st_hash_type *, st_index_t);
st_table *st_init_numtable(void);
st_table *st_init_numtable_with_size(st_index_t);
st_table *st_init_strtable(void);
st_table *st_init_strtable_with_size(st_index_t);
st_table *st_init_strcasetable(void);
st_table *st_init_strcasetable_with_size(st_index_t);
int st_delete(st_table *, st_data_t *, st_data_t *);
int st_delete_safe(st_table *, st_data_t *, st_data_t *, st_data_t);
int st_shift(st_table *, st_data_t *, st_data_t *);
int st_insert(st_table *, st_data_t, st_data_t);
int st_insert2(st_table *, st_data_t, st_data_t, st_data_t (*)(st_data_t));
int st_lookup(st_table *, st_data_t, st_data_t *);
int st_get_key(st_table *, st_data_t, st_data_t *);
typedef int st_update_callback_func(st_data_t *key, st_data_t *value,
                                    st_data_t arg, int existing);

int st_update(st_table *table, st_data_t key, st_update_callback_func *func,
              st_data_t arg);
int st_foreach(st_table *, int (*)(), st_data_t);
int st_foreach_check(st_table *, int (*)(), st_data_t, st_data_t);
st_index_t st_keys(st_table *table, st_data_t *keys, st_index_t size);
st_index_t st_keys_check(st_table *table, st_data_t *keys, st_index_t size,
                         st_data_t never);
st_index_t st_values(st_table *table, st_data_t *values, st_index_t size);
st_index_t st_values_check(st_table *table, st_data_t *values, st_index_t size,
                           st_data_t never);
void st_add_direct(st_table *, st_data_t, st_data_t);
void st_free_table(st_table *);
void st_cleanup_safe(st_table *, st_data_t);
void st_clear(st_table *);
st_table *st_copy(st_table *);
__attribute__((__const__)) int st_numcmp(st_data_t, st_data_t);
__attribute__((__const__)) st_index_t st_numhash(st_data_t);
__attribute__((__pure__)) int st_locale_insensitive_strcasecmp(const char *s1,
                                                               const char *s2);
__attribute__((__pure__)) int
st_locale_insensitive_strncasecmp(const char *s1, const char *s2, size_t n);

__attribute__((__pure__)) size_t st_memsize(const st_table *);
__attribute__((__pure__)) st_index_t st_hash(const void *ptr, size_t len,
                                             st_index_t h);
__attribute__((__const__)) st_index_t st_hash_uint32(st_index_t h, uint32_t i);
__attribute__((__const__)) st_index_t st_hash_uint(st_index_t h, st_index_t i);
__attribute__((__const__)) st_index_t st_hash_end(st_index_t h);
__attribute__((__const__)) st_index_t st_hash_start(st_index_t h);

void rb_hash_bulk_insert_into_st_table(long, const VALUE *, VALUE);

#pragma GCC visibility pop
# 36 "./include/ruby/intern.h" 2
# 46 "./include/ruby/intern.h"
#pragma GCC visibility push(default)
# 56 "./include/ruby/intern.h"
void rb_mem_clear(register VALUE *, register long);
VALUE rb_assoc_new(VALUE, VALUE);
VALUE rb_check_array_type(VALUE);
VALUE rb_ary_new(void);
VALUE rb_ary_new_capa(long capa);
VALUE rb_ary_new_from_args(long n, ...);
VALUE rb_ary_new_from_values(long n, const VALUE *elts);
VALUE rb_ary_tmp_new(long);
void rb_ary_free(VALUE);
void rb_ary_modify(VALUE);
VALUE rb_ary_freeze(VALUE);
VALUE rb_ary_shared_with_p(VALUE, VALUE);
VALUE rb_ary_aref(int, const VALUE *, VALUE);
VALUE rb_ary_subseq(VALUE, long, long);
void rb_ary_store(VALUE, long, VALUE);
VALUE rb_ary_dup(VALUE);
VALUE rb_ary_resurrect(VALUE ary);
VALUE rb_ary_to_ary(VALUE);
VALUE rb_ary_to_s(VALUE);
VALUE rb_ary_cat(VALUE, const VALUE *, long);
VALUE rb_ary_push(VALUE, VALUE);
VALUE rb_ary_pop(VALUE);
VALUE rb_ary_shift(VALUE);
VALUE rb_ary_unshift(VALUE, VALUE);
VALUE rb_ary_entry(VALUE, long);
VALUE rb_ary_each(VALUE);
VALUE rb_ary_join(VALUE, VALUE);
VALUE rb_ary_reverse(VALUE);
VALUE rb_ary_rotate(VALUE, long);
VALUE rb_ary_sort(VALUE);
VALUE rb_ary_sort_bang(VALUE);
VALUE rb_ary_delete(VALUE, VALUE);
VALUE rb_ary_delete_at(VALUE, long);
VALUE rb_ary_clear(VALUE);
VALUE rb_ary_plus(VALUE, VALUE);
VALUE rb_ary_concat(VALUE, VALUE);
VALUE rb_ary_assoc(VALUE, VALUE);
VALUE rb_ary_rassoc(VALUE, VALUE);
VALUE rb_ary_includes(VALUE, VALUE);
VALUE rb_ary_cmp(VALUE, VALUE);
VALUE rb_ary_replace(VALUE copy, VALUE orig);
VALUE rb_get_values_at(VALUE, long, int, const VALUE *, VALUE (*)(VALUE, long));
VALUE rb_ary_resize(VALUE ary, long len);

VALUE rb_big_new(size_t, int);
int rb_bigzero_p(VALUE x);
VALUE rb_big_clone(VALUE);
void rb_big_2comp(VALUE);
VALUE rb_big_norm(VALUE);
void rb_big_resize(VALUE big, size_t len);
VALUE rb_cstr_to_inum(const char *, int, int);
VALUE rb_str_to_inum(VALUE, int, int);
VALUE rb_cstr2inum(const char *, int);
VALUE rb_str2inum(VALUE, int);
VALUE rb_big2str(VALUE, int);
long rb_big2long(VALUE);

unsigned long rb_big2ulong(VALUE);

long long rb_big2ll(VALUE);
unsigned long long rb_big2ull(VALUE);

void rb_big_pack(VALUE val, unsigned long *buf, long num_longs);
VALUE rb_big_unpack(unsigned long *buf, long num_longs);
int rb_uv_to_utf8(char[6], unsigned long);
VALUE rb_dbl2big(double);
double rb_big2dbl(VALUE);
VALUE rb_big_cmp(VALUE, VALUE);
VALUE rb_big_eq(VALUE, VALUE);
VALUE rb_big_eql(VALUE, VALUE);
VALUE rb_big_plus(VALUE, VALUE);
VALUE rb_big_minus(VALUE, VALUE);
VALUE rb_big_mul(VALUE, VALUE);
VALUE rb_big_div(VALUE, VALUE);
VALUE rb_big_idiv(VALUE, VALUE);
VALUE rb_big_modulo(VALUE, VALUE);
VALUE rb_big_divmod(VALUE, VALUE);
VALUE rb_big_pow(VALUE, VALUE);
VALUE rb_big_and(VALUE, VALUE);
VALUE rb_big_or(VALUE, VALUE);
VALUE rb_big_xor(VALUE, VALUE);
VALUE rb_big_lshift(VALUE, VALUE);
VALUE rb_big_rshift(VALUE, VALUE);
# 164 "./include/ruby/intern.h"
int rb_integer_pack(VALUE val, void *words, size_t numwords, size_t wordsize,
                    size_t nails, int flags);
VALUE rb_integer_unpack(const void *words, size_t numwords, size_t wordsize,
                        size_t nails, int flags);
size_t rb_absint_size(VALUE val, int *nlz_bits_ret);
size_t rb_absint_numwords(VALUE val, size_t word_numbits, size_t *nlz_bits_ret);
int rb_absint_singlebit_p(VALUE val);

VALUE rb_rational_raw(VALUE, VALUE);

VALUE rb_rational_new(VALUE, VALUE);

VALUE rb_Rational(VALUE, VALUE);

VALUE rb_rational_num(VALUE rat);
VALUE rb_rational_den(VALUE rat);
VALUE rb_flt_rationalize_with_prec(VALUE, VALUE);
VALUE rb_flt_rationalize(VALUE);

VALUE rb_complex_raw(VALUE, VALUE);

VALUE rb_complex_new(VALUE, VALUE);

VALUE rb_complex_polar(VALUE, VALUE);
VALUE rb_Complex(VALUE, VALUE);

VALUE rb_class_new(VALUE);
VALUE rb_mod_init_copy(VALUE, VALUE);
VALUE rb_singleton_class_clone(VALUE);
void rb_singleton_class_attached(VALUE, VALUE);
void rb_check_inheritable(VALUE);
VALUE rb_define_class_id(ID, VALUE);
VALUE rb_define_class_id_under(VALUE, ID, VALUE);
VALUE rb_module_new(void);
VALUE rb_define_module_id(ID);
VALUE rb_define_module_id_under(VALUE, ID);
VALUE rb_mod_included_modules(VALUE);
VALUE rb_mod_include_p(VALUE, VALUE);
VALUE rb_mod_ancestors(VALUE);
VALUE rb_class_instance_methods(int, const VALUE *, VALUE);
VALUE rb_class_public_instance_methods(int, const VALUE *, VALUE);
VALUE rb_class_protected_instance_methods(int, const VALUE *, VALUE);
VALUE rb_class_private_instance_methods(int, const VALUE *, VALUE);
VALUE rb_obj_singleton_methods(int, const VALUE *, VALUE);
void rb_define_method_id(VALUE, ID, VALUE (*)(), int);
void rb_undef(VALUE, ID);
void rb_define_protected_method(VALUE, const char *, VALUE (*)(), int);
void rb_define_private_method(VALUE, const char *, VALUE (*)(), int);
void rb_define_singleton_method(VALUE, const char *, VALUE (*)(), int);
VALUE rb_singleton_class(VALUE);

int rb_cmpint(VALUE, VALUE, VALUE);
__attribute__((__noreturn__)) void rb_cmperr(VALUE, VALUE);

VALUE rb_fiber_new(VALUE (*)(), VALUE);
VALUE rb_fiber_resume(VALUE fib, int argc, const VALUE *argv);
VALUE rb_fiber_yield(int argc, const VALUE *argv);
VALUE rb_fiber_current(void);
VALUE rb_fiber_alive_p(VALUE);

VALUE rb_enum_values_pack(int, const VALUE *);

VALUE rb_enumeratorize(VALUE, VALUE, int, const VALUE *);
typedef VALUE rb_enumerator_size_func(VALUE, VALUE, VALUE);
VALUE rb_enumeratorize_with_size(VALUE, VALUE, int, const VALUE *,
                                 rb_enumerator_size_func *);
# 248 "./include/ruby/intern.h"
VALUE rb_exc_new(VALUE, const char *, long);
VALUE rb_exc_new_cstr(VALUE, const char *);
VALUE rb_exc_new_str(VALUE, VALUE);

__attribute__((__noreturn__)) void rb_loaderror(const char *, ...)
    __attribute__((format(printf, 1, 2)));
__attribute__((__noreturn__)) void rb_loaderror_with_path(VALUE path,
                                                          const char *, ...)
    __attribute__((format(printf, 2, 3)));
__attribute__((__noreturn__)) void rb_name_error(ID, const char *, ...)
    __attribute__((format(printf, 2, 3)));
__attribute__((__noreturn__)) void rb_name_error_str(VALUE, const char *, ...)
    __attribute__((format(printf, 2, 3)));
__attribute__((__noreturn__)) void rb_invalid_str(const char *, const char *);
__attribute__((__noreturn__)) void rb_error_frozen(const char *);
__attribute__((__noreturn__)) void rb_error_frozen_object(VALUE);
void rb_error_untrusted(VALUE);
void rb_check_frozen(VALUE);
void rb_check_trusted(VALUE);
# 287 "./include/ruby/intern.h"
void rb_check_copyable(VALUE obj, VALUE orig);

int rb_sourceline(void);
const char *rb_sourcefile(void);
VALUE rb_check_funcall(VALUE, ID, int, const VALUE *);

__attribute__((__noreturn__)) void rb_error_arity(int, int, int);
static inline int rb_check_arity(int argc, int min, int max) {
  if ((argc < min) || (max != (-1) && argc > max))
    rb_error_arity(argc, min, max);
  return argc;
}

typedef struct {
  int maxfd;
  fd_set *fdset;
} rb_fdset_t;

void rb_fd_init(rb_fdset_t *);
void rb_fd_term(rb_fdset_t *);
void rb_fd_zero(rb_fdset_t *);
void rb_fd_set(int, rb_fdset_t *);
void rb_fd_clr(int, rb_fdset_t *);
int rb_fd_isset(int, const rb_fdset_t *);
void rb_fd_copy(rb_fdset_t *, const fd_set *, int);
void rb_fd_dup(rb_fdset_t *dst, const rb_fdset_t *src);

struct timeval;
int rb_fd_select(int, rb_fdset_t *, rb_fdset_t *, rb_fdset_t *,
                 struct timeval *);
# 379 "./include/ruby/intern.h"
__attribute__((__noreturn__)) void rb_exc_raise(VALUE);
__attribute__((__noreturn__)) void rb_exc_fatal(VALUE);
__attribute__((__noreturn__)) VALUE rb_f_exit(int, const VALUE *);
__attribute__((__noreturn__)) VALUE rb_f_abort(int, const VALUE *);
void rb_remove_method(VALUE, const char *);
void rb_remove_method_id(VALUE, ID);

typedef VALUE (*rb_alloc_func_t)(VALUE);
void rb_define_alloc_func(VALUE, rb_alloc_func_t);
void rb_undef_alloc_func(VALUE);
rb_alloc_func_t rb_get_alloc_func(VALUE);
void rb_clear_constant_cache(void);
void rb_clear_method_cache_by_class(VALUE);
void rb_alias(VALUE, ID, ID);
void rb_attr(VALUE, ID, int, int, int);
int rb_method_boundp(VALUE, ID, int);
int rb_method_basic_definition_p(VALUE, ID);
VALUE rb_eval_cmd(VALUE, VALUE, int);
int rb_obj_respond_to(VALUE, ID, int);
int rb_respond_to(VALUE, ID);
__attribute__((__noreturn__)) VALUE
rb_f_notimplement(int argc, const VALUE *argv, VALUE obj);

__attribute__((__noreturn__)) void rb_interrupt(void);
VALUE rb_apply(VALUE, ID, VALUE);
void rb_backtrace(void);
ID rb_frame_this_func(void);
VALUE rb_obj_instance_eval(int, const VALUE *, VALUE);
VALUE rb_obj_instance_exec(int, const VALUE *, VALUE);
VALUE rb_mod_module_eval(int, const VALUE *, VALUE);
VALUE rb_mod_module_exec(int, const VALUE *, VALUE);
void rb_load(VALUE, int);
void rb_load_protect(VALUE, int, int *);
__attribute__((__noreturn__)) void rb_jump_tag(int);
int rb_provided(const char *);
int rb_feature_provided(const char *, const char **);
void rb_provide(const char *);
VALUE rb_f_require(VALUE, VALUE);
VALUE rb_require_safe(VALUE, int);
void rb_obj_call_init(VALUE, int, const VALUE *);
VALUE rb_class_new_instance(int, const VALUE *, VALUE);
VALUE rb_block_proc(void);
VALUE rb_block_lambda(void);
VALUE rb_proc_new(VALUE (*)(), VALUE);
VALUE rb_obj_is_proc(VALUE);
VALUE rb_proc_call(VALUE, VALUE);
VALUE rb_proc_call_with_block(VALUE, int argc, const VALUE *argv, VALUE);
int rb_proc_arity(VALUE);
VALUE rb_proc_lambda_p(VALUE);
VALUE rb_binding_new(void);
VALUE rb_obj_method(VALUE, VALUE);
VALUE rb_obj_is_method(VALUE);
VALUE rb_method_call(int, const VALUE *, VALUE);
VALUE rb_method_call_with_block(int, const VALUE *, VALUE, VALUE);
int rb_mod_method_arity(VALUE, ID);
int rb_obj_method_arity(VALUE, ID);
VALUE rb_protect(VALUE (*)(VALUE), VALUE, int *);
void rb_set_end_proc(void (*)(VALUE), VALUE);
void rb_exec_end_proc(void);
void rb_thread_schedule(void);
void rb_thread_wait_fd(int);
int rb_thread_fd_writable(int);
void rb_thread_fd_close(int);
int rb_thread_alone(void);
void rb_thread_sleep(int);
void rb_thread_sleep_forever(void);
void rb_thread_sleep_deadly(void);
VALUE rb_thread_stop(void);
VALUE rb_thread_wakeup(VALUE);
VALUE rb_thread_wakeup_alive(VALUE);
VALUE rb_thread_run(VALUE);
VALUE rb_thread_kill(VALUE);
VALUE rb_thread_create(VALUE (*)(), void *);
int rb_thread_fd_select(int, rb_fdset_t *, rb_fdset_t *, rb_fdset_t *,
                        struct timeval *);
void rb_thread_wait_for(struct timeval);
VALUE rb_thread_current(void);
VALUE rb_thread_main(void);
VALUE rb_thread_local_aref(VALUE, ID);
VALUE rb_thread_local_aset(VALUE, ID, VALUE);
void rb_thread_atfork(void);
void rb_thread_atfork_before_exec(void);
VALUE rb_exec_recursive(VALUE (*)(VALUE, VALUE, int), VALUE, VALUE);
VALUE rb_exec_recursive_paired(VALUE (*)(VALUE, VALUE, int), VALUE, VALUE,
                               VALUE);
VALUE rb_exec_recursive_outer(VALUE (*)(VALUE, VALUE, int), VALUE, VALUE);
VALUE rb_exec_recursive_paired_outer(VALUE (*)(VALUE, VALUE, int), VALUE, VALUE,
                                     VALUE);

VALUE rb_dir_getwd(void);

VALUE rb_file_s_expand_path(int, const VALUE *);
VALUE rb_file_expand_path(VALUE, VALUE);
VALUE rb_file_s_absolute_path(int, const VALUE *);
VALUE rb_file_absolute_path(VALUE, VALUE);
VALUE rb_file_dirname(VALUE fname);
int rb_find_file_ext_safe(VALUE *, const char *const *, int);
VALUE rb_find_file_safe(VALUE, int);
int rb_find_file_ext(VALUE *, const char *const *);
VALUE rb_find_file(VALUE);
VALUE rb_file_directory_p(VALUE, VALUE);
VALUE rb_str_encode_ospath(VALUE);
int rb_is_absolute_path(const char *);

__attribute__((__noreturn__)) void rb_memerror(void);
__attribute__((__pure__)) int rb_during_gc(void);
void rb_gc_mark_locations(const VALUE *, const VALUE *);
void rb_mark_tbl(struct st_table *);
void rb_mark_set(struct st_table *);
void rb_mark_hash(struct st_table *);
void rb_gc_mark_maybe(VALUE);
void rb_gc_mark(VALUE);
void rb_gc_force_recycle(VALUE);
void rb_gc(void);
void rb_gc_copy_finalizer(VALUE, VALUE);
void rb_gc_finalize_deferred(void);
void rb_gc_call_finalizer_at_exit(void);
VALUE rb_gc_enable(void);
VALUE rb_gc_disable(void);
VALUE rb_gc_start(void);
VALUE rb_define_finalizer(VALUE, VALUE);
VALUE rb_undefine_finalizer(VALUE);
size_t rb_gc_count(void);
size_t rb_gc_stat(VALUE);
VALUE rb_gc_latest_gc_info(VALUE);
void rb_gc_adjust_memory_usage(ssize_t);

void st_foreach_safe(struct st_table *, int (*)(), st_data_t);
VALUE rb_check_hash_type(VALUE);
void rb_hash_foreach(VALUE, int (*)(), VALUE);
VALUE rb_hash(VALUE);
VALUE rb_hash_new(void);
VALUE rb_hash_dup(VALUE);
VALUE rb_hash_freeze(VALUE);
VALUE rb_hash_aref(VALUE, VALUE);
VALUE rb_hash_lookup(VALUE, VALUE);
VALUE rb_hash_lookup2(VALUE, VALUE, VALUE);
VALUE rb_hash_fetch(VALUE, VALUE);
VALUE rb_hash_aset(VALUE, VALUE, VALUE);
VALUE rb_hash_clear(VALUE);
VALUE rb_hash_delete_if(VALUE);
VALUE rb_hash_delete(VALUE, VALUE);
VALUE rb_hash_set_ifnone(VALUE hash, VALUE ifnone);
typedef VALUE rb_hash_update_func(VALUE newkey, VALUE oldkey, VALUE value);
VALUE rb_hash_update_by(VALUE hash1, VALUE hash2, rb_hash_update_func *func);
struct st_table *rb_hash_tbl(VALUE, const char *file, int line);
int rb_path_check(const char *);
int rb_env_path_tainted(void);
VALUE rb_env_clear(void);
VALUE rb_hash_size(VALUE);
void rb_hash_free(VALUE);

extern VALUE rb_fs;
extern VALUE rb_output_fs;
extern VALUE rb_rs;
extern VALUE rb_default_rs;
extern VALUE rb_output_rs;
VALUE rb_io_write(VALUE, VALUE);
VALUE rb_io_gets(VALUE);
VALUE rb_io_getbyte(VALUE);
VALUE rb_io_ungetc(VALUE, VALUE);
VALUE rb_io_ungetbyte(VALUE, VALUE);
VALUE rb_io_close(VALUE);
VALUE rb_io_flush(VALUE);
VALUE rb_io_eof(VALUE);
VALUE rb_io_binmode(VALUE);
VALUE rb_io_ascii8bit_binmode(VALUE);
VALUE rb_io_addstr(VALUE, VALUE);
VALUE rb_io_printf(int, const VALUE *, VALUE);
VALUE rb_io_print(int, const VALUE *, VALUE);
VALUE rb_io_puts(int, const VALUE *, VALUE);
VALUE rb_io_fdopen(int, int, const char *);
VALUE rb_io_get_io(VALUE);
VALUE rb_file_open(const char *, const char *);
VALUE rb_file_open_str(VALUE, const char *);
VALUE rb_gets(void);
void rb_write_error(const char *);
void rb_write_error2(const char *, long);
void rb_close_before_exec(int lowfd, int maxhint, VALUE noclose_fds);
int rb_pipe(int *pipes);
int rb_reserved_fd_p(int fd);
int rb_cloexec_open(const char *pathname, int flags, mode_t mode);
int rb_cloexec_dup(int oldfd);
int rb_cloexec_dup2(int oldfd, int newfd);
int rb_cloexec_pipe(int fildes[2]);
int rb_cloexec_fcntl_dupfd(int fd, int minfd);

void rb_update_max_fd(int fd);
void rb_fd_fix_cloexec(int fd);

VALUE rb_marshal_dump(VALUE, VALUE);
VALUE rb_marshal_load(VALUE);
void rb_marshal_define_compat(VALUE newclass, VALUE oldclass,
                              VALUE (*dumper)(VALUE),
                              VALUE (*loader)(VALUE, VALUE));

__attribute__((__noreturn__)) void rb_num_zerodiv(void);

VALUE rb_num_coerce_bin(VALUE, VALUE, ID);
VALUE rb_num_coerce_cmp(VALUE, VALUE, ID);
VALUE rb_num_coerce_relop(VALUE, VALUE, ID);
VALUE rb_num_coerce_bit(VALUE, VALUE, ID);
VALUE rb_num2fix(VALUE);
VALUE rb_fix2str(VALUE, int);
__attribute__((__const__)) VALUE rb_dbl_cmp(double, double);

int rb_eql(VALUE, VALUE);
VALUE rb_any_to_s(VALUE);
VALUE rb_inspect(VALUE);
VALUE rb_obj_is_instance_of(VALUE, VALUE);
VALUE rb_obj_is_kind_of(VALUE, VALUE);
VALUE rb_obj_alloc(VALUE);
VALUE rb_obj_clone(VALUE);
VALUE rb_obj_dup(VALUE);
VALUE rb_obj_init_copy(VALUE, VALUE);
VALUE rb_obj_taint(VALUE);
__attribute__((__pure__)) VALUE rb_obj_tainted(VALUE);
VALUE rb_obj_untaint(VALUE);
VALUE rb_obj_untrust(VALUE);
__attribute__((__pure__)) VALUE rb_obj_untrusted(VALUE);
VALUE rb_obj_trust(VALUE);
VALUE rb_obj_freeze(VALUE);
__attribute__((__pure__)) VALUE rb_obj_frozen_p(VALUE);
VALUE rb_obj_id(VALUE);
VALUE rb_obj_class(VALUE);
__attribute__((__pure__)) VALUE rb_class_real(VALUE);
__attribute__((__pure__)) VALUE rb_class_inherited_p(VALUE, VALUE);
VALUE rb_class_superclass(VALUE);
VALUE rb_class_get_superclass(VALUE);
VALUE rb_convert_type(VALUE, int, const char *, const char *);
VALUE rb_check_convert_type(VALUE, int, const char *, const char *);
VALUE rb_check_to_integer(VALUE, const char *);
VALUE rb_check_to_float(VALUE);
VALUE rb_to_int(VALUE);
VALUE rb_check_to_int(VALUE);
VALUE rb_Integer(VALUE);
VALUE rb_to_float(VALUE);
VALUE rb_Float(VALUE);
VALUE rb_String(VALUE);
VALUE rb_Array(VALUE);
VALUE rb_Hash(VALUE);
double rb_cstr_to_dbl(const char *, int);
double rb_str_to_dbl(VALUE, int);

ID rb_id_attrset(ID);
__attribute__((__const__)) int rb_is_const_id(ID);
__attribute__((__const__)) int rb_is_global_id(ID);
__attribute__((__const__)) int rb_is_instance_id(ID);
__attribute__((__const__)) int rb_is_attrset_id(ID);
__attribute__((__const__)) int rb_is_class_id(ID);
__attribute__((__const__)) int rb_is_local_id(ID);
__attribute__((__const__)) int rb_is_junk_id(ID);
int rb_symname_p(const char *);
int rb_sym_interned_p(VALUE);
VALUE rb_backref_get(void);
void rb_backref_set(VALUE);
VALUE rb_lastline_get(void);
void rb_lastline_set(VALUE);

void rb_last_status_set(int status, pid_t pid);
VALUE rb_last_status_get(void);
int rb_proc_exec(const char *);
__attribute__((__noreturn__)) VALUE rb_f_exec(int, const VALUE *);
pid_t rb_waitpid(pid_t pid, int *status, int flags);
void rb_syswait(pid_t pid);
pid_t rb_spawn(int, const VALUE *);
pid_t rb_spawn_err(int, const VALUE *, char *, size_t);
VALUE rb_proc_times(VALUE);
VALUE rb_detach_process(pid_t pid);

VALUE rb_range_new(VALUE, VALUE, int);
VALUE rb_range_beg_len(VALUE, long *, long *, long, int);
int rb_range_values(VALUE range, VALUE *begp, VALUE *endp, int *exclp);

unsigned int rb_genrand_int32(void);
double rb_genrand_real(void);
void rb_reset_random_seed(void);
VALUE rb_random_bytes(VALUE rnd, long n);
VALUE rb_random_int(VALUE rnd, VALUE max);
unsigned int rb_random_int32(VALUE rnd);
double rb_random_real(VALUE rnd);
unsigned long rb_random_ulong_limited(VALUE rnd, unsigned long limit);
unsigned long rb_genrand_ulong_limited(unsigned long i);

int rb_memcicmp(const void *, const void *, long);
void rb_match_busy(VALUE);
VALUE rb_reg_nth_defined(int, VALUE);
VALUE rb_reg_nth_match(int, VALUE);
int rb_reg_backref_number(VALUE match, VALUE backref);
VALUE rb_reg_last_match(VALUE);
VALUE rb_reg_match_pre(VALUE);
VALUE rb_reg_match_post(VALUE);
VALUE rb_reg_match_last(VALUE);

VALUE rb_reg_new_str(VALUE, int);
VALUE rb_reg_new(const char *, long, int);
VALUE rb_reg_alloc(void);
VALUE rb_reg_init_str(VALUE re, VALUE s, int options);
VALUE rb_reg_match(VALUE, VALUE);
VALUE rb_reg_match2(VALUE);
int rb_reg_options(VALUE);

extern VALUE rb_argv0;
VALUE rb_get_argv(void);
void *rb_load_file(const char *);
void *rb_load_file_str(VALUE);

VALUE rb_f_kill(int, const VALUE *);

void (*ruby_posix_signal(int, void (*)(int)))(int);

void rb_trap_exit(void);
void rb_trap_exec(void);
const char *ruby_signal_name(int);
void ruby_default_signal(int);

VALUE rb_f_sprintf(int, const VALUE *);
VALUE rb_sprintf(const char *, ...) __attribute__((format(printf, 1, 2)));
VALUE rb_vsprintf(const char *, va_list);
VALUE rb_str_catf(VALUE, const char *, ...)
    __attribute__((format(printf, 2, 3)));
VALUE rb_str_vcatf(VALUE, const char *, va_list);
VALUE rb_str_format(int, const VALUE *, VALUE);

VALUE rb_str_new(const char *, long);
VALUE rb_str_new_cstr(const char *);
VALUE rb_str_new_shared(VALUE);
VALUE rb_str_new_frozen(VALUE);
VALUE rb_str_new_with_class(VALUE, const char *, long);
VALUE rb_tainted_str_new_cstr(const char *);
VALUE rb_tainted_str_new(const char *, long);
VALUE rb_external_str_new(const char *, long);
VALUE rb_external_str_new_cstr(const char *);
VALUE rb_locale_str_new(const char *, long);
VALUE rb_locale_str_new_cstr(const char *);
VALUE rb_filesystem_str_new(const char *, long);
VALUE rb_filesystem_str_new_cstr(const char *);
VALUE rb_str_buf_new(long);
VALUE rb_str_buf_new_cstr(const char *);
VALUE rb_str_buf_new2(const char *);
VALUE rb_str_tmp_new(long);
VALUE rb_usascii_str_new(const char *, long);
VALUE rb_usascii_str_new_cstr(const char *);
VALUE rb_utf8_str_new(const char *, long);
VALUE rb_utf8_str_new_cstr(const char *);
VALUE rb_str_new_static(const char *, long);
VALUE rb_usascii_str_new_static(const char *, long);
VALUE rb_utf8_str_new_static(const char *, long);
void rb_str_free(VALUE);
void rb_str_shared_replace(VALUE, VALUE);
VALUE rb_str_buf_append(VALUE, VALUE);
VALUE rb_str_buf_cat(VALUE, const char *, long);
VALUE rb_str_buf_cat2(VALUE, const char *);
VALUE rb_str_buf_cat_ascii(VALUE, const char *);
VALUE rb_obj_as_string(VALUE);
VALUE rb_check_string_type(VALUE);
void rb_must_asciicompat(VALUE);
VALUE rb_str_dup(VALUE);
VALUE rb_str_resurrect(VALUE str);
VALUE rb_str_locktmp(VALUE);
VALUE rb_str_unlocktmp(VALUE);
VALUE rb_str_dup_frozen(VALUE);

VALUE rb_str_plus(VALUE, VALUE);
VALUE rb_str_times(VALUE, VALUE);
long rb_str_sublen(VALUE, long);
VALUE rb_str_substr(VALUE, long, long);
VALUE rb_str_subseq(VALUE, long, long);
char *rb_str_subpos(VALUE, long, long *);
void rb_str_modify(VALUE);
void rb_str_modify_expand(VALUE, long);
VALUE rb_str_freeze(VALUE);
void rb_str_set_len(VALUE, long);
VALUE rb_str_resize(VALUE, long);
VALUE rb_str_cat(VALUE, const char *, long);
VALUE rb_str_cat_cstr(VALUE, const char *);
VALUE rb_str_cat2(VALUE, const char *);
VALUE rb_str_append(VALUE, VALUE);
VALUE rb_str_concat(VALUE, VALUE);
st_index_t rb_memhash(const void *ptr, long len);
st_index_t rb_hash_start(st_index_t);
st_index_t rb_hash_uint32(st_index_t, uint32_t);
st_index_t rb_hash_uint(st_index_t, st_index_t);
st_index_t rb_hash_end(st_index_t);

st_index_t rb_str_hash(VALUE);
int rb_str_hash_cmp(VALUE, VALUE);
int rb_str_comparable(VALUE, VALUE);
int rb_str_cmp(VALUE, VALUE);
VALUE rb_str_equal(VALUE str1, VALUE str2);
VALUE rb_str_drop_bytes(VALUE, long);
void rb_str_update(VALUE, long, long, VALUE);
VALUE rb_str_replace(VALUE, VALUE);
VALUE rb_str_inspect(VALUE);
VALUE rb_str_dump(VALUE);
VALUE rb_str_split(VALUE, const char *);
void rb_str_setter(VALUE, ID, VALUE *);
VALUE rb_str_intern(VALUE);
VALUE rb_sym_to_s(VALUE);
long rb_str_strlen(VALUE);
VALUE rb_str_length(VALUE);
long rb_str_offset(VALUE, long);
__attribute__((__pure__)) size_t rb_str_capacity(VALUE);
VALUE rb_str_ellipsize(VALUE, long);
VALUE rb_str_scrub(VALUE, VALUE);

VALUE rb_sym_all_symbols(void);
# 873 "./include/ruby/intern.h"
VALUE rb_struct_new(VALUE, ...);
VALUE rb_struct_define(const char *, ...);
VALUE rb_struct_define_under(VALUE, const char *, ...);
VALUE rb_struct_alloc(VALUE, VALUE);
VALUE rb_struct_initialize(VALUE, VALUE);
VALUE rb_struct_aref(VALUE, VALUE);
VALUE rb_struct_aset(VALUE, VALUE, VALUE);
VALUE rb_struct_getmember(VALUE, ID);
VALUE rb_struct_s_members(VALUE);
VALUE rb_struct_members(VALUE);
VALUE rb_struct_size(VALUE s);
VALUE rb_struct_alloc_noinit(VALUE);
VALUE rb_struct_define_without_accessor(const char *, VALUE, rb_alloc_func_t,
                                        ...);
VALUE rb_struct_define_without_accessor_under(VALUE outer,
                                              const char *class_name,
                                              VALUE super,
                                              rb_alloc_func_t alloc, ...);

typedef void rb_unblock_function_t(void *);
typedef VALUE rb_blocking_function_t(void *);
void rb_thread_check_ints(void);
int rb_thread_interrupted(VALUE thval);

VALUE rb_mutex_new(void);
VALUE rb_mutex_locked_p(VALUE mutex);
VALUE rb_mutex_trylock(VALUE mutex);
VALUE rb_mutex_lock(VALUE mutex);
VALUE rb_mutex_unlock(VALUE mutex);
VALUE rb_mutex_sleep(VALUE self, VALUE timeout);
VALUE rb_mutex_synchronize(VALUE mutex, VALUE (*func)(VALUE arg), VALUE arg);

void rb_timespec_now(struct timespec *);
VALUE rb_time_new(time_t, long);
VALUE rb_time_nano_new(time_t, long);
VALUE rb_time_timespec_new(const struct timespec *, int);
VALUE rb_time_num_new(VALUE, VALUE);
struct timeval rb_time_interval(VALUE num);
struct timeval rb_time_timeval(VALUE time);
struct timespec rb_time_timespec(VALUE time);
VALUE rb_time_utc_offset(VALUE time);

VALUE rb_mod_name(VALUE);
VALUE rb_class_path(VALUE);
VALUE rb_class_path_cached(VALUE);
void rb_set_class_path(VALUE, VALUE, const char *);
void rb_set_class_path_string(VALUE, VALUE, VALUE);
VALUE rb_path_to_class(VALUE);
VALUE rb_path2class(const char *);
void rb_name_class(VALUE, ID);
VALUE rb_class_name(VALUE);
VALUE rb_autoload_load(VALUE, ID);
VALUE rb_autoload_p(VALUE, ID);
VALUE rb_f_trace_var(int, const VALUE *);
VALUE rb_f_untrace_var(int, const VALUE *);
VALUE rb_f_global_variables(void);
void rb_alias_variable(ID, ID);
void rb_copy_generic_ivar(VALUE, VALUE);
void rb_free_generic_ivar(VALUE);
VALUE rb_ivar_get(VALUE, ID);
VALUE rb_ivar_set(VALUE, ID, VALUE);
VALUE rb_ivar_defined(VALUE, ID);
void rb_ivar_foreach(VALUE, int (*)(), st_data_t);
st_index_t rb_ivar_count(VALUE);
VALUE rb_attr_get(VALUE, ID);
VALUE rb_obj_instance_variables(VALUE);
VALUE rb_obj_remove_instance_variable(VALUE, VALUE);
void *rb_mod_const_at(VALUE, void *);
void *rb_mod_const_of(VALUE, void *);
VALUE rb_const_list(void *);
VALUE rb_mod_constants(int, const VALUE *, VALUE);
VALUE rb_mod_remove_const(VALUE, VALUE);
int rb_const_defined(VALUE, ID);
int rb_const_defined_at(VALUE, ID);
int rb_const_defined_from(VALUE, ID);
VALUE rb_const_get(VALUE, ID);
VALUE rb_const_get_at(VALUE, ID);
VALUE rb_const_get_from(VALUE, ID);
void rb_const_set(VALUE, ID, VALUE);
VALUE rb_const_remove(VALUE, ID);

VALUE rb_cvar_defined(VALUE, ID);
void rb_cvar_set(VALUE, ID, VALUE);
VALUE rb_cvar_get(VALUE, ID);
void rb_cv_set(VALUE, const char *, VALUE);
VALUE rb_cv_get(VALUE, const char *);
void rb_define_class_variable(VALUE, const char *, VALUE);
VALUE rb_mod_class_variables(int, const VALUE *, VALUE);
VALUE rb_mod_remove_cvar(VALUE, VALUE);

ID rb_frame_callee(void);
VALUE rb_str_succ(VALUE);
VALUE rb_time_succ(VALUE);
VALUE rb_make_backtrace(void);
VALUE rb_make_exception(int, const VALUE *);

#pragma GCC visibility pop
# 2105 "./include/ruby/ruby.h" 2

static inline void rb_clone_setup(VALUE clone, VALUE obj) {
  rb_obj_setup(clone, rb_singleton_class_clone(obj),
               ((struct RBasic *)(obj))->flags &
                   ~(((VALUE)RUBY_FL_PROMOTED0) | ((VALUE)RUBY_FL_PROMOTED1) |
                     ((VALUE)RUBY_FL_FINALIZE)));
  rb_singleton_class_attached((((struct RBasic *)(clone))->klass), clone);
  if (((!(((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(obj))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((obj)))->flags & ((RUBY_FL_EXIVAR)))
           : 0))
    rb_copy_generic_ivar(clone, obj);
}

static inline void rb_dup_setup(VALUE dup, VALUE obj) {
  rb_obj_setup(dup, rb_obj_class(obj),
               (((struct RBasic *)(obj))->flags & (RUBY_FL_DUPPED)));
  if (((!(((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(obj))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((obj)))->flags & ((RUBY_FL_EXIVAR)))
           : 0))
    rb_copy_generic_ivar(dup, obj);
}

static inline long rb_array_len(VALUE a) {
  return (((struct RBasic *)(a))->flags & (VALUE)RARRAY_EMBED_FLAG)
             ? (long)((((struct RBasic *)(a))->flags >>
                       RARRAY_EMBED_LEN_SHIFT) &
                      ((VALUE)RARRAY_EMBED_LEN_MASK >> RARRAY_EMBED_LEN_SHIFT))
             : ((struct RArray *)(a))->as.heap.len;
}
# 2137 "./include/ruby/ruby.h"
static inline const VALUE *rb_array_const_ptr_transient(VALUE a) {
  return ((((struct RBasic *)(a))->flags & (VALUE)RARRAY_EMBED_FLAG)
              ? ((struct RArray *)(a))->as.ary
              : ((struct RArray *)(a))->as.heap.ptr);
}

static inline const VALUE *rb_array_const_ptr(VALUE a) {

  void rb_ary_detransient(VALUE a);

  if ((((struct RBasic *)((a)))->flags & (RARRAY_TRANSIENT_FLAG))) {
    rb_ary_detransient(a);
  }

  return rb_array_const_ptr_transient(a);
}
# 2164 "./include/ruby/ruby.h"
int ruby_native_thread_p(void);
# 2203 "./include/ruby/ruby.h"
typedef uint32_t rb_event_flag_t;
typedef void (*rb_event_hook_func_t)(rb_event_flag_t evflag, VALUE data,
                                     VALUE self, ID mid, VALUE klass);

void rb_add_event_hook(rb_event_hook_func_t func, rb_event_flag_t events,
                       VALUE data);
int rb_remove_event_hook(rb_event_hook_func_t func);

static inline int rb_isascii(int c) { return '\0' <= c && c <= '\x7f'; }
static inline int rb_isupper(int c) { return 'A' <= c && c <= 'Z'; }
static inline int rb_islower(int c) { return 'a' <= c && c <= 'z'; }
static inline int rb_isalpha(int c) { return rb_isupper(c) || rb_islower(c); }
static inline int rb_isdigit(int c) { return '0' <= c && c <= '9'; }
static inline int rb_isalnum(int c) { return rb_isalpha(c) || rb_isdigit(c); }
static inline int rb_isxdigit(int c) {
  return rb_isdigit(c) || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f');
}
static inline int rb_isblank(int c) { return c == ' ' || c == '\t'; }
static inline int rb_isspace(int c) {
  return c == ' ' || ('\t' <= c && c <= '\r');
}
static inline int rb_iscntrl(int c) {
  return ('\0' <= c && c < ' ') || c == '\x7f';
}
static inline int rb_isprint(int c) { return ' ' <= c && c <= '\x7e'; }
static inline int rb_ispunct(int c) { return !rb_isalnum(c); }
static inline int rb_isgraph(int c) { return '!' <= c && c <= '\x7e'; }
static inline int rb_tolower(int c) { return rb_isupper(c) ? (c | 0x20) : c; }
static inline int rb_toupper(int c) { return rb_islower(c) ? (c & 0x5f) : c; }
# 2243 "./include/ruby/ruby.h"
int st_locale_insensitive_strcasecmp(const char *s1, const char *s2);
int st_locale_insensitive_strncasecmp(const char *s1, const char *s2, size_t n);

unsigned long ruby_strtoul(const char *str, char **endptr, int base);

int ruby_snprintf(char *str, size_t n, char const *fmt, ...)
    __attribute__((format(printf, 3, 4)));
int ruby_vsnprintf(char *str, size_t n, char const *fmt, va_list ap);
# 2335 "./include/ruby/ruby.h"
__attribute__((__always_inline__)) static int
rb_scan_args_lead_p(const char *fmt);
static inline int rb_scan_args_lead_p(const char *fmt) {
  return ((unsigned char)((fmt[0]) - '0') < 10);
}

__attribute__((__always_inline__)) static int
rb_scan_args_n_lead(const char *fmt);
static inline int rb_scan_args_n_lead(const char *fmt) {
  return (rb_scan_args_lead_p(fmt) ? fmt[0] - '0' : 0);
}

__attribute__((__always_inline__)) static int
rb_scan_args_opt_p(const char *fmt);
static inline int rb_scan_args_opt_p(const char *fmt) {
  return (rb_scan_args_lead_p(fmt) && ((unsigned char)((fmt[1]) - '0') < 10));
}

__attribute__((__always_inline__)) static int
rb_scan_args_n_opt(const char *fmt);
static inline int rb_scan_args_n_opt(const char *fmt) {
  return (rb_scan_args_opt_p(fmt) ? fmt[1] - '0' : 0);
}

__attribute__((__always_inline__)) static int
rb_scan_args_var_idx(const char *fmt);
static inline int rb_scan_args_var_idx(const char *fmt) {
  return (!rb_scan_args_lead_p(fmt)
              ? 0
              : !((unsigned char)((fmt[1]) - '0') < 10) ? 1 : 2);
}

__attribute__((__always_inline__)) static int
rb_scan_args_f_var(const char *fmt);
static inline int rb_scan_args_f_var(const char *fmt) {
  return (fmt[rb_scan_args_var_idx(fmt)] == '*');
}

__attribute__((__always_inline__)) static int
rb_scan_args_trail_idx(const char *fmt);
static inline int rb_scan_args_trail_idx(const char *fmt) {
  const int idx = rb_scan_args_var_idx(fmt);
  return idx + (fmt[idx] == '*');
}

__attribute__((__always_inline__)) static int
rb_scan_args_n_trail(const char *fmt);
static inline int rb_scan_args_n_trail(const char *fmt) {
  const int idx = rb_scan_args_trail_idx(fmt);
  return (((unsigned char)((fmt[idx]) - '0') < 10) ? fmt[idx] - '0' : 0);
}

__attribute__((__always_inline__)) static int
rb_scan_args_hash_idx(const char *fmt);
static inline int rb_scan_args_hash_idx(const char *fmt) {
  const int idx = rb_scan_args_trail_idx(fmt);
  return idx + ((unsigned char)((fmt[idx]) - '0') < 10);
}

__attribute__((__always_inline__)) static int
rb_scan_args_f_hash(const char *fmt);
static inline int rb_scan_args_f_hash(const char *fmt) {
  return (fmt[rb_scan_args_hash_idx(fmt)] == ':');
}

__attribute__((__always_inline__)) static int
rb_scan_args_block_idx(const char *fmt);
static inline int rb_scan_args_block_idx(const char *fmt) {
  const int idx = rb_scan_args_hash_idx(fmt);
  return idx + (fmt[idx] == ':');
}

__attribute__((__always_inline__)) static int
rb_scan_args_f_block(const char *fmt);
static inline int rb_scan_args_f_block(const char *fmt) {
  return (fmt[rb_scan_args_block_idx(fmt)] == '&');
}
# 2444 "./include/ruby/ruby.h"
__attribute__((__always_inline__)) static int
rb_scan_args_set(int argc, const VALUE *argv, int n_lead, int n_opt,
                 int n_trail, int f_var, int f_hash, int f_block, VALUE *vars[],
                 char *fmt, int varc);

inline int rb_scan_args_set(int argc, const VALUE *argv, int n_lead, int n_opt,
                            int n_trail, int f_var, int f_hash, int f_block,
                            VALUE *vars[], char *fmt __attribute__((unused)),
                            int varc __attribute__((unused)))

    __attribute__((diagnose_if(
        (!((unsigned char)((fmt[0]) - '0') < 10)
             ? (fmt[0] != '*'
                    ? (!((unsigned char)((fmt[0]) - '0') < 10)
                           ? (fmt[0] != ':'
                                  ? (fmt[0] != '&' ? (fmt[0] ? 0 : (0))
                                                   : (fmt[0 + 1] ? 0 : (0 + 1)))
                                  : (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0 : (0 + 1))
                                         : (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1))))
                           : (fmt[0 + 1] != ':'
                                  ? (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0
                                                       : (0 + (fmt[0] - '0')))
                                         : (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1)))
                                  : (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1 +
                                                   1)))))
                    : (!((unsigned char)((fmt[0 + 1]) - '0') < 10)
                           ? (fmt[0 + 1] != ':'
                                  ? (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0 : (0 + 1))
                                         : (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1)))
                                  : (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + 1 + 1))))
                           : (fmt[0 + 1 + 1] != ':'
                                  ? (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0')))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1)))
                                  : (fmt[0 + 1 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1))
                                         : (fmt[0 + 1 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1 + 1))))))
             : (!((unsigned char)((fmt[1]) - '0') < 10)
                    ? (fmt[1] != '*'
                           ? (!((unsigned char)((fmt[1]) - '0') < 10)
                                  ? (fmt[1] != ':'
                                         ? (fmt[1] != '&'
                                                ? (fmt[1] ? 0 : (fmt[0] - '0'))
                                                : (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1)))
                                         : (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          1))))
                                  : (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0')))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1 +
                                                          1)))))
                           : (!((unsigned char)((fmt[1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0')))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1 + 1))))))
                    : (fmt[1 + 1] != '*'
                           ? (!((unsigned char)((fmt[1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1] ? 0
                                                              : (fmt[0] - '0' +
                                                                 fmt[1] - '0'))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0')))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1 + 1)))))
                           : (!((unsigned char)((fmt[1 + 1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 + 1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0')))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1 + 1)))))))) == 0,
        "bad scan arg format", "error")))
    __attribute__((diagnose_if(
        (!((unsigned char)((fmt[0]) - '0') < 10)
             ? (fmt[0] != '*'
                    ? (!((unsigned char)((fmt[0]) - '0') < 10)
                           ? (fmt[0] != ':'
                                  ? (fmt[0] != '&' ? (fmt[0] ? 0 : (0))
                                                   : (fmt[0 + 1] ? 0 : (0 + 1)))
                                  : (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0 : (0 + 1))
                                         : (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1))))
                           : (fmt[0 + 1] != ':'
                                  ? (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0
                                                       : (0 + (fmt[0] - '0')))
                                         : (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1)))
                                  : (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + (fmt[0] - '0') + 1 +
                                                   1)))))
                    : (!((unsigned char)((fmt[0 + 1]) - '0') < 10)
                           ? (fmt[0 + 1] != ':'
                                  ? (fmt[0 + 1] != '&'
                                         ? (fmt[0 + 1] ? 0 : (0 + 1))
                                         : (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1)))
                                  : (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1] ? 0 : (0 + 1 + 1))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + 1 + 1))))
                           : (fmt[0 + 1 + 1] != ':'
                                  ? (fmt[0 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0')))
                                         : (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1)))
                                  : (fmt[0 + 1 + 1 + 1] != '&'
                                         ? (fmt[0 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1))
                                         : (fmt[0 + 1 + 1 + 1 + 1]
                                                ? 0
                                                : (0 + 1 + (fmt[0 + 1] - '0') +
                                                   1 + 1))))))
             : (!((unsigned char)((fmt[1]) - '0') < 10)
                    ? (fmt[1] != '*'
                           ? (!((unsigned char)((fmt[1]) - '0') < 10)
                                  ? (fmt[1] != ':'
                                         ? (fmt[1] != '&'
                                                ? (fmt[1] ? 0 : (fmt[0] - '0'))
                                                : (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1)))
                                         : (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          1))))
                                  : (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0')))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          (fmt[1] - '0') + 1 +
                                                          1)))))
                           : (!((unsigned char)((fmt[1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0')))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' + 1 +
                                                          (fmt[1 + 1] - '0') +
                                                          1 + 1))))))
                    : (fmt[1 + 1] != '*'
                           ? (!((unsigned char)((fmt[1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1] != ':'
                                         ? (fmt[1 + 1] != '&'
                                                ? (fmt[1 + 1] ? 0
                                                              : (fmt[0] - '0' +
                                                                 fmt[1] - '0'))
                                                : (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1)))
                                         : (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0')))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' +
                                                          (fmt[1 + 1] - '0') +
                                                          1 + 1)))))
                           : (!((unsigned char)((fmt[1 + 1 + 1]) - '0') < 10)
                                  ? (fmt[1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1))
                                                : (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 + 1))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 + 1 +
                                                          1))))
                                  : (fmt[1 + 1 + 1 + 1] != ':'
                                         ? (fmt[1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0')))
                                                : (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1)))
                                         : (fmt[1 + 1 + 1 + 1 + 1] != '&'
                                                ? (fmt[1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1))
                                                : (fmt[1 + 1 + 1 + 1 + 1 + 1]
                                                       ? 0
                                                       : (fmt[0] - '0' +
                                                          fmt[1] - '0' + 1 +
                                                          (fmt[1 + 1 + 1] -
                                                           '0') +
                                                          1 + 1)))))))) != varc,
        "variable argument length doesn't match", "error")))

{
  int i, argi = 0, vari = 0, last_idx = -1;
  VALUE *var, hash = ((VALUE)RUBY_Qnil), last_hash = 0;
  const int n_mand = n_lead + n_trail;

  if (f_hash && n_mand < argc) {
    VALUE last = argv[argc - 1];

    if (!((VALUE)(last) != ((VALUE)RUBY_Qnil))) {

      if (!f_var && n_mand + n_opt < argc)
        argc--;
    } else {
      hash = rb_check_hash_type(last);
      if (!!((VALUE)(hash) != ((VALUE)RUBY_Qnil))) {
        VALUE opts = rb_extract_keywords(&hash);
        if (!(last_hash = hash))
          argc--;
        else
          last_idx = argc - 1;
        hash = opts ? opts : ((VALUE)RUBY_Qnil);
      }
    }
  }

  rb_check_arity(argc, n_mand, f_var ? (-1) : n_mand + n_opt);

  for (i = n_lead; i-- > 0;) {
    var = vars[vari++];
    if (var)
      *var = (argi == last_idx) ? last_hash : argv[argi];
    argi++;
  }

  for (i = n_opt; i-- > 0;) {
    var = vars[vari++];
    if (argi < argc - n_trail) {
      if (var)
        *var = (argi == last_idx) ? last_hash : argv[argi];
      argi++;
    } else {
      if (var)
        *var = ((VALUE)RUBY_Qnil);
    }
  }

  if (f_var) {
    int n_var = argc - argi - n_trail;

    var = vars[vari++];
    if (0 < n_var) {
      if (var) {
        int f_last = (last_idx + 1 == argc - n_trail);
        *var = rb_ary_new_from_values(n_var - f_last, &argv[argi]);
        if (f_last)
          rb_ary_push(*var, last_hash);
      }
      argi += n_var;
    } else {
      if (var)
        *var = rb_ary_new();
    }
  }

  for (i = n_trail; i-- > 0;) {
    var = vars[vari++];
    if (var)
      *var = (argi == last_idx) ? last_hash : argv[argi];
    argi++;
  }

  if (f_hash) {
    var = vars[vari++];
    if (var)
      *var = hash;
  }

  if (f_block) {
    var = vars[vari++];
    if (rb_block_given_p()) {
      *var = rb_block_proc();
    } else {
      *var = ((VALUE)RUBY_Qnil);
    }
  }

  return argc;
}
# 2573 "./include/ruby/ruby.h"
# 1 "./include/ruby/subst.h" 1
# 2574 "./include/ruby/ruby.h" 2
# 2592 "./include/ruby/ruby.h"
void ruby_sysinit(int *argc, char ***argv);
void ruby_init(void);
void *ruby_options(int argc, char **argv);
int ruby_executable_node(void *n, int *status);
int ruby_run_node(void *n);

void ruby_show_version(void);
void ruby_show_copyright(void);
# 2614 "./include/ruby/ruby.h"
void ruby_init_stack(volatile VALUE *);

int ruby_setup(void);
int ruby_cleanup(volatile int);

void ruby_finalize(void);
__attribute__((__noreturn__)) void ruby_stop(int);

void ruby_set_stack_size(size_t);
int ruby_stack_check(void);
size_t ruby_stack_length(VALUE **);

int ruby_exec_node(void *n);

void ruby_script(const char *name);
void ruby_set_script_name(VALUE name);

void ruby_prog_init(void);
void ruby_set_argv(int, char **);
void *ruby_process_options(int, char **);
void ruby_init_loadpath(void);
void ruby_incpush(const char *);
void ruby_sig_finalize(void);

#pragma GCC visibility pop
# 34 "./include/ruby.h" 2
# 16 "./internal.h" 2
# 25 "./internal.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stdbool.h" 1 3 4
# 26 "./internal.h" 2
# 86 "./internal.h"
# 1 "/usr/local/include/valgrind/memcheck.h" 1 3
# 72 "/usr/local/include/valgrind/memcheck.h" 3
# 1 "/usr/local/include/valgrind/valgrind.h" 1 3
# 399 "/usr/local/include/valgrind/valgrind.h" 3
typedef struct {
  unsigned long int nraddr;
} OrigFn;
# 6126 "/usr/local/include/valgrind/valgrind.h" 3
typedef enum {
  VG_USERREQ__RUNNING_ON_VALGRIND = 0x1001,
  VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,

  VG_USERREQ__CLIENT_CALL0 = 0x1101,
  VG_USERREQ__CLIENT_CALL1 = 0x1102,
  VG_USERREQ__CLIENT_CALL2 = 0x1103,
  VG_USERREQ__CLIENT_CALL3 = 0x1104,

  VG_USERREQ__COUNT_ERRORS = 0x1201,

  VG_USERREQ__GDB_MONITOR_COMMAND = 0x1202,

  VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,
  VG_USERREQ__RESIZEINPLACE_BLOCK = 0x130b,
  VG_USERREQ__FREELIKE_BLOCK = 0x1302,

  VG_USERREQ__CREATE_MEMPOOL = 0x1303,
  VG_USERREQ__DESTROY_MEMPOOL = 0x1304,
  VG_USERREQ__MEMPOOL_ALLOC = 0x1305,
  VG_USERREQ__MEMPOOL_FREE = 0x1306,
  VG_USERREQ__MEMPOOL_TRIM = 0x1307,
  VG_USERREQ__MOVE_MEMPOOL = 0x1308,
  VG_USERREQ__MEMPOOL_CHANGE = 0x1309,
  VG_USERREQ__MEMPOOL_EXISTS = 0x130a,
# 6171 "/usr/local/include/valgrind/valgrind.h" 3
  VG_USERREQ__PRINTF = 0x1401,
  VG_USERREQ__PRINTF_BACKTRACE = 0x1402,

  VG_USERREQ__PRINTF_VALIST_BY_REF = 0x1403,
  VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF = 0x1404,

  VG_USERREQ__STACK_REGISTER = 0x1501,
  VG_USERREQ__STACK_DEREGISTER = 0x1502,
  VG_USERREQ__STACK_CHANGE = 0x1503,

  VG_USERREQ__LOAD_PDB_DEBUGINFO = 0x1601,

  VG_USERREQ__MAP_IP_TO_SRCLOC = 0x1701,

  VG_USERREQ__CHANGE_ERR_DISABLEMENT = 0x1801,

  VG_USERREQ__VEX_INIT_FOR_IRI = 0x1901,

  VG_USERREQ__INNER_THREADS = 0x1902
} Vg_ClientRequest;
# 6240 "/usr/local/include/valgrind/valgrind.h" 3
static int VALGRIND_PRINTF(const char *format, ...)
    __attribute__((format(__printf__, 1, 2), __unused__));

static int

VALGRIND_PRINTF(const char *format, ...) {

  unsigned long _qzz_res;

  va_list vargs;
  __builtin_va_start(vargs, format);

  _qzz_res = __extension__({
    volatile unsigned long int _zzq_args[6];
    volatile unsigned long int _zzq_result;
    _zzq_args[0] = (unsigned long int)(VG_USERREQ__PRINTF_VALIST_BY_REF);
    _zzq_args[1] = (unsigned long int)((unsigned long)format);
    _zzq_args[2] = (unsigned long int)((unsigned long)&vargs);
    _zzq_args[3] = (unsigned long int)(0);
    _zzq_args[4] = (unsigned long int)(0);
    _zzq_args[5] = (unsigned long int)(0);
    __asm__ volatile("rolq $3,  %%rdi ; rolq $13, %%rdi\n\t"
                     "rolq $61, %%rdi ; rolq $51, %%rdi\n\t"
                     "xchgq %%rbx,%%rbx"
                     : "=d"(_zzq_result)
                     : "a"(&_zzq_args[0]), "0"(0)
                     : "cc", "memory");
    _zzq_result;
  });

  __builtin_va_end(vargs);
  return (int)_qzz_res;
}

static int VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
    __attribute__((format(__printf__, 1, 2), __unused__));

static int

VALGRIND_PRINTF_BACKTRACE(const char *format, ...) {

  unsigned long _qzz_res;

  va_list vargs;
  __builtin_va_start(vargs, format);

  _qzz_res = __extension__({
    volatile unsigned long int _zzq_args[6];
    volatile unsigned long int _zzq_result;
    _zzq_args[0] =
        (unsigned long int)(VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF);
    _zzq_args[1] = (unsigned long int)((unsigned long)format);
    _zzq_args[2] = (unsigned long int)((unsigned long)&vargs);
    _zzq_args[3] = (unsigned long int)(0);
    _zzq_args[4] = (unsigned long int)(0);
    _zzq_args[5] = (unsigned long int)(0);
    __asm__ volatile("rolq $3,  %%rdi ; rolq $13, %%rdi\n\t"
                     "rolq $61, %%rdi ; rolq $51, %%rdi\n\t"
                     "xchgq %%rbx,%%rbx"
                     : "=d"(_zzq_result)
                     : "a"(&_zzq_args[0]), "0"(0)
                     : "cc", "memory");
    _zzq_result;
  });

  __builtin_va_end(vargs);
  return (int)_qzz_res;
}
# 73 "/usr/local/include/valgrind/memcheck.h" 2 3

typedef enum {
  VG_USERREQ__MAKE_MEM_NOACCESS =
      ((unsigned int)((('M') & 0xff) << 24 | (('C') & 0xff) << 16)),
  VG_USERREQ__MAKE_MEM_UNDEFINED,
  VG_USERREQ__MAKE_MEM_DEFINED,
  VG_USERREQ__DISCARD,
  VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE,
  VG_USERREQ__CHECK_MEM_IS_DEFINED,
  VG_USERREQ__DO_LEAK_CHECK,
  VG_USERREQ__COUNT_LEAKS,

  VG_USERREQ__GET_VBITS,
  VG_USERREQ__SET_VBITS,

  VG_USERREQ__CREATE_BLOCK,

  VG_USERREQ__MAKE_MEM_DEFINED_IF_ADDRESSABLE,

  VG_USERREQ__COUNT_LEAK_BLOCKS,

  VG_USERREQ__ENABLE_ADDR_ERROR_REPORTING_IN_RANGE,
  VG_USERREQ__DISABLE_ADDR_ERROR_REPORTING_IN_RANGE,

  _VG_USERREQ__MEMCHECK_RECORD_OVERLAP_ERROR =
      ((unsigned int)((('M') & 0xff) << 24 | (('C') & 0xff) << 16)) + 256
} Vg_MemCheckClientRequest;
# 87 "./internal.h" 2
# 111 "./internal.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 1 3 4
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 1 3 4
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/stddef.h" 1 3 4
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 3 4
typedef struct {

  int coverage_sandboxed;

  intptr_t coverage_fd;

  unsigned int coverage_max_block_size;
} __sanitizer_sandbox_arguments;

void __sanitizer_set_report_path(const char *path);

void __sanitizer_set_report_fd(void *fd);

void __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);

void __sanitizer_report_error_summary(const char *error_summary);

uint16_t __sanitizer_unaligned_load16(const void *p);
uint32_t __sanitizer_unaligned_load32(const void *p);
uint64_t __sanitizer_unaligned_load64(const void *p);
void __sanitizer_unaligned_store16(void *p, uint16_t x);
void __sanitizer_unaligned_store32(void *p, uint32_t x);
void __sanitizer_unaligned_store64(void *p, uint64_t x);
# 98 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 3 4
void __sanitizer_annotate_contiguous_container(const void *beg, const void *end,
                                               const void *old_mid,
                                               const void *new_mid);

int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,
                                            const void *end);

const void *__sanitizer_contiguous_container_find_bad_address(const void *beg,
                                                              const void *mid,
                                                              const void *end);

void __sanitizer_print_stack_trace(void);

void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,
                              size_t out_buf_size);

void __sanitizer_symbolize_global(void *data_ptr, const char *fmt,
                                  char *out_buf, size_t out_buf_size);

void __sanitizer_set_death_callback(void (*callback)(void));

void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,
                                  const void *s2, size_t n, int result);
void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,
                                   const char *s2, size_t n, int result);
void __sanitizer_weak_hook_strncasecmp(void *called_pc, const char *s1,
                                       const char *s2, size_t n, int result);
void __sanitizer_weak_hook_strcmp(void *called_pc, const char *s1,
                                  const char *s2, int result);
void __sanitizer_weak_hook_strcasecmp(void *called_pc, const char *s1,
                                      const char *s2, int result);
void __sanitizer_weak_hook_strstr(void *called_pc, const char *s1,
                                  const char *s2, char *result);
void __sanitizer_weak_hook_strcasestr(void *called_pc, const char *s1,
                                      const char *s2, char *result);
void __sanitizer_weak_hook_memmem(void *called_pc, const void *s1, size_t len1,
                                  const void *s2, size_t len2, void *result);

void __sanitizer_print_memory_profile(size_t top_percent,
                                      size_t max_number_of_contexts);
# 182 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/common_interface_defs.h" 3 4
void __sanitizer_start_switch_fiber(void **fake_stack_save, const void *bottom,
                                    size_t size);
void __sanitizer_finish_switch_fiber(void *fake_stack_save,
                                     const void **bottom_old, size_t *size_old);

int __sanitizer_get_module_and_offset_for_pc(void *pc, char *module_path,
                                             size_t module_path_len,
                                             void **pc_offset);
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 2 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 3 4
void __asan_poison_memory_region(void const volatile *addr, size_t size);

void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
# 56 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 3 4
int __asan_address_is_poisoned(void const volatile *addr);

void *__asan_region_is_poisoned(void *beg, size_t size);

void __asan_describe_address(void *addr);

int __asan_report_present(void);

void *__asan_get_report_pc(void);
void *__asan_get_report_bp(void);
void *__asan_get_report_sp(void);
void *__asan_get_report_address(void);
int __asan_get_report_access_type(void);
size_t __asan_get_report_access_size(void);
const char *__asan_get_report_description(void);
# 88 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 3 4
const char *__asan_locate_address(void *addr, char *name, size_t name_size,
                                  void **region_address, size_t *region_size);

size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,
                              int *thread_id);

size_t __asan_get_free_stack(void *addr, void **trace, size_t size,
                             int *thread_id);

void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);

void __asan_report_error(void *pc, void *bp, void *sp, void *addr, int is_write,
                         size_t access_size);

void __asan_set_death_callback(void (*callback)(void));

void __asan_set_error_report_callback(void (*callback)(const char *));

void __asan_on_error(void);

void __asan_print_accumulated_stats(void);

const char *__asan_default_options(void);

void *__asan_get_current_fake_stack(void);
# 144 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/asan_interface.h" 3 4
void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,
                                   void **end);

void __asan_handle_no_return(void);
# 112 "./internal.h" 2
# 121 "./internal.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/msan_interface.h" 1 3 4
# 23 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include/sanitizer/msan_interface.h" 3 4
void __msan_set_origin(const volatile void *a, size_t size, uint32_t origin);

uint32_t __msan_get_origin(const volatile void *a);

int __msan_origin_is_descendant_or_same(uint32_t this_id, uint32_t prev_id);

int __msan_get_track_origins(void);

uint32_t __msan_get_umr_origin(void);

void __msan_unpoison(const volatile void *a, size_t size);

void __msan_unpoison_string(const volatile char *a);

void __msan_poison(const volatile void *a, size_t size);

void __msan_partial_poison(const volatile void *data, void *shadow,
                           size_t size);

intptr_t __msan_test_shadow(const volatile void *x, size_t size);

void __msan_check_mem_is_initialized(const volatile void *x, size_t size);

void __msan_set_expect_umr(int expect_umr);

void __msan_set_keep_going(int keep_going);

void __msan_print_shadow(const volatile void *x, size_t size);

void __msan_dump_shadow(const volatile void *x, size_t size);

int __msan_has_dynamic_component(void);

void __msan_allocated_memory(const volatile void *data, size_t size);

void __sanitizer_dtor_callback(const volatile void *data, size_t size);

const char *__msan_default_options(void);

void __msan_set_death_callback(void (*callback)(void));

void __msan_copy_shadow(const volatile void *dst, const volatile void *src,
                        size_t size);
# 122 "./internal.h" 2
# 131 "./internal.h"
static inline void poison_memory_region(const volatile void *ptr, size_t size) {
  ;
  ;
}

static inline void poison_object(VALUE obj) {
  struct RVALUE *ptr = (void *)obj;
  poison_memory_region(ptr, 8);
}

static inline void unpoison_memory_region(const volatile void *ptr, size_t size,
                                          _Bool malloc_p) {
  ;
  if (malloc_p) {
    ;
  } else {
    ;
  }
}

static inline void unpoison_object(VALUE obj, _Bool newobj_p) {
  struct RVALUE *ptr = (void *)obj;
  unpoison_memory_region(ptr, 8, newobj_p);
}
# 273 "./internal.h"
static inline unsigned int nlz_int(unsigned int x) {

  if (x == 0)
    return 4 * 8;
  return (unsigned int)__builtin_clz(x);
# 301 "./internal.h"
}

static inline unsigned int nlz_long(unsigned long x) {

  if (x == 0)
    return 8 * 8;
  return (unsigned int)__builtin_clzl(x);
# 331 "./internal.h"
}

static inline unsigned int nlz_long_long(unsigned long long x) {

  if (x == 0)
    return 8 * 8;
  return (unsigned int)__builtin_clzll(x);
# 362 "./internal.h"
}

static inline unsigned int nlz_int128(unsigned __int128 x) {
  unsigned __int128 y;
  unsigned int n = 128;
  y = x >> 64;
  if (y) {
    n -= 64;
    x = y;
  }
  y = x >> 32;
  if (y) {
    n -= 32;
    x = y;
  }
  y = x >> 16;
  if (y) {
    n -= 16;
    x = y;
  }
  y = x >> 8;
  if (y) {
    n -= 8;
    x = y;
  }
  y = x >> 4;
  if (y) {
    n -= 4;
    x = y;
  }
  y = x >> 2;
  if (y) {
    n -= 2;
    x = y;
  }
  y = x >> 1;
  if (y) {
    return n - 2;
  }
  return (unsigned int)(n - x);
}

static inline unsigned int nlz_intptr(uintptr_t x) { return nlz_long(x); }

static inline unsigned int rb_popcount32(uint32_t x) {

  return (unsigned int)__builtin_popcount(x);
}

static inline int rb_popcount64(uint64_t x) {

  return __builtin_popcountll(x);
# 424 "./internal.h"
}

static inline int rb_popcount_intptr(uintptr_t x) { return rb_popcount64(x); }

static inline int ntz_int32(uint32_t x) { return __builtin_ctz(x); }

static inline int ntz_int64(uint64_t x) { return __builtin_ctzll(x); }

static inline int ntz_intptr(uintptr_t x) { return ntz_int64(x); }

VALUE rb_int128t2big(__int128 n);

static inline long rb_overflowed_fix_to_int(long x) {
  return (long)((unsigned long)(x >> 1) ^ (1LU << (8 * 8 - 1)));
}

static inline VALUE rb_fix_plus_fix(VALUE x, VALUE y) {

  long lz;
# 506 "./internal.h"
  if (__builtin_add_overflow((long)x, (long)y - 1, &lz)) {
    return rb_int2big(rb_overflowed_fix_to_int(lz));
  } else {
    return (VALUE)lz;
  }
}

static inline VALUE rb_fix_minus_fix(VALUE x, VALUE y) {

  long lz;
  if (__builtin_sub_overflow((long)x, (long)y - 1, &lz)) {
    return rb_int2big(rb_overflowed_fix_to_int(lz));
  } else {
    return (VALUE)lz;
  }
}

static inline VALUE rb_fix_mul_fix(VALUE x, VALUE y) {
  long lx = ((long)(((long)(x)) >> (int)(1)));
  long ly = ((long)(((long)(y)) >> (int)(1)));

  return (((((__int128)lx * (__int128)ly) < (9223372036854775807L >> 1) + 1) &&
           (((__int128)lx * (__int128)ly) >=
            (((long)(-9223372036854775807L - 1L)) >> (int)(1))))
              ? (((VALUE)((__int128)lx * (__int128)ly)) << 1 | RUBY_FIXNUM_FLAG)
              : rb_int128t2big((__int128)lx * (__int128)ly));
# 551 "./internal.h"
}

static inline void rb_fix_divmod_fix(VALUE a, VALUE b, VALUE *divp,
                                     VALUE *modp) {

  long x = ((long)(((long)(a)) >> (int)(1)));
  long y = ((long)(((long)(b)) >> (int)(1)));
  long div, mod;
  if (x == (((long)(-9223372036854775807L - 1L)) >> (int)(1)) && y == -1) {
    if (divp)
      *divp = rb_long2num_inline(
          -(((long)(-9223372036854775807L - 1L)) >> (int)(1)));
    if (modp)
      *modp = (((VALUE)(0)) << 1 | RUBY_FIXNUM_FLAG);
    return;
  }
  div = x / y;
  mod = x % y;
  if (y > 0 ? mod < 0 : mod > 0) {
    mod += y;
    div -= 1;
  }
  if (divp)
    *divp = (((VALUE)(div)) << 1 | RUBY_FIXNUM_FLAG);
  if (modp)
    *modp = (((VALUE)(mod)) << 1 | RUBY_FIXNUM_FLAG);
}

static inline VALUE rb_fix_div_fix(VALUE x, VALUE y) {
  VALUE div;
  rb_fix_divmod_fix(x, y, &div, ((void *)0));
  return div;
}

static inline VALUE rb_fix_mod_fix(VALUE x, VALUE y) {
  VALUE mod;
  rb_fix_divmod_fix(x, y, ((void *)0), &mod);
  return mod;
}
# 693 "./internal.h"
struct RBignum {
  struct RBasic basic;
  union {
    struct {
      size_t len;
      unsigned int *digits;
    } heap;
    unsigned int ary[(8 * 3 / 4)];
  } as;
};
# 732 "./internal.h"
struct RRational {
  struct RBasic basic;
  const VALUE num;
  const VALUE den;
};

struct RFloat {
  struct RBasic basic;
  double float_value;
};

struct RComplex {
  struct RBasic basic;
  const VALUE real;
  const VALUE imag;
};

enum ruby_rhash_flags {
  RHASH_ST_TABLE_FLAG = ((VALUE)RUBY_FL_USER3),
  RHASH_ARRAY_MAX_SIZE = 8,
  RHASH_ARRAY_SIZE_MASK = (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5) |
                           ((VALUE)RUBY_FL_USER6) | ((VALUE)RUBY_FL_USER7)),
  RHASH_ARRAY_SIZE_SHIFT = (((VALUE)RUBY_FL_USHIFT) + 4),
  RHASH_ARRAY_BOUND_MASK = (((VALUE)RUBY_FL_USER8) | ((VALUE)RUBY_FL_USER9) |
                            ((VALUE)RUBY_FL_USER10) | ((VALUE)RUBY_FL_USER11)),
  RHASH_ARRAY_BOUND_SHIFT = (((VALUE)RUBY_FL_USHIFT) + 8),

  RHASH_ENUM_END
};

int rb_hash_array_p(VALUE hash);
struct li_table *rb_hash_array(VALUE hash);
st_table *rb_hash_st_table(VALUE hash);
void rb_hash_st_table_set(VALUE hash, st_table *st);
# 816 "./internal.h"
typedef struct li_table_entry {
  VALUE hash;
  VALUE key;
  VALUE record;
} li_table_entry;

typedef struct li_table {
  li_table_entry entries[8];
} li_table;
# 835 "./internal.h"
struct RHash {
  struct RBasic basic;
  union {
    struct st_table *st;
    struct li_table *li;
  } as;
  int iter_lev;
  const VALUE ifnone;
};
# 857 "./internal.h"
extern void ruby_init_setproctitle(int argc, char *argv[]);

enum {
  RSTRUCT_EMBED_LEN_MAX = 3,
  RSTRUCT_EMBED_LEN_MASK = (RUBY_FL_USER2 | RUBY_FL_USER1),
  RSTRUCT_EMBED_LEN_SHIFT = (RUBY_FL_USHIFT + 1),
  RSTRUCT_TRANSIENT_FLAG = ((VALUE)RUBY_FL_USER3),

  RSTRUCT_ENUM_END
};
# 883 "./internal.h"
struct RStruct {
  struct RBasic basic;
  union {
    struct {
      long len;
      const VALUE *ptr;
    } heap;
    const VALUE ary[RSTRUCT_EMBED_LEN_MAX];
  } as;
};
# 909 "./internal.h"
static inline long rb_struct_len(VALUE st) {
  return (((struct RBasic *)(st))->flags & RSTRUCT_EMBED_LEN_MASK)
             ? (long)((((struct RBasic *)(st))->flags >>
                       RSTRUCT_EMBED_LEN_SHIFT) &
                      (RSTRUCT_EMBED_LEN_MASK >> RSTRUCT_EMBED_LEN_SHIFT))
             : ((struct RStruct *)(st))->as.heap.len;
}

static inline const VALUE *rb_struct_const_ptr(VALUE st) {
  return ((((struct RBasic *)(st))->flags & RSTRUCT_EMBED_LEN_MASK)
              ? ((struct RStruct *)(st))->as.ary
              : ((struct RStruct *)(st))->as.heap.ptr);
}

static inline const VALUE *rb_struct_const_heap_ptr(VALUE st) {

  return ((struct RStruct *)(st))->as.heap.ptr;
}

struct rb_deprecated_classext_struct {
  char conflict[sizeof(VALUE) * 3];
};

struct rb_subclass_entry;
typedef struct rb_subclass_entry rb_subclass_entry_t;

struct rb_subclass_entry {
  VALUE klass;
  rb_subclass_entry_t *next;
};

typedef unsigned long long rb_serial_t;
# 958 "./internal.h"
struct rb_classext_struct {
  struct st_table *iv_index_tbl;
  struct st_table *iv_tbl;
  struct rb_id_table *const_tbl;
  struct rb_id_table *callable_m_tbl;
  rb_subclass_entry_t *subclasses;
  rb_subclass_entry_t **parent_subclasses;

  rb_subclass_entry_t **module_subclasses;
  rb_serial_t class_serial;
  const VALUE origin_;
  VALUE refined_class;
  rb_alloc_func_t allocator;
};

typedef struct rb_classext_struct rb_classext_t;

struct RClass {
  struct RBasic basic;
  VALUE super;
  rb_classext_t *ptr;
  struct rb_id_table *m_tbl;
};

void rb_class_subclass_add(VALUE super, VALUE klass);
void rb_class_remove_from_super_subclasses(VALUE);
int rb_singleton_class_internal_p(VALUE sklass);
# 1003 "./internal.h"
static inline void RCLASS_SET_ORIGIN(VALUE klass, VALUE origin) {
  rb_obj_write((VALUE)(klass),
               (VALUE *)(&((((struct RClass *)(klass))->ptr)->origin_)),
               (VALUE)(origin), "./internal.h", 1006);
  if (klass != origin)
    ((!(((VALUE)(origin)&RUBY_IMMEDIATE_MASK) ||
        !!(((VALUE)(origin) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
      (int)(((struct RBasic *)(origin))->flags & RUBY_T_MASK) != RUBY_T_NODE)
         ? (void)(((struct RBasic *)(origin))->flags |=
                  (((VALUE)RUBY_FL_USER5)))
         : (void)0);
}

static inline VALUE RCLASS_SUPER(VALUE klass) {
  return ((struct RClass *)(klass))->super;
}

static inline VALUE RCLASS_SET_SUPER(VALUE klass, VALUE super) {
  if (super) {
    rb_class_remove_from_super_subclasses(klass);
    rb_class_subclass_add(super, klass);
  }
  rb_obj_write((VALUE)(klass), (VALUE *)(&((struct RClass *)(klass))->super),
               (VALUE)(super), "./internal.h", 1024);
  return super;
}

struct RIMemo {
  VALUE flags;
  VALUE v0;
  VALUE v1;
  VALUE v2;
  VALUE v3;
};

enum imemo_type {
  imemo_env = 0,
  imemo_cref = 1,
  imemo_svar = 2,
  imemo_throw_data = 3,
  imemo_ifunc = 4,
  imemo_memo = 5,
  imemo_ment = 6,
  imemo_iseq = 7,
  imemo_tmpbuf = 8,
  imemo_ast = 9,
  imemo_parser_strterm = 10
};

static inline enum imemo_type imemo_type(VALUE imemo) {
  return (((struct RBasic *)(imemo))->flags >> ((VALUE)RUBY_FL_USHIFT)) & 0x0f;
}

static inline int imemo_type_p(VALUE imemo, enum imemo_type imemo_type) {
  if ((__builtin_expect(
          !!(!(((VALUE)(imemo)&RUBY_IMMEDIATE_MASK) ||
               !!(((VALUE)(imemo) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))),
          1))) {

    const VALUE mask = (0x0f << ((VALUE)RUBY_FL_USHIFT)) | RUBY_T_MASK;
    const VALUE expected_type =
        (imemo_type << ((VALUE)RUBY_FL_USHIFT)) | RUBY_T_IMEMO;

    return expected_type == (((struct RBasic *)(imemo))->flags & mask);
  } else {
    return 0;
  }
}
# 1088 "./internal.h"
struct vm_svar {
  VALUE flags;
  const VALUE cref_or_me;
  const VALUE lastline;
  const VALUE backref;
  const VALUE others;
};

struct vm_throw_data {
  VALUE flags;
  VALUE reserved;
  const VALUE throw_obj;
  const struct rb_control_frame_struct *catch_frame;
  VALUE throw_state;
};

struct vm_ifunc_argc {

  int min, max;
};

struct vm_ifunc {
  VALUE flags;
  VALUE reserved;
  VALUE (*func)();
  const void *data;
  struct vm_ifunc_argc argc;
};

struct vm_ifunc *rb_vm_ifunc_new(VALUE (*func)(), const void *data,
                                 int min_argc, int max_argc);
static inline struct vm_ifunc *rb_vm_ifunc_proc_new(VALUE (*func)(),
                                                    const void *data) {
  return rb_vm_ifunc_new(func, data, 0, (-1));
}

typedef struct rb_imemo_tmpbuf_struct {
  VALUE flags;
  VALUE reserved;
  VALUE *ptr;
  struct rb_imemo_tmpbuf_struct *next;
  size_t cnt;
} rb_imemo_tmpbuf_t;

VALUE rb_imemo_tmpbuf_auto_free_pointer(void *buf);
VALUE rb_imemo_tmpbuf_auto_free_maybe_mark_buffer(void *buf, size_t cnt);
rb_imemo_tmpbuf_t *
rb_imemo_tmpbuf_parser_heap(void *buf, rb_imemo_tmpbuf_t *old_heap, size_t cnt);

static inline VALUE
rb_imemo_tmpbuf_auto_free_pointer_new_from_an_RString(VALUE str) {
  const void *src;
  void *dst;
  size_t len;

  do {
    rb_string_value(&(str));
    rb_check_safe_obj(str);
  } while (0);
  len = (!(((struct RBasic *)(str))->flags & RSTRING_NOEMBED)
             ? (long)((((struct RBasic *)(str))->flags >>
                       RSTRING_EMBED_LEN_SHIFT) &
                      (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT))
             : ((struct RString *)(str))->as.heap.len);
  src = (!(((struct RBasic *)(str))->flags & RSTRING_NOEMBED)
             ? ((struct RString *)(str))->as.ary
             : ((struct RString *)(str))->as.heap.ptr);
  dst = ruby_xmalloc(len);
  __builtin___memcpy_chk(dst, src, len, __builtin_object_size(dst, 0));
  return rb_imemo_tmpbuf_auto_free_pointer(dst);
}

void rb_strterm_mark(VALUE obj);

struct MEMO {
  VALUE flags;
  VALUE reserved;
  const VALUE v1;
  const VALUE v2;
  union {
    long cnt;
    long state;
    const VALUE value;
    VALUE (*func)();
  } u3;
};
# 1211 "./internal.h"
enum { cmp_opt_Fixnum, cmp_opt_String, cmp_opt_Float, cmp_optimizable_count };

struct cmp_opt_data {
  unsigned int opt_methods;
  unsigned int opt_inited;
};
# 1246 "./internal.h"
struct rb_global_entry {
  struct rb_global_variable *var;
  ID id;
};

struct rb_global_entry *rb_global_entry(ID);
VALUE rb_gvar_get(struct rb_global_entry *);
VALUE rb_gvar_set(struct rb_global_entry *, VALUE);
VALUE rb_gvar_defined(struct rb_global_entry *);
# 1288 "./internal.h"
VALUE rb_ary_last(int, const VALUE *, VALUE);
void rb_ary_set_len(VALUE, long);
void rb_ary_delete_same(VALUE, VALUE);
VALUE rb_ary_tmp_new_fill(long capa);
VALUE rb_ary_at(VALUE, VALUE);
VALUE rb_ary_aref1(VALUE ary, VALUE i);
VALUE rb_ary_aref2(VALUE ary, VALUE b, VALUE e);
size_t rb_ary_memsize(VALUE);
VALUE rb_to_array_type(VALUE obj);
VALUE rb_check_to_array(VALUE ary);
VALUE rb_ary_tmp_new_from_values(VALUE, long, const VALUE *);
VALUE rb_ary_behead(VALUE, long);
# 1311 "./internal.h"
static inline VALUE rb_ary_entry_internal(VALUE ary, long offset) {
  long len = rb_array_len(ary);
  const VALUE *ptr = rb_array_const_ptr_transient(ary);
  if (len == 0)
    return ((VALUE)RUBY_Qnil);
  if (offset < 0) {
    offset += len;
    if (offset < 0)
      return ((VALUE)RUBY_Qnil);
  } else if (len <= offset) {
    return ((VALUE)RUBY_Qnil);
  }
  return ptr[offset];
}

extern const char ruby_digitmap[];
double rb_big_fdiv_double(VALUE x, VALUE y);
VALUE rb_big_uminus(VALUE x);
VALUE rb_big_hash(VALUE);
VALUE rb_big_odd_p(VALUE);
VALUE rb_big_even_p(VALUE);
size_t rb_big_size(VALUE);
VALUE rb_integer_float_cmp(VALUE x, VALUE y);
VALUE rb_integer_float_eq(VALUE x, VALUE y);
VALUE rb_cstr_parse_inum(const char *str, ssize_t len, char **endp, int base);
VALUE rb_str_convert_to_inum(VALUE str, int base, int badcheck,
                             int raise_exception);
VALUE rb_big_comp(VALUE x);
VALUE rb_big_aref(VALUE x, VALUE y);
VALUE rb_big_abs(VALUE x);
VALUE rb_big_size_m(VALUE big);
VALUE rb_big_bit_length(VALUE big);
VALUE rb_big_remainder(VALUE x, VALUE y);
VALUE rb_big_gt(VALUE x, VALUE y);
VALUE rb_big_ge(VALUE x, VALUE y);
VALUE rb_big_lt(VALUE x, VALUE y);
VALUE rb_big_le(VALUE x, VALUE y);
VALUE rb_int_powm(int const argc, VALUE *const argv, VALUE const num);

VALUE rb_class_boot(VALUE);
VALUE rb_class_inherited(VALUE, VALUE);
VALUE rb_make_metaclass(VALUE, VALUE);
VALUE rb_include_class_new(VALUE, VALUE);
void rb_class_foreach_subclass(VALUE klass, void (*f)(VALUE, VALUE), VALUE);
void rb_class_detach_subclasses(VALUE);
void rb_class_detach_module_subclasses(VALUE);
void rb_class_remove_from_module_subclasses(VALUE);
VALUE rb_obj_methods(int argc, const VALUE *argv, VALUE obj);
VALUE rb_obj_protected_methods(int argc, const VALUE *argv, VALUE obj);
VALUE rb_obj_private_methods(int argc, const VALUE *argv, VALUE obj);
VALUE rb_obj_public_methods(int argc, const VALUE *argv, VALUE obj);
VALUE rb_special_singleton_class(VALUE);
VALUE rb_singleton_class_clone_and_attach(VALUE obj, VALUE attach);
VALUE rb_singleton_class_get(VALUE obj);
void Init_class_hierarchy(void);

int rb_class_has_methods(VALUE c);
void rb_undef_methods_from(VALUE klass, VALUE super);

VALUE rb_invcmp(VALUE, VALUE);

struct rb_block;
int rb_dvar_defined(ID, const struct rb_block *);
int rb_local_defined(ID, const struct rb_block *);
const char *rb_insns_name(int i);
VALUE rb_insns_name_array(void);
int rb_vm_insn_addr2insn(const void *);

VALUE rb_complex_plus(VALUE, VALUE);
VALUE rb_complex_mul(VALUE, VALUE);
VALUE rb_complex_abs(VALUE x);
VALUE rb_complex_sqrt(VALUE x);
VALUE rb_dbl_complex_polar_pi(double abs, double ang);
VALUE rb_complex_pow(VALUE self, VALUE other);

struct rb_thread_struct;

VALUE rb_obj_is_fiber(VALUE);
void rb_fiber_reset_root_local_storage(struct rb_thread_struct *);
void ruby_register_rollback_func_for_ensure(VALUE (*ensure_func)(),
                                            VALUE (*rollback_func)());

void ruby_debug_printf(const char *, ...) __attribute__((format(printf, 1, 2)));

VALUE rb_dir_getwd_ospath(void);

void Init_enc(void);
void Init_ext(void);

ID rb_id_encoding(void);

int rb_encdb_replicate(const char *alias, const char *orig);
int rb_encdb_alias(const char *alias, const char *orig);
int rb_encdb_dummy(const char *name);
void rb_encdb_declare(const char *name);
void rb_enc_set_base(const char *name, const char *orig);
int rb_enc_set_dummy(int index);
void rb_encdb_set_unicode(int index);
__attribute__((__pure__)) int rb_data_is_encoding(VALUE obj);

VALUE rb_f_send(int argc, VALUE *argv, VALUE recv);
VALUE rb_nmin_run(VALUE obj, VALUE num, int by, int rev, int ary);

extern VALUE rb_eEAGAIN;
extern VALUE rb_eEWOULDBLOCK;
extern VALUE rb_eEINPROGRESS;
void rb_report_bug_valist(VALUE file, int line, const char *fmt, va_list args);
VALUE rb_check_backtrace(VALUE);
__attribute__((__noreturn__)) void rb_async_bug_errno(const char *, int);
const char *rb_builtin_type_name(int t);
const char *rb_builtin_class_name(VALUE x);
void rb_sys_warn(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
void rb_syserr_warn(int err, const char *fmt, ...)
    __attribute__((format(printf, 2, 3)));
void rb_sys_warning(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
void rb_syserr_warning(int err, const char *fmt, ...)
    __attribute__((format(printf, 2, 3)));
# 1454 "./internal.h"
VALUE rb_name_err_new(VALUE mesg, VALUE recv, VALUE method);

VALUE rb_nomethod_err_new(VALUE mesg, VALUE recv, VALUE method, VALUE args,
                          int priv);
VALUE rb_key_err_new(VALUE mesg, VALUE recv, VALUE name);

__attribute__((__noreturn__)) void
ruby_deprecated_internal_feature(const char *);

VALUE rb_warning_warn(VALUE mod, VALUE str);
VALUE rb_warning_string(const char *fmt, ...)
    __attribute__((format(printf, 1, 2)));

VALUE rb_refinement_module_get_refined_class(VALUE module);
extern ID ruby_static_id_signo, ruby_static_id_status;
void rb_class_modify_check(VALUE);

VALUE rb_get_backtrace(VALUE info);

void rb_call_end_proc(VALUE data);
void rb_mark_end_proc(void);

extern const char ruby_null_device[];
VALUE rb_home_dir_of(VALUE user, VALUE result);
VALUE rb_default_home_dir(VALUE result);
VALUE rb_realpath_internal(VALUE basedir, VALUE path, int strict);
VALUE rb_check_realpath(VALUE basedir, VALUE path);
void rb_file_const(const char *, VALUE);
int rb_file_load_ok(const char *);
VALUE rb_file_expand_path_fast(VALUE, VALUE);
VALUE rb_file_expand_path_internal(VALUE, VALUE, int, int, VALUE);
VALUE rb_get_path_check_to_string(VALUE, int);
VALUE rb_get_path_check_convert(VALUE, VALUE, int);
VALUE rb_get_path_check(VALUE, int);
void Init_File(void);
int ruby_is_fd_loadable(int fd);

#pragma GCC visibility push(default)

__attribute__((__noreturn__)) void rb_sys_fail_path_in(const char *func_name,
                                                       VALUE path);
__attribute__((__noreturn__)) void rb_syserr_fail_path_in(const char *func_name,
                                                          int err, VALUE path);

#pragma GCC visibility pop
# 1516 "./internal.h"
extern VALUE *ruby_initial_gc_stress_ptr;
extern int ruby_disable_gc;
void Init_heap(void);
void *ruby_mimmalloc(size_t size);
void ruby_mimfree(void *ptr);
void rb_objspace_set_event_hook(const rb_event_flag_t event);

void rb_gc_writebarrier_remember(VALUE obj);

void ruby_gc_set_params(int safe_level);
void rb_copy_wb_protected_attribute(VALUE dest, VALUE obj);
# 1553 "./internal.h"
void *rb_aligned_malloc(size_t, size_t);
void rb_aligned_free(void *);

struct st_table *rb_hash_tbl_raw(VALUE hash);

VALUE rb_hash_new_with_size(st_index_t size);
#pragma GCC visibility push(default)
VALUE rb_hash_new_compare_by_id(void);
#pragma GCC visibility pop
VALUE rb_hash_has_key(VALUE hash, VALUE key);
VALUE rb_hash_default_value(VALUE hash, VALUE key);
VALUE rb_hash_set_default_proc(VALUE hash, VALUE proc);
long rb_objid_hash(st_index_t index);
long rb_dbl_long_hash(double d);
st_table *rb_init_identtable(void);
st_table *rb_init_identtable_with_size(st_index_t size);
VALUE rb_hash_compare_by_id_p(VALUE hash);
VALUE rb_to_hash_type(VALUE obj);
VALUE rb_hash_key_str(VALUE);
VALUE rb_hash_keys(VALUE hash);
VALUE rb_hash_values(VALUE hash);
VALUE rb_hash_rehash(VALUE hash);
int rb_hash_add_new_element(VALUE hash, VALUE key, VALUE val);
VALUE rb_hash_set_pair(VALUE hash, VALUE pair);
void rb_hash_bulk_insert(long, const VALUE *, VALUE);

int rb_hash_stlike_lookup(VALUE hash, st_data_t key, st_data_t *pval);
int rb_hash_stlike_delete(VALUE hash, st_data_t *pkey, st_data_t *pval);
int rb_hash_stlike_foreach(VALUE hash, int (*func)(), st_data_t arg);
int rb_hash_stlike_update(VALUE hash, st_data_t key,
                          st_update_callback_func func, st_data_t arg);

void rb_call_inits(void);

const char *ruby_get_inplace_mode(void);
void ruby_set_inplace_mode(const char *);
ssize_t rb_io_bufread(VALUE io, void *buf, size_t size);
void rb_stdio_set_default_encoding(void);
VALUE rb_io_flush_raw(VALUE, int);

int rb_stderr_tty_p(void);
void rb_io_fptr_finalize_internal(void *ptr);

VALUE rb_get_load_path(void);
VALUE rb_get_expanded_load_path(void);
int rb_require_internal(VALUE fname, int safe);
__attribute__((__noreturn__)) void rb_load_fail(VALUE, const char *);

extern const char ruby_exec_prefix[];
extern const char ruby_initial_load_paths[];

int Init_enc_set_filesystem_encoding(void);

VALUE rb_math_atan2(VALUE, VALUE);
VALUE rb_math_cos(VALUE);
VALUE rb_math_cosh(VALUE);
VALUE rb_math_exp(VALUE);
VALUE rb_math_hypot(VALUE, VALUE);
VALUE rb_math_log(int argc, const VALUE *argv);
VALUE rb_math_sin(VALUE);
VALUE rb_math_sinh(VALUE);
VALUE rb_math_sqrt(VALUE);

extern int mjit_enabled;
VALUE mjit_pause(int wait_p);
VALUE mjit_resume(void);

void Init_newline(void);
# 1657 "./internal.h"
enum ruby_num_rounding_mode {
  RUBY_NUM_ROUND_HALF_UP,
  RUBY_NUM_ROUND_HALF_EVEN,
  RUBY_NUM_ROUND_HALF_DOWN,
  RUBY_NUM_ROUND_DEFAULT = RUBY_NUM_ROUND_HALF_UP
};
# 1672 "./internal.h"
int rb_num_to_uint(VALUE val, unsigned int *ret);
VALUE ruby_num_interval_step_size(VALUE from, VALUE to, VALUE step, int excl);
int ruby_float_step(VALUE from, VALUE to, VALUE step, int excl,
                    int allow_endless);
double ruby_float_mod(double x, double y);
int rb_num_negative_p(VALUE);
VALUE rb_int_succ(VALUE num);
VALUE rb_int_pred(VALUE num);
VALUE rb_int_uminus(VALUE num);
VALUE rb_float_uminus(VALUE num);
VALUE rb_int_plus(VALUE x, VALUE y);
VALUE rb_int_minus(VALUE x, VALUE y);
VALUE rb_int_mul(VALUE x, VALUE y);
VALUE rb_int_idiv(VALUE x, VALUE y);
VALUE rb_int_modulo(VALUE x, VALUE y);
VALUE rb_int_round(VALUE num, int ndigits, enum ruby_num_rounding_mode mode);
VALUE rb_int2str(VALUE num, int base);
VALUE rb_dbl_hash(double d);
VALUE rb_fix_plus(VALUE x, VALUE y);
VALUE rb_int_gt(VALUE x, VALUE y);
int rb_float_cmp(VALUE x, VALUE y);
VALUE rb_float_gt(VALUE x, VALUE y);
VALUE rb_int_ge(VALUE x, VALUE y);
enum ruby_num_rounding_mode rb_num_get_rounding_option(VALUE opts);
double rb_int_fdiv_double(VALUE x, VALUE y);
VALUE rb_int_pow(VALUE x, VALUE y);
VALUE rb_float_pow(VALUE x, VALUE y);
VALUE rb_int_cmp(VALUE x, VALUE y);
VALUE rb_int_equal(VALUE x, VALUE y);
VALUE rb_int_divmod(VALUE x, VALUE y);
VALUE rb_int_and(VALUE x, VALUE y);
VALUE rb_int_lshift(VALUE x, VALUE y);
VALUE rb_int_div(VALUE x, VALUE y);
VALUE rb_int_abs(VALUE num);
VALUE rb_int_odd_p(VALUE num);
int rb_int_positive_p(VALUE num);
int rb_int_negative_p(VALUE num);
VALUE rb_num_pow(VALUE x, VALUE y);

static inline VALUE rb_num_compare_with_zero(VALUE num, ID mid) {
  VALUE zero = (((VALUE)(0)) << 1 | RUBY_FIXNUM_FLAG);
  VALUE r = rb_check_funcall(num, mid, 1, &zero);
  if (r == ((VALUE)RUBY_Qundef)) {
    rb_cmperr(num, zero);
  }
  return r;
}

static inline int rb_num_positive_int_p(VALUE num) {
  const ID mid = '>';

  if ((((int)(long)(num)) & RUBY_FIXNUM_FLAG)) {
    if (rb_method_basic_definition_p(rb_cInteger, mid))
      return ((long)(num) > (long)(((VALUE)(0)) << 1 | RUBY_FIXNUM_FLAG));
  } else if (
      (((RUBY_T_BIGNUM) == RUBY_T_FIXNUM)
           ? (((int)(long)(num)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_BIGNUM) == RUBY_T_TRUE)
                 ? ((num) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_BIGNUM) == RUBY_T_FALSE)
                       ? ((num) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_BIGNUM) == RUBY_T_NIL)
                             ? ((num) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_BIGNUM) == RUBY_T_UNDEF)
                                   ? ((num) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_BIGNUM) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(num) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   num)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(num) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(num))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_BIGNUM) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(num)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         num)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(num) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(num))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        num)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(num) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(num))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_BIGNUM)))) {
    if (rb_method_basic_definition_p(rb_cInteger, mid))
      return ((((struct RBasic *)(num))->flags &
               ((VALUE)((VALUE)RUBY_FL_USER1))) != 0);
  }
  return !(((VALUE)(rb_num_compare_with_zero(num, mid)) &
            (VALUE) ~((VALUE)RUBY_Qnil)) == 0);
}

static inline int rb_num_negative_int_p(VALUE num) {
  const ID mid = '<';

  if ((((int)(long)(num)) & RUBY_FIXNUM_FLAG)) {
    if (rb_method_basic_definition_p(rb_cInteger, mid))
      return ((long)(num) < 0);
  } else if (
      (((RUBY_T_BIGNUM) == RUBY_T_FIXNUM)
           ? (((int)(long)(num)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_BIGNUM) == RUBY_T_TRUE)
                 ? ((num) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_BIGNUM) == RUBY_T_FALSE)
                       ? ((num) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_BIGNUM) == RUBY_T_NIL)
                             ? ((num) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_BIGNUM) == RUBY_T_UNDEF)
                                   ? ((num) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_BIGNUM) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(num) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   num)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(num) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(num))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_BIGNUM) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(num)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         num)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(num) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(num))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        num)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(num) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(num))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_BIGNUM)))) {
    if (rb_method_basic_definition_p(rb_cInteger, mid))
      return (!((((struct RBasic *)(num))->flags &
                 ((VALUE)((VALUE)RUBY_FL_USER1))) != 0));
  }
  return !(((VALUE)(rb_num_compare_with_zero(num, mid)) &
            (VALUE) ~((VALUE)RUBY_Qnil)) == 0);
}

VALUE rb_float_abs(VALUE flt);
VALUE rb_float_equal(VALUE x, VALUE y);
VALUE rb_float_eql(VALUE x, VALUE y);
VALUE rb_flo_div_flo(VALUE x, VALUE y);

static inline double rb_float_flonum_value(VALUE v) {

  if (v != (VALUE)0x8000000000000002) {
    union {
      double d;
      VALUE v;
    } t;

    VALUE b63 = (v >> 63);

    t.v = ((((2 - b63) | (v & ~(VALUE)0x03)) >> (3)) |
           (((2 - b63) | (v & ~(VALUE)0x03))
            << ((sizeof((2 - b63) | (v & ~(VALUE)0x03)) * 8) - 3)));
    return t.d;
  }

  return 0.0;
}

static inline double rb_float_noflonum_value(VALUE v) {
  return ((struct RFloat *)v)->float_value;
}

static inline double rb_float_value_inline(VALUE v) {
  if (((((int)(long)(v)) & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG)) {
    return rb_float_flonum_value(v);
  }
  return rb_float_noflonum_value(v);
}

static inline VALUE rb_float_new_inline(double d) {

  union {
    double d;
    VALUE v;
  } t;
  int bits;

  t.d = d;
  bits = (int)((VALUE)(t.v >> 60) & 0x7);

  if (t.v != 0x3000000000000000 && !((bits - 3) & ~0x01)) {
    return ((((t.v) << (3)) | ((t.v) >> ((sizeof(t.v) * 8) - 3))) &
            ~(VALUE)0x01) |
           0x02;
  } else if (t.v == (VALUE)0) {

    return 0x8000000000000002;
  }

  return rb_float_new_in_heap(d);
}

void rb_obj_copy_ivar(VALUE dest, VALUE obj);
__attribute__((__const__)) VALUE rb_obj_equal(VALUE obj1, VALUE obj2);
__attribute__((__const__)) VALUE rb_obj_not(VALUE obj);
VALUE rb_class_search_ancestor(VALUE klass, VALUE super);
__attribute__((__noreturn__)) void rb_undefined_alloc(VALUE klass);
double rb_num_to_dbl(VALUE val);
VALUE rb_obj_dig(int argc, VALUE *argv, VALUE self, VALUE notfound);
VALUE rb_immutable_obj_clone(int, VALUE *, VALUE);
VALUE rb_obj_not_equal(VALUE obj1, VALUE obj2);
VALUE rb_convert_type_with_id(VALUE, int, const char *, ID);
VALUE rb_check_convert_type_with_id(VALUE, int, const char *, ID);

struct RBasicRaw {
  VALUE flags;
  VALUE klass;
};
# 1863 "./internal.h"
VALUE rb_parser_get_yydebug(VALUE);
VALUE rb_parser_set_yydebug(VALUE, VALUE);
#pragma GCC visibility push(default)
VALUE rb_parser_set_context(VALUE, const struct rb_block *, int);
#pragma GCC visibility pop
void *rb_parser_load_file(VALUE parser, VALUE name);
int rb_is_const_name(VALUE name);
int rb_is_class_name(VALUE name);
int rb_is_global_name(VALUE name);
int rb_is_instance_name(VALUE name);
int rb_is_attrset_name(VALUE name);
int rb_is_local_name(VALUE name);
int rb_is_method_name(VALUE name);
int rb_is_junk_name(VALUE name);
__attribute__((__pure__)) int rb_is_const_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_class_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_global_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_instance_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_attrset_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_local_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_method_sym(VALUE sym);
__attribute__((__pure__)) int rb_is_junk_sym(VALUE sym);
ID rb_make_internal_id(void);
void rb_gc_free_dsymbol(VALUE);
ID rb_id_attrget(ID id);

VALUE rb_proc_location(VALUE self);
st_index_t rb_hash_proc(st_index_t hash, VALUE proc);
int rb_block_arity(void);
int rb_block_min_max_arity(int *max);
VALUE rb_func_proc_new(rb_block_call_func_t func, VALUE val);
VALUE rb_func_lambda_new(rb_block_call_func_t func, VALUE val, int min_argc,
                         int max_argc);
VALUE rb_block_to_s(VALUE self, const struct rb_block *block,
                    const char *additional_info);

struct waitpid_state;
struct rb_execarg {
  union {
    struct {
      VALUE shell_script;
    } sh;
    struct {
      VALUE command_name;
      VALUE command_abspath;
      VALUE argv_str;
      VALUE argv_buf;
    } cmd;
  } invoke;
  VALUE redirect_fds;
  VALUE envp_str;
  VALUE envp_buf;
  VALUE dup2_tmpbuf;
  unsigned use_shell : 1;
  unsigned pgroup_given : 1;
  unsigned umask_given : 1;
  unsigned unsetenv_others_given : 1;
  unsigned unsetenv_others_do : 1;
  unsigned close_others_given : 1;
  unsigned close_others_do : 1;
  unsigned chdir_given : 1;
  unsigned new_pgroup_given : 1;
  unsigned new_pgroup_flag : 1;
  unsigned uid_given : 1;
  unsigned gid_given : 1;
  unsigned exception : 1;
  struct waitpid_state *waitpid_state;
  pid_t pgroup_pgid;
  VALUE rlimit_limits;
  mode_t umask_mask;
  uid_t uid;
  gid_t gid;
  int close_others_maxhint;
  VALUE fd_dup2;
  VALUE fd_close;
  VALUE fd_open;
  VALUE fd_dup2_child;
  VALUE env_modification;
  VALUE path_env;
  VALUE chdir_dir;
};

static inline size_t ARGVSTR2ARGC(VALUE argv_str) {
  size_t i = 0;
  char *const *p =
      ((char **)((
           void *)(((const struct rb_imemo_tmpbuf_struct *)(argv_str))->ptr)) +
       1);
  while (p[i++])
    ;
  return i - 1;
}

pid_t rb_fork_ruby(int *status);
void rb_last_status_clear(void);

VALUE rb_rational_canonicalize(VALUE x);
VALUE rb_rational_uminus(VALUE self);
VALUE rb_rational_plus(VALUE self, VALUE other);
VALUE rb_lcm(VALUE x, VALUE y);
VALUE rb_rational_reciprocal(VALUE x);
VALUE rb_cstr_to_rat(const char *, int);
VALUE rb_rational_abs(VALUE self);
VALUE rb_rational_cmp(VALUE self, VALUE other);
VALUE rb_rational_pow(VALUE self, VALUE other);
VALUE rb_numeric_quo(VALUE x, VALUE y);

VALUE rb_reg_compile(VALUE str, int options, const char *sourcefile,
                     int sourceline);
VALUE rb_reg_check_preprocess(VALUE);
long rb_reg_search0(VALUE, VALUE, long, int, int);
VALUE rb_reg_match_p(VALUE re, VALUE str, long pos);
_Bool rb_reg_start_with_p(VALUE re, VALUE str);
void rb_backref_set_string(VALUE string, long pos, long len);
int rb_match_count(VALUE match);
int rb_match_nth_defined(int nth, VALUE match);
VALUE rb_reg_new_ary(VALUE ary, int options);

extern int ruby_enable_coredump;
int rb_get_next_signal(void);

VALUE rb_fstring(VALUE);
VALUE rb_fstring_new(const char *ptr, long len);

VALUE rb_fstring_cstr(const char *str);
# 2019 "./internal.h"
int rb_str_buf_cat_escaped_char(VALUE result, unsigned int c, int unicode_p);
int rb_str_symname_p(VALUE);
VALUE rb_str_quote_unprintable(VALUE);
VALUE rb_id_quote_unprintable(ID);

char *rb_str_fill_terminator(VALUE str, const int termlen);
void rb_str_change_terminator_length(VALUE str, const int oldtermlen,
                                     const int termlen);
VALUE rb_str_locktmp_ensure(VALUE str, VALUE (*func)(VALUE), VALUE arg);
VALUE rb_str_tmp_frozen_acquire(VALUE str);
void rb_str_tmp_frozen_release(VALUE str, VALUE tmp);
VALUE rb_str_chomp_string(VALUE str, VALUE chomp);
# 2044 "./internal.h"
size_t rb_str_memsize(VALUE);
VALUE rb_sym_proc_call(ID mid, int argc, const VALUE *argv, VALUE passed_proc);
VALUE rb_sym_to_proc(VALUE sym);
char *rb_str_to_cstr(VALUE str);
VALUE rb_str_eql(VALUE str1, VALUE str2);
VALUE rb_obj_as_string_result(VALUE str, VALUE obj);
# 2064 "./internal.h"
VALUE rb_sym_intern_ascii(const char *ptr, long len);
VALUE rb_sym_intern_ascii_cstr(const char *ptr);
# 2074 "./internal.h"
VALUE rb_to_symbol_type(VALUE obj);

VALUE rb_struct_init_copy(VALUE copy, VALUE s);
VALUE rb_struct_lookup(VALUE s, VALUE idx);
VALUE rb_struct_s_keyword_init(VALUE klass);

struct timeval rb_time_timeval(VALUE);
# 2092 "./internal.h"
VALUE rb_obj_is_mutex(VALUE obj);
VALUE rb_suppress_tracing(VALUE (*func)(VALUE), VALUE arg);
void rb_thread_execute_interrupts(VALUE th);
void rb_clear_trace_func(void);
VALUE rb_get_coverages(void);
int rb_get_coverage_mode(void);
VALUE rb_default_coverage(int);
VALUE rb_thread_shield_new(void);
VALUE rb_thread_shield_wait(VALUE self);
VALUE rb_thread_shield_release(VALUE self);
VALUE rb_thread_shield_destroy(VALUE self);
int rb_thread_to_be_killed(VALUE thread);
void rb_mutex_allow_trap(VALUE self, int val);
VALUE rb_uninterruptible(VALUE (*b_proc)(), VALUE data);
VALUE rb_mutex_owned_p(VALUE self);

extern VALUE rb_cEncodingConverter;
# 2120 "./internal.h"
char *ruby_dtoa(double d_, int mode, int ndigits, int *decpt, int *sign,
                char **rve);
char *ruby_hdtoa(double d, const char *xdigs, int ndigits, int *decpt,
                 int *sign, char **rve);
# 2139 "./internal.h"
void rb_gc_mark_global_tbl(void);
size_t rb_generic_ivar_memsize(VALUE);
VALUE rb_search_class_path(VALUE);
VALUE rb_attr_delete(VALUE, ID);
VALUE rb_ivar_lookup(VALUE obj, ID id, VALUE undef);
void rb_autoload_str(VALUE mod, ID id, VALUE file);
void rb_deprecate_constant(VALUE mod, const char *name);
__attribute__((__noreturn__)) VALUE rb_mod_const_missing(VALUE, VALUE);
rb_gvar_getter_t *rb_gvar_getter_function_of(const struct rb_global_entry *);
rb_gvar_setter_t *rb_gvar_setter_function_of(const struct rb_global_entry *);
_Bool rb_gvar_is_traced(const struct rb_global_entry *);

rb_serial_t rb_next_class_serial(void);

VALUE rb_obj_is_thread(VALUE obj);
void rb_vm_mark(void *ptr);
void Init_BareVM(void);
void Init_vm_objects(void);
__attribute__((__pure__)) VALUE rb_vm_top_self(void);
void rb_thread_recycle_stack_release(VALUE *);
VALUE *rb_thread_recycle_stack(size_t);
void rb_vm_change_state(void);
void rb_vm_inc_const_missing_count(void);
const void **rb_vm_get_insns_address_table(void);
VALUE rb_source_location(int *pline);
const char *rb_source_location_cstr(int *pline);
void rb_vm_pop_cfunc_frame(void);
int rb_vm_add_root_module(ID id, VALUE module);
void rb_vm_check_redefinition_by_prepend(VALUE klass);
VALUE rb_yield_refine_block(VALUE refinement, VALUE refinements);
VALUE ruby_vm_special_exception_copy(VALUE);
__attribute__((__pure__)) st_table *rb_vm_fstring_table(void);

void rb_print_backtrace(void);

void Init_vm_eval(void);
VALUE rb_current_realfilepath(void);
VALUE rb_check_block_call(VALUE, ID, int, const VALUE *, rb_block_call_func_t,
                          VALUE);
typedef void rb_check_funcall_hook(int, VALUE, ID, int, const VALUE *, VALUE);
VALUE rb_check_funcall_with_hook(VALUE recv, ID mid, int argc,
                                 const VALUE *argv, rb_check_funcall_hook *hook,
                                 VALUE arg);
const char *rb_type_str(enum ruby_value_type type);
VALUE rb_check_funcall_default(VALUE, ID, int, const VALUE *, VALUE);
VALUE rb_yield_1(VALUE val);
VALUE rb_yield_force_blockarg(VALUE values);
VALUE rb_lambda_call(VALUE obj, ID mid, int argc, const VALUE *argv,
                     rb_block_call_func_t bl_proc, int min_argc, int max_argc,
                     VALUE data2);

VALUE rb_equal_opt(VALUE obj1, VALUE obj2);
VALUE rb_eql_opt(VALUE obj1, VALUE obj2);
void Init_vm_stack_canary(void);

void Init_eval_method(void);
int rb_method_defined_by(VALUE obj, ID mid, VALUE (*cfunc)());

void Init_prelude(void);

void Init_vm_backtrace(void);
VALUE rb_vm_thread_backtrace(int argc, const VALUE *argv, VALUE thval);
VALUE rb_vm_thread_backtrace_locations(int argc, const VALUE *argv,
                                       VALUE thval);

VALUE rb_make_backtrace(void);
void rb_backtrace_print_as_bugreport(void);
int rb_backtrace_p(VALUE obj);
VALUE rb_backtrace_to_str_ary(VALUE obj);
VALUE rb_backtrace_to_location_ary(VALUE obj);
void rb_backtrace_each(VALUE (*iter)(VALUE recv, VALUE str), VALUE output);

#pragma GCC visibility push(default)
const char *rb_objspace_data_type_name(VALUE obj);

VALUE rb_thread_io_blocking_region(rb_blocking_function_t *func, void *data1,
                                   int fd);

void rb_ary_detransient(VALUE a);

VALUE rb_big_mul_normal(VALUE x, VALUE y);
VALUE rb_big_mul_balance(VALUE x, VALUE y);
VALUE rb_big_mul_karatsuba(VALUE x, VALUE y);
VALUE rb_big_mul_toom3(VALUE x, VALUE y);
VALUE rb_big_sq_fast(VALUE x);
VALUE rb_big_divrem_normal(VALUE x, VALUE y);
VALUE rb_big2str_poweroftwo(VALUE x, int base);
VALUE rb_big2str_generic(VALUE x, int base);
VALUE rb_str2big_poweroftwo(VALUE arg, int base, int badcheck);
VALUE rb_str2big_normal(VALUE arg, int base, int badcheck);
VALUE rb_str2big_karatsuba(VALUE arg, int base, int badcheck);

VALUE rb_big_mul_gmp(VALUE x, VALUE y);
VALUE rb_big_divrem_gmp(VALUE x, VALUE y);
VALUE rb_big2str_gmp(VALUE x, int base);
VALUE rb_str2big_gmp(VALUE arg, int base, int badcheck);

enum rb_int_parse_flags {
  RB_INT_PARSE_SIGN = 0x01,
  RB_INT_PARSE_UNDERSCORE = 0x02,
  RB_INT_PARSE_PREFIX = 0x04,
  RB_INT_PARSE_ALL = 0x07,
  RB_INT_PARSE_DEFAULT = 0x07
};
VALUE rb_int_parse_cstr(const char *str, ssize_t len, char **endp,
                        size_t *ndigits, int base, int flags);

VALUE rb_arith_seq_new(VALUE obj, VALUE meth, int argc, VALUE const *argv,
                       rb_enumerator_size_func *size_fn, VALUE beg, VALUE end,
                       VALUE step, int excl);

int rb_bug_reporter_add(void (*func)(FILE *, void *), void *data);
__attribute__((__noreturn__)) void rb_unexpected_type(VALUE, int);
# 2272 "./internal.h"
VALUE rb_str_normalize_ospath(const char *ptr, long len);

VALUE rb_hash_delete_entry(VALUE hash, VALUE key);
VALUE rb_ident_hash_new(void);

void rb_maygvl_fd_fix_cloexec(int fd);
int rb_gc_for_fd(int err);
void rb_write_error_str(VALUE mesg);

VALUE rb_int_positive_pow(long x, unsigned long y);

int rb_exec_async_signal_safe(const struct rb_execarg *e, char *errmsg,
                              size_t errmsg_buflen);
pid_t rb_fork_async_signal_safe(int *status,
                                int (*chfunc)(void *, char *, size_t),
                                void *charg, VALUE fds, char *errmsg,
                                size_t errmsg_buflen);
VALUE rb_execarg_new(int argc, const VALUE *argv, int accept_shell,
                     int allow_exc_opt);
struct rb_execarg *rb_execarg_get(VALUE execarg_obj);
VALUE rb_execarg_init(int argc, const VALUE *argv, int accept_shell,
                      VALUE execarg_obj, int allow_exc_opt);
int rb_execarg_addopt(VALUE execarg_obj, VALUE key, VALUE val);
void rb_execarg_parent_start(VALUE execarg_obj);
void rb_execarg_parent_end(VALUE execarg_obj);
int rb_execarg_run_options(const struct rb_execarg *e, struct rb_execarg *s,
                           char *errmsg, size_t errmsg_buflen);
VALUE rb_execarg_extract_options(VALUE execarg_obj, VALUE opthash);
void rb_execarg_setenv(VALUE execarg_obj, VALUE env);

VALUE rb_gcd(VALUE x, VALUE y);
VALUE rb_gcd_normal(VALUE self, VALUE other);

VALUE rb_gcd_gmp(VALUE x, VALUE y);

int rb_grantpt(int fd);

VALUE rb_str_upto_each(VALUE, VALUE, int, int (*each)(VALUE, VALUE), VALUE);
VALUE rb_str_upto_endless_each(VALUE, int (*each)(VALUE, VALUE), VALUE);

int ruby_thread_has_gvl_p(void);

void ruby_reset_leap_second_info(void);

extern const signed char ruby_digit36_to_number_table[];
extern const char ruby_hexdigits[];
extern unsigned long ruby_scan_digits(const char *str, ssize_t len, int base,
                                      size_t *retlen, int *overflow);

void rb_mark_generic_ivar(VALUE);
VALUE rb_const_missing(VALUE klass, VALUE name);
int rb_class_ivar_set(VALUE klass, ID vid, VALUE value);
st_table *rb_st_copy(VALUE obj, struct st_table *orig_tbl);

VALUE rb_wb_protected_newobj_of(VALUE, VALUE);
VALUE rb_wb_unprotected_newobj_of(VALUE, VALUE);

size_t rb_obj_memsize_of(VALUE);
void rb_gc_verify_internal_consistency(void);

size_t rb_obj_gc_flags(VALUE, ID[], size_t);
void rb_gc_mark_values(long n, const VALUE *values);

VALUE rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3,
                   VALUE v0);

int ruby_fill_random_bytes(void *, size_t, int);

#pragma GCC visibility pop
# 12 "vm.c" 2
# 1 "./include/ruby/vm.h" 1
# 22 "./include/ruby/vm.h"
#pragma GCC visibility push(default)
# 32 "./include/ruby/vm.h"
typedef struct rb_vm_struct ruby_vm_t;

int ruby_vm_destruct(ruby_vm_t *vm);
# 53 "./include/ruby/vm.h"
void ruby_vm_at_exit(void (*func)(ruby_vm_t *));

#pragma GCC visibility pop
# 13 "vm.c" 2

# 1 "./gc.h" 1
# 89 "./gc.h"
const char *rb_obj_info(VALUE obj);
const char *rb_raw_obj_info(char *buff, const int buff_size, VALUE obj);
void rb_obj_info_dump(VALUE obj);

struct rb_thread_struct;

#pragma GCC visibility push(default)

size_t rb_objspace_data_type_memsize(VALUE obj);
void rb_objspace_reachable_objects_from(VALUE obj, void(func)(VALUE, void *),
                                        void *data);
void rb_objspace_reachable_objects_from_root(void(func)(const char *category,
                                                        VALUE, void *),
                                             void *data);
int rb_objspace_markable_object_p(VALUE obj);
int rb_objspace_internal_object_p(VALUE obj);
int rb_objspace_marked_object_p(VALUE obj);
int rb_objspace_garbage_object_p(VALUE obj);

void rb_objspace_each_objects(int (*callback)(void *start, void *end,
                                              size_t stride, void *data),
                              void *data);

void rb_objspace_each_objects_without_setup(int (*callback)(void *, void *,
                                                            size_t, void *),
                                            void *data);

#pragma GCC visibility pop
# 18 "vm.c" 2
# 1 "./vm_core.h" 1
# 45 "./vm_core.h"
# 1 "./ruby_assert.h" 1
# 13 "./ruby_assert.h"
__attribute__((__noreturn__)) void
rb_assert_failure(const char *, int, const char *, const char *);
# 46 "./vm_core.h" 2
# 72 "./vm_core.h"
# 1 "./node.h" 1
# 22 "./node.h"
enum node_type {
  NODE_SCOPE,
  NODE_BLOCK,
  NODE_IF,
  NODE_UNLESS,
  NODE_CASE,
  NODE_CASE2,
  NODE_WHEN,
  NODE_WHILE,
  NODE_UNTIL,
  NODE_ITER,
  NODE_FOR,
  NODE_FOR_MASGN,
  NODE_BREAK,
  NODE_NEXT,
  NODE_REDO,
  NODE_RETRY,
  NODE_BEGIN,
  NODE_RESCUE,
  NODE_RESBODY,
  NODE_ENSURE,
  NODE_AND,
  NODE_OR,
  NODE_MASGN,
  NODE_LASGN,
  NODE_DASGN,
  NODE_DASGN_CURR,
  NODE_GASGN,
  NODE_IASGN,
  NODE_CDECL,
  NODE_CVASGN,
  NODE_OP_ASGN1,
  NODE_OP_ASGN2,
  NODE_OP_ASGN_AND,
  NODE_OP_ASGN_OR,
  NODE_OP_CDECL,
  NODE_CALL,
  NODE_OPCALL,
  NODE_FCALL,
  NODE_VCALL,
  NODE_QCALL,
  NODE_SUPER,
  NODE_ZSUPER,
  NODE_ARRAY,
  NODE_ZARRAY,
  NODE_VALUES,
  NODE_HASH,
  NODE_RETURN,
  NODE_YIELD,
  NODE_LVAR,
  NODE_DVAR,
  NODE_GVAR,
  NODE_IVAR,
  NODE_CONST,
  NODE_CVAR,
  NODE_NTH_REF,
  NODE_BACK_REF,
  NODE_MATCH,
  NODE_MATCH2,
  NODE_MATCH3,
  NODE_LIT,
  NODE_STR,
  NODE_DSTR,
  NODE_XSTR,
  NODE_DXSTR,
  NODE_EVSTR,
  NODE_DREGX,
  NODE_ONCE,
  NODE_ARGS,
  NODE_ARGS_AUX,
  NODE_OPT_ARG,
  NODE_KW_ARG,
  NODE_POSTARG,
  NODE_ARGSCAT,
  NODE_ARGSPUSH,
  NODE_SPLAT,
  NODE_BLOCK_PASS,
  NODE_DEFN,
  NODE_DEFS,
  NODE_ALIAS,
  NODE_VALIAS,
  NODE_UNDEF,
  NODE_CLASS,
  NODE_MODULE,
  NODE_SCLASS,
  NODE_COLON2,
  NODE_COLON3,
  NODE_DOT2,
  NODE_DOT3,
  NODE_FLIP2,
  NODE_FLIP3,
  NODE_SELF,
  NODE_NIL,
  NODE_TRUE,
  NODE_FALSE,
  NODE_ERRINFO,
  NODE_DEFINED,
  NODE_POSTEXE,
  NODE_DSYM,
  NODE_ATTRASGN,
  NODE_LAMBDA,
  NODE_LAST
};

typedef struct rb_code_position_struct {
  int lineno;
  int column;
} rb_code_position_t;

typedef struct rb_code_location_struct {
  rb_code_position_t beg_pos;
  rb_code_position_t end_pos;
} rb_code_location_t;

static inline rb_code_location_t code_loc_gen(rb_code_location_t *loc1,
                                              rb_code_location_t *loc2) {
  rb_code_location_t loc;
  loc.beg_pos = loc1->beg_pos;
  loc.end_pos = loc2->end_pos;
  return loc;
}

typedef struct RNode {
  VALUE flags;
  union {
    struct RNode *node;
    ID id;
    VALUE value;
    ID *tbl;
  } u1;
  union {
    struct RNode *node;
    ID id;
    long argc;
    VALUE value;
  } u2;
  union {
    struct RNode *node;
    ID id;
    long state;
    struct rb_global_entry *entry;
    struct rb_args_info *args;
    VALUE value;
  } u3;
  rb_code_location_t nd_loc;
  int node_id;
} NODE;
# 370 "./node.h"
#pragma GCC visibility push(default)

typedef struct node_buffer_struct node_buffer_t;

typedef struct rb_ast_body_struct {
  const NODE *root;
  VALUE compile_option;
  int line_count;
} rb_ast_body_t;
typedef struct rb_ast_struct {
  VALUE flags;
  node_buffer_t *node_buffer;
  rb_ast_body_t body;
} rb_ast_t;
rb_ast_t *rb_ast_new(void);
void rb_ast_mark(rb_ast_t *);
void rb_ast_dispose(rb_ast_t *);
void rb_ast_free(rb_ast_t *);
void rb_ast_add_mark_object(rb_ast_t *, VALUE);
NODE *rb_ast_newnode(rb_ast_t *);
void rb_ast_delete_node(rb_ast_t *, NODE *n);

VALUE rb_parser_new(void);
VALUE rb_parser_end_seen_p(VALUE);
VALUE rb_parser_encoding(VALUE);
VALUE rb_parser_get_yydebug(VALUE);
VALUE rb_parser_set_yydebug(VALUE, VALUE);
VALUE rb_parser_dump_tree(const NODE *node, int comment);
void rb_parser_set_options(VALUE, int, int, int, int);

rb_ast_t *rb_parser_compile_cstr(VALUE, const char *, const char *, int, int);
rb_ast_t *rb_parser_compile_string(VALUE, const char *, VALUE, int);
rb_ast_t *rb_parser_compile_file(VALUE, const char *, VALUE, int);
rb_ast_t *rb_parser_compile_string_path(VALUE vparser, VALUE fname, VALUE src,
                                        int line);
rb_ast_t *rb_parser_compile_file_path(VALUE vparser, VALUE fname, VALUE input,
                                      int line);
rb_ast_t *rb_parser_compile_generic(VALUE vparser,
                                    VALUE (*lex_gets)(VALUE, int), VALUE fname,
                                    VALUE input, int line);

rb_ast_t *rb_compile_cstr(const char *, const char *, int, int);
rb_ast_t *rb_compile_string(const char *, VALUE, int);
rb_ast_t *rb_compile_file(const char *, VALUE, int);

void rb_node_init(NODE *n, enum node_type type, VALUE a0, VALUE a1, VALUE a2);

const struct kwtable *rb_reserved_word(const char *, unsigned int);

struct rb_args_info {
  NODE *pre_init;
  NODE *post_init;

  int pre_args_num;
  int post_args_num;

  ID first_post_arg;

  ID rest_arg;
  ID block_arg;

  NODE *kw_args;
  NODE *kw_rest_arg;

  NODE *opt_args;
};

struct parser_params;
void *rb_parser_malloc(struct parser_params *, size_t);
void *rb_parser_realloc(struct parser_params *, void *, size_t);
void *rb_parser_calloc(struct parser_params *, size_t, size_t);
void rb_parser_free(struct parser_params *, void *);
void rb_parser_printf(struct parser_params *parser, const char *fmt, ...)
    __attribute__((format(printf, 2, 3)));

#pragma GCC visibility pop
# 73 "./vm_core.h" 2
# 1 "./vm_opts.h" 1
# 74 "./vm_core.h" 2
# 1 "./id.h" 1
# 16 "./id.h"
enum ruby_id_types {
  RUBY_ID_STATIC_SYM = 0x01,
  RUBY_ID_LOCAL = 0x00,
  RUBY_ID_INSTANCE = (0x01 << 1),
  RUBY_ID_GLOBAL = (0x03 << 1),
  RUBY_ID_ATTRSET = (0x04 << 1),
  RUBY_ID_CONST = (0x05 << 1),
  RUBY_ID_CLASS = (0x06 << 1),
  RUBY_ID_JUNK = (0x07 << 1),
  RUBY_ID_INTERNAL = RUBY_ID_JUNK,
  RUBY_ID_SCOPE_SHIFT = 4,
  RUBY_ID_SCOPE_MASK = (~(~0U << (RUBY_ID_SCOPE_SHIFT - 1)) << 1)
};
# 76 "./id.h"
enum ruby_method_ids {
  idDot2 = 128,
  idDot3 = 129,
  idUPlus = 130,
  idUMinus = 131,
  idPow = 132,
  idCmp = 133,
  idPLUS = '+',
  idMINUS = '-',
  idMULT = '*',
  idDIV = '/',
  idMOD = '%',
  idLTLT = 134,
  idGTGT = 135,
  idLT = '<',
  idLE = 136,
  idGT = '>',
  idGE = 137,
  idEq = 138,
  idEqq = 139,
  idNeq = 140,
  idNot = '!',
  idAnd = '&',
  idOr = '|',
  idBackquote = '`',
  idEqTilde = 141,
  idNeqTilde = 142,
  idAREF = 143,
  idASET = 144,
  idCOLON2 = 145,
  idANDOP = 146,
  idOROP = 147,
  idANDDOT = 148,
  tPRESERVED_ID_BEGIN = 148,
  idNULL,
  idEmptyP,
  idEqlP,
  idRespond_to,
  idRespond_to_missing,
  idIFUNC,
  idCFUNC,
  id_core_set_method_alias,
  id_core_set_variable_alias,
  id_core_undef_method,
  id_core_define_method,
  id_core_define_singleton_method,
  id_core_set_postexe,
  id_core_hash_merge_ptr,
  id_core_hash_merge_kwd,
  id_debug_created_info,
  tPRESERVED_ID_END,
  tTOKEN_LOCAL_BEGIN = tPRESERVED_ID_END - 1,
  tMax,
  tMin,
  tFreeze,
  tInspect,
  tIntern,
  tObject_id,
  tConst_missing,
  tMethodMissing,
  tMethod_added,
  tSingleton_method_added,
  tMethod_removed,
  tSingleton_method_removed,
  tMethod_undefined,
  tSingleton_method_undefined,
  tLength,
  tSize,
  tGets,
  tSucc,
  tEach,
  tProc,
  tLambda,
  tSend,
  t__send__,
  t__attached__,
  tInitialize,
  tInitialize_copy,
  tInitialize_clone,
  tInitialize_dup,
  tTo_int,
  tTo_ary,
  tTo_str,
  tTo_sym,
  tTo_hash,
  tTo_proc,
  tTo_io,
  tTo_a,
  tTo_s,
  tTo_i,
  tTo_f,
  tTo_r,
  tBt,
  tBt_locations,
  tCall,
  tMesg,
  tException,
  tNOT,
  tAND,
  tOR,
  tUScore,
  tTOKEN_LOCAL_END,
  tTOKEN_INSTANCE_BEGIN = tTOKEN_LOCAL_END - 1,
  tTOKEN_INSTANCE_END,
  tTOKEN_GLOBAL_BEGIN = tTOKEN_INSTANCE_END - 1,
  tLASTLINE,
  tBACKREF,
  tTOKEN_GLOBAL_END,
  tTOKEN_CONST_BEGIN = tTOKEN_GLOBAL_END - 1,
  tTOKEN_CONST_END,
  tTOKEN_CLASS_BEGIN = tTOKEN_CONST_END - 1,
  tTOKEN_CLASS_END,
  tTOKEN_ATTRSET_BEGIN = tTOKEN_CLASS_END - 1,
  tTOKEN_ATTRSET_END,
  tNEXT_ID = tTOKEN_ATTRSET_END,

  idMax = ((tMax << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idMin = ((tMin << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idFreeze =
      ((tFreeze << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idInspect =
      ((tInspect << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idIntern =
      ((tIntern << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idObject_id = ((tObject_id << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                 RUBY_ID_STATIC_SYM),
  idConst_missing = ((tConst_missing << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                     RUBY_ID_STATIC_SYM),
  idMethodMissing = ((tMethodMissing << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                     RUBY_ID_STATIC_SYM),
  idMethod_added = ((tMethod_added << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                    RUBY_ID_STATIC_SYM),
  idSingleton_method_added = ((tSingleton_method_added << RUBY_ID_SCOPE_SHIFT) |
                              RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idMethod_removed = ((tMethod_removed << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                      RUBY_ID_STATIC_SYM),
  idSingleton_method_removed =
      ((tSingleton_method_removed << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
       RUBY_ID_STATIC_SYM),
  idMethod_undefined = ((tMethod_undefined << RUBY_ID_SCOPE_SHIFT) |
                        RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idSingleton_method_undefined =
      ((tSingleton_method_undefined << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
       RUBY_ID_STATIC_SYM),
  idLength =
      ((tLength << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idSize =
      ((tSize << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idGets =
      ((tGets << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idSucc =
      ((tSucc << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idEach =
      ((tEach << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idProc =
      ((tProc << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idLambda =
      ((tLambda << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idSend =
      ((tSend << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  id__send__ =
      ((t__send__ << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  id__attached__ = ((t__attached__ << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                    RUBY_ID_STATIC_SYM),
  idInitialize = ((tInitialize << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                  RUBY_ID_STATIC_SYM),
  idInitialize_copy = ((tInitialize_copy << RUBY_ID_SCOPE_SHIFT) |
                       RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idInitialize_clone = ((tInitialize_clone << RUBY_ID_SCOPE_SHIFT) |
                        RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idInitialize_dup = ((tInitialize_dup << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                      RUBY_ID_STATIC_SYM),
  idTo_int =
      ((tTo_int << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_ary =
      ((tTo_ary << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_str =
      ((tTo_str << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_sym =
      ((tTo_sym << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_hash =
      ((tTo_hash << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_proc =
      ((tTo_proc << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_io =
      ((tTo_io << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_a =
      ((tTo_a << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_s =
      ((tTo_s << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_i =
      ((tTo_i << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_f =
      ((tTo_f << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idTo_r =
      ((tTo_r << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idBt = ((tBt << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idBt_locations = ((tBt_locations << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                    RUBY_ID_STATIC_SYM),
  idCall =
      ((tCall << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idMesg =
      ((tMesg << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idException = ((tException << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL |
                 RUBY_ID_STATIC_SYM),
  idNOT = ((tNOT << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idAND = ((tAND << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idOR = ((tOR << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),
  idUScore =
      ((tUScore << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_LOCAL | RUBY_ID_STATIC_SYM),

  idLASTLINE = ((tLASTLINE << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_GLOBAL |
                RUBY_ID_STATIC_SYM),
  idBACKREF =
      ((tBACKREF << RUBY_ID_SCOPE_SHIFT) | RUBY_ID_GLOBAL | RUBY_ID_STATIC_SYM),

  tLAST_OP_ID = tPRESERVED_ID_END - 1,
  idLAST_OP_ID = tLAST_OP_ID >> RUBY_ID_SCOPE_SHIFT
};
# 75 "./vm_core.h" 2
# 1 "./method.h" 1
# 26 "./method.h"
typedef enum {
  METHOD_VISI_UNDEF = 0x00,
  METHOD_VISI_PUBLIC = 0x01,
  METHOD_VISI_PRIVATE = 0x02,
  METHOD_VISI_PROTECTED = 0x03,

  METHOD_VISI_MASK = 0x03
} rb_method_visibility_t;

typedef struct rb_scope_visi_struct {
  rb_method_visibility_t method_visi : 3;
  unsigned int module_func : 1;
} rb_scope_visibility_t;

typedef struct rb_cref_struct {
  VALUE flags;
  const VALUE refinements;
  const VALUE klass;
  struct rb_cref_struct *const next;
  const rb_scope_visibility_t scope_visi;
} rb_cref_t;

typedef struct rb_method_entry_struct {
  VALUE flags;
  const VALUE defined_class;
  struct rb_method_definition_struct *const def;
  ID called_id;
  const VALUE owner;
} rb_method_entry_t;

typedef struct rb_callable_method_entry_struct {
  VALUE flags;
  const VALUE defined_class;
  struct rb_method_definition_struct *const def;
  ID called_id;
  const VALUE owner;
} rb_callable_method_entry_t;

static inline void METHOD_ENTRY_VISI_SET(rb_method_entry_t *me,
                                         rb_method_visibility_t visi) {
  ((void)0);
  me->flags = (me->flags & ~(((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) |
              (visi << ((((VALUE)RUBY_FL_USHIFT) + 4) + 0));
}
static inline void METHOD_ENTRY_BASIC_SET(rb_method_entry_t *me,
                                          unsigned int basic) {
  ((void)0);
  me->flags = (me->flags & ~(((VALUE)RUBY_FL_USER6))) |
              (basic << ((((VALUE)RUBY_FL_USHIFT) + 4) + 2));
}
static inline void METHOD_ENTRY_FLAGS_SET(rb_method_entry_t *me,
                                          rb_method_visibility_t visi,
                                          unsigned int basic) {
  ((void)0);
  ((void)0);
  me->flags = (me->flags & ~(((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5) |
                             ((VALUE)RUBY_FL_USER6))) |
              ((visi << ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)) |
               (basic << ((((VALUE)RUBY_FL_USHIFT) + 4) + 2)));
}
static inline void METHOD_ENTRY_FLAGS_COPY(rb_method_entry_t *dst,
                                           const rb_method_entry_t *src) {
  dst->flags = (dst->flags & ~(((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5) |
                               ((VALUE)RUBY_FL_USER6))) |
               (src->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5) |
                              ((VALUE)RUBY_FL_USER6)));
}

typedef enum {
  VM_METHOD_TYPE_ISEQ,
  VM_METHOD_TYPE_CFUNC,
  VM_METHOD_TYPE_ATTRSET,
  VM_METHOD_TYPE_IVAR,
  VM_METHOD_TYPE_BMETHOD,
  VM_METHOD_TYPE_ZSUPER,
  VM_METHOD_TYPE_ALIAS,
  VM_METHOD_TYPE_UNDEF,
  VM_METHOD_TYPE_NOTIMPLEMENTED,
  VM_METHOD_TYPE_OPTIMIZED,
  VM_METHOD_TYPE_MISSING,
  VM_METHOD_TYPE_REFINED,

} rb_method_type_t;

typedef struct rb_iseq_struct rb_iseq_t;

typedef struct rb_method_iseq_struct {
  const rb_iseq_t *const iseqptr;
  rb_cref_t *const cref;
} rb_method_iseq_t;

typedef struct rb_method_cfunc_struct {
  VALUE (*func)();
  VALUE (*invoker)(VALUE (*func)(), VALUE recv, int argc, const VALUE *argv);
  int argc;
} rb_method_cfunc_t;

typedef struct rb_method_attr_struct {
  ID id;
  const VALUE location;
} rb_method_attr_t;

typedef struct rb_method_alias_struct {
  const struct rb_method_entry_struct *const original_me;
} rb_method_alias_t;

typedef struct rb_method_refined_struct {
  const struct rb_method_entry_struct *const orig_me;
  const VALUE owner;
} rb_method_refined_t;

enum method_optimized_type {
  OPTIMIZED_METHOD_TYPE_SEND,
  OPTIMIZED_METHOD_TYPE_CALL,
  OPTIMIZED_METHOD_TYPE_BLOCK_CALL,
  OPTIMIZED_METHOD_TYPE__MAX
};

struct rb_method_definition_struct {
  rb_method_type_t type : 4;
  int alias_count : 28;
  int complemented_count : 28;
  union {
    rb_method_iseq_t iseq;
    rb_method_cfunc_t cfunc;
    rb_method_attr_t attr;
    rb_method_alias_t alias;
    rb_method_refined_t refined;
    const VALUE proc;
    enum method_optimized_type optimize_type;
  } body;
  ID original_id;
} __attribute__((packed));
# 176 "./method.h"
typedef struct rb_method_definition_struct rb_method_definition_t;

void rb_add_method_cfunc(VALUE klass, ID mid, VALUE (*func)(), int argc,
                         rb_method_visibility_t visi);
void rb_add_method_iseq(VALUE klass, ID mid, const rb_iseq_t *iseq,
                        rb_cref_t *cref, rb_method_visibility_t visi);
void rb_add_refined_method_entry(VALUE refined_class, ID mid);

rb_method_entry_t *rb_add_method(VALUE klass, ID mid, rb_method_type_t type,
                                 void *option, rb_method_visibility_t visi);
rb_method_entry_t *rb_method_entry_set(VALUE klass, ID mid,
                                       const rb_method_entry_t *,
                                       rb_method_visibility_t noex);
rb_method_entry_t *rb_method_entry_create(ID called_id, VALUE klass,
                                          rb_method_visibility_t visi,
                                          const rb_method_definition_t *def);

const rb_method_entry_t *rb_method_entry_at(VALUE obj, ID id);

const rb_method_entry_t *rb_method_entry(VALUE klass, ID id);
const rb_method_entry_t *
rb_method_entry_without_refinements(VALUE klass, ID id, VALUE *defined_class);
const rb_method_entry_t *rb_resolve_refined_method(VALUE refinements,
                                                   const rb_method_entry_t *me);
#pragma GCC visibility push(default)
const rb_method_entry_t *rb_resolve_me_location(const rb_method_entry_t *,
                                                VALUE[5]);
#pragma GCC visibility pop

const rb_callable_method_entry_t *rb_callable_method_entry(VALUE klass, ID id);
const rb_callable_method_entry_t *
rb_callable_method_entry_with_refinements(VALUE klass, ID id,
                                          VALUE *defined_class);
const rb_callable_method_entry_t *
rb_callable_method_entry_without_refinements(VALUE klass, ID id,
                                             VALUE *defined_class);

int rb_method_entry_arity(const rb_method_entry_t *me);
int rb_method_entry_eq(const rb_method_entry_t *m1,
                       const rb_method_entry_t *m2);
st_index_t rb_hash_method_entry(st_index_t hash, const rb_method_entry_t *me);

VALUE rb_method_entry_location(const rb_method_entry_t *me);
VALUE rb_mod_method_location(VALUE mod, ID id);
VALUE rb_obj_method_location(VALUE obj, ID id);

void rb_free_method_entry(const rb_method_entry_t *me);
void rb_sweep_method_entry(void *vm);

const rb_method_entry_t *rb_method_entry_clone(const rb_method_entry_t *me);
const rb_callable_method_entry_t *
rb_method_entry_complement_defined_class(const rb_method_entry_t *src_me,
                                         ID called_id, VALUE defined_class);
void rb_method_entry_copy(rb_method_entry_t *dst, const rb_method_entry_t *src);

void rb_scope_visibility_set(rb_method_visibility_t);

VALUE rb_unnamed_parameters(int arity);
# 76 "./vm_core.h" 2
# 1 "./ruby_atomic.h" 1

typedef unsigned int rb_atomic_t;
# 77 "./vm_core.h" 2
# 1 "./ccan/list/list.h" 1

# 1 "/usr/include/assert.h" 1 3 4
# 76 "/usr/include/assert.h" 3 4
void __assert_rtn(const char *, const char *, int, const char *)
    __attribute__((noreturn)) __attribute__((__disable_tail_calls__));
# 5 "./ccan/list/list.h" 2
# 1 "./ccan/str/str.h" 1
# 6 "./ccan/list/list.h" 2
# 1 "./ccan/container_of/container_of.h" 1

# 1 "./ccan/check_type/check_type.h" 1
# 5 "./ccan/container_of/container_of.h" 2
# 62 "./ccan/container_of/container_of.h"
static inline char *container_of_or_null_(void *member_ptr, size_t offset) {
  return member_ptr ? (char *)member_ptr - offset : ((void *)0);
}
# 7 "./ccan/list/list.h" 2
# 22 "./ccan/list/list.h"
struct list_node {
  struct list_node *next, *prev;
};
# 39 "./ccan/list/list.h"
struct list_head {
  struct list_node n;
};
# 89 "./ccan/list/list.h"
static inline void list_head_init(struct list_head *h) {
  h->n.next = h->n.prev = &h->n;
}
# 101 "./ccan/list/list.h"
static inline void list_node_init(struct list_node *n) {
  n->next = n->prev = n;
}
# 124 "./ccan/list/list.h"
static inline void list_add_after_(struct list_head *h, struct list_node *p,
                                   struct list_node *n, const char *abortstr) {
  n->next = p->next;
  n->prev = p;
  p->next->prev = n;
  p->next = n;
  (void)((void)abortstr, h);
}
# 150 "./ccan/list/list.h"
static inline void list_add_(struct list_head *h, struct list_node *n,
                             const char *abortstr) {
  list_add_after_(h, &h->n, n, abortstr);
}
# 173 "./ccan/list/list.h"
static inline void list_add_before_(struct list_head *h, struct list_node *p,
                                    struct list_node *n, const char *abortstr) {
  n->next = p;
  n->prev = p->prev;
  p->prev->next = n;
  p->prev = n;
  (void)((void)abortstr, h);
}
# 196 "./ccan/list/list.h"
static inline void list_add_tail_(struct list_head *h, struct list_node *n,
                                  const char *abortstr) {
  list_add_before_(h, &h->n, n, abortstr);
}
# 213 "./ccan/list/list.h"
static inline int list_empty_(const struct list_head *h, const char *abortstr) {
  (void)((void)abortstr, h);
  return h->n.next == &h->n;
}
# 250 "./ccan/list/list.h"
static inline _Bool list_empty_nocheck(const struct list_head *h) {
  return h->n.next == &h->n;
}
# 270 "./ccan/list/list.h"
static inline void list_del_(struct list_node *n, const char *abortstr) {
  (void)((void)abortstr, n);
  n->next->prev = n->prev;
  n->prev->next = n->next;
}
# 296 "./ccan/list/list.h"
static inline void list_del_init_(struct list_node *n, const char *abortstr) {
  list_del_(n, abortstr);
  list_node_init(n);
}
# 316 "./ccan/list/list.h"
static inline void list_del_from(struct list_head *h, struct list_node *n) {
# 328 "./ccan/list/list.h"
  (__builtin_expect(!(!list_empty_(h, "./ccan/list/list.h"
                                      ":"
                                      "328")),
                    0)
       ? __assert_rtn(__func__, "./ccan/list/list.h", 328, "!list_empty(h)")
       : (void)0);
  list_del_(n, "./ccan/list/list.h"
               ":"
               "329");
}
# 351 "./ccan/list/list.h"
static inline void list_swap_(struct list_node *o, struct list_node *n,
                              const char *abortstr) {
  (void)((void)abortstr, o);
  *n = *o;
  n->next->prev = n;
  n->prev->next = n;
}
# 397 "./ccan/list/list.h"
static inline const void *list_top_(const struct list_head *h, size_t off) {
  if (list_empty_(h, "./ccan/list/list.h"
                     ":"
                     "399"))
    return ((void *)0);
  return (const char *)h->n.next - off;
}
# 421 "./ccan/list/list.h"
static inline const void *list_pop_(const struct list_head *h, size_t off) {
  struct list_node *n;

  if (list_empty_(h, "./ccan/list/list.h"
                     ":"
                     "425"))
    return ((void *)0);
  n = h->n.next;
  list_del_(n, "./ccan/list/list.h"
               ":"
               "428");
  return (const char *)n - off;
}
# 449 "./ccan/list/list.h"
static inline const void *list_tail_(const struct list_head *h, size_t off) {
  if (list_empty_(h, "./ccan/list/list.h"
                     ":"
                     "451"))
    return ((void *)0);
  return (const char *)h->n.prev - off;
}
# 586 "./ccan/list/list.h"
static inline void list_append_list_(struct list_head *to,
                                     struct list_head *from,
                                     const char *abortstr) {
  struct list_node *from_tail = ((void)abortstr, from)->n.prev;
  struct list_node *to_tail = ((void)abortstr, to)->n.prev;

  to->n.prev = from_tail;
  from_tail->next = &to->n;
  to_tail->next = &from->n;
  from->n.prev = to_tail;

  list_del_(&from->n, "./ccan/list/list.h"
                      ":"
                      "600");
  list_head_init(from);
}
# 618 "./ccan/list/list.h"
static inline void list_prepend_list_(struct list_head *to,
                                      struct list_head *from,
                                      const char *abortstr) {
  struct list_node *from_tail = ((void)abortstr, from)->n.prev;
  struct list_node *to_head = ((void)abortstr, to)->n.next;

  to->n.next = &from->n;
  from->n.prev = &to->n;
  to_head->prev = from_tail;
  from_tail->next = to_head;

  list_del_(&from->n, "./ccan/list/list.h"
                      ":"
                      "632");
  list_head_init(from);
}
# 755 "./ccan/list/list.h"
static inline void *list_node_to_off_(struct list_node *node, size_t off) {
  return (void *)((char *)node - off);
}
static inline struct list_node *list_node_from_off_(void *ptr, size_t off) {
  return (struct list_node *)((char *)ptr + off);
}
# 780 "./ccan/list/list.h"
static inline void *list_entry_or_null(const struct list_head *h,
                                       const struct list_node *n, size_t off) {
  if (n == &h->n)
    return ((void *)0);
  return (char *)n - off;
}
# 78 "./vm_core.h" 2

# 1 "./include/ruby/thread_native.h" 1
# 36 "./include/ruby/thread_native.h"
# 1 "/usr/include/pthread.h" 1 3 4
# 57 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull begin
#pragma clang assume_nonnull end
# 58 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/pthread/sched.h" 1 3 4
# 35 "/usr/include/pthread/sched.h" 3 4
struct sched_param {
  int sched_priority;
  char __opaque[4];
};

extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
# 60 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 74 "/usr/include/time.h" 3 4
struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long tm_gmtoff;
  char *tm_zone;
};
# 97 "/usr/include/time.h" 3 4
extern char *tzname[];

extern int getdate_err;

extern long timezone __asm("_"
                           "timezone");

extern int daylight;

char *asctime(const struct tm *);
clock_t clock(void) __asm("_"
                          "clock");
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_"
                                 "mktime");
size_t strftime(char *restrict, size_t, const char *restrict,
                const struct tm *restrict) __asm("_"
                                                 "strftime");
char *strptime(const char *restrict, const char *restrict,
               struct tm *restrict) __asm("_"
                                          "strptime");
time_t time(time_t *);

void tzset(void);

char *asctime_r(const struct tm *restrict, char *restrict);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t *restrict, struct tm *restrict);
struct tm *localtime_r(const time_t *restrict, struct tm *restrict);

time_t posix2time(time_t);

void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm *const);
time_t timegm(struct tm *const);

int nanosleep(const struct timespec *__rqtp,
              struct timespec *__rmtp) __asm("_"
                                             "nanosleep");
# 152 "/usr/include/time.h" 3 4
typedef enum {
  _CLOCK_REALTIME __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 0,

  _CLOCK_MONOTONIC __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 6,

  _CLOCK_MONOTONIC_RAW __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 4,

  _CLOCK_MONOTONIC_RAW_APPROX
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 5,

  _CLOCK_UPTIME_RAW __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 8,

  _CLOCK_UPTIME_RAW_APPROX
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 9,

  _CLOCK_PROCESS_CPUTIME_ID
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 12,

  _CLOCK_THREAD_CPUTIME_ID
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 16

} clockid_t;

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) int
clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) int
clock_gettime(clockid_t __clock_id, struct timespec *__tp);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) __uint64_t
clock_gettime_nsec_np(clockid_t __clock_id);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(tvos, unavailable)))
__attribute__((availability(watchos, unavailable))) int
clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 61 "/usr/include/pthread.h" 2 3 4
# 73 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread/qos.h" 1 3 4
# 34 "/usr/include/pthread/qos.h" 3 4
# 1 "/usr/include/sys/qos.h" 1 3 4
# 128 "/usr/include/sys/qos.h" 3 4
enum {
  QOS_CLASS_USER_INTERACTIVE
  __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x21,
  QOS_CLASS_USER_INITIATED
  __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x19,
  QOS_CLASS_DEFAULT __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x15,
  QOS_CLASS_UTILITY __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x11,
  QOS_CLASS_BACKGROUND __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x09,
  QOS_CLASS_UNSPECIFIED __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x00,
};
typedef unsigned int qos_class_t;
# 168 "/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) qos_class_t
qos_class_self(void);
# 190 "/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) qos_class_t
qos_class_main(void);
# 35 "/usr/include/pthread/qos.h" 2 3 4

#pragma clang assume_nonnull begin
# 81 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class,
                              int __relative_priority);
# 112 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_attr_get_qos_class_np(pthread_attr_t *restrict __attr,
                              qos_class_t *_Nullable restrict __qos_class,
                              int *_Nullable restrict __relative_priority);
# 153 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority);
# 184 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_get_qos_class_np(pthread_t __pthread,
                         qos_class_t *_Nullable restrict __qos_class,
                         int *_Nullable restrict __relative_priority);
# 211 "/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s *pthread_override_t;
# 263 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
                                    qos_class_t __qos_class,
                                    int __relative_priority);
# 291 "/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_override_qos_class_end_np(pthread_override_t __override);
#pragma clang assume_nonnull end
# 74 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 78 "/usr/include/pthread.h" 2 3 4
# 106 "/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull begin
# 215 "/usr/include/pthread.h" 3 4
__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_atfork(void (*_Nullable)(void), void (*_Nullable)(void),
               void (*_Nullable)(void));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getguardsize(const pthread_attr_t *restrict, size_t *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getinheritsched(const pthread_attr_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getschedparam(const pthread_attr_t *restrict,
                           struct sched_param *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getschedpolicy(const pthread_attr_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getscope(const pthread_attr_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstack(const pthread_attr_t *restrict,
                      void *_Nullable *_Nonnull restrict, size_t *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstackaddr(const pthread_attr_t *restrict,
                          void *_Nullable *_Nonnull restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstacksize(const pthread_attr_t *restrict, size_t *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setschedparam(pthread_attr_t *restrict,
                           const struct sched_param *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_cancel(pthread_t) __asm("_"
                                    "pthread_cancel");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_init(
    pthread_cond_t *restrict,
    const pthread_condattr_t *_Nullable restrict) __asm("_"
                                                        "pthread_cond_init");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_timedwait(
    pthread_cond_t *restrict, pthread_mutex_t *restrict,
    const struct timespec *_Nullable restrict) __asm("_"
                                                     "pthread_cond_timedwait");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_wait(pthread_cond_t *restrict,
                  pthread_mutex_t *restrict) __asm("_"
                                                   "pthread_cond_wait");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_getpshared(const pthread_condattr_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create(pthread_t _Nullable * _Nonnull restrict,
  const pthread_attr_t * _Nullable restrict,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_detach(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_exit(void *_Nullable) __attribute__((noreturn));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_getconcurrency(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_getschedparam(pthread_t, int *_Nullable restrict,
                      struct sched_param *_Nullable restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(
    ios, introduced = 2.0))) void *_Nullable pthread_getspecific(pthread_key_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_join(pthread_t, void *_Nullable *_Nullable) __asm("_"
                                                          "pthread_join");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_key_create(pthread_key_t *, void (*_Nullable)(void *));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_key_delete(pthread_key_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_getprioceiling(const pthread_mutex_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_init(pthread_mutex_t *restrict,
                   const pthread_mutexattr_t *_Nullable restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_setprioceiling(pthread_mutex_t *restrict, int, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm(
    "_"
    "pthread_mutexattr_destroy");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict,
                                 int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict,
                              int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict,
                             int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict, int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(
    swift, unavailable, message = "Use lazily initialized globals instead")))
__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_once(pthread_once_t *, void (*_Nonnull)(void));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_destroy(pthread_rwlock_t *) __asm("_"
                                                 "pthread_rwlock_destroy");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_init(pthread_rwlock_t *restrict,
                    const pthread_rwlockattr_t
                        *_Nullable restrict) __asm("_"
                                                   "pthread_rwlock_init");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_rdlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_"
                                                   "pthread_rwlock_tryrdlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_"
                                                   "pthread_rwlock_trywrlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_wrlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_unlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict,
                              int *restrict);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) pthread_t
pthread_self(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setcancelstate(int, int *_Nullable) __asm("_"
                                                  "pthread_setcancelstate");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setcanceltype(int, int *_Nullable) __asm("_"
                                                 "pthread_setcanceltype");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setconcurrency(int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setspecific(pthread_key_t, const void *_Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_testcancel(void) __asm("_"
                               "pthread_testcancel");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_is_threaded_np(void);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_threadid_np(pthread_t _Nullable, __uint64_t *_Nullable);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_getname_np(pthread_t, char *, size_t);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_setname_np(const char *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_main_np(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void *
    pthread_get_stackaddr_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
                                   const struct timespec *_Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_kill(pthread_t, int);

__attribute__((availability(macos, introduced = 10.5)))
__attribute__((availability(ios, introduced = 2.0))) _Nullable pthread_t
    pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_sigmask(int, const sigset_t *_Nullable,
                sigset_t *_Nullable) __asm("_"
                                           "pthread_sigmask");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_yield_np(void);
#pragma clang assume_nonnull end
# 37 "./include/ruby/thread_native.h" 2
typedef pthread_t rb_nativethread_id_t;
typedef pthread_mutex_t rb_nativethread_lock_t;

#pragma GCC visibility push(default)

rb_nativethread_id_t rb_nativethread_self();

void rb_nativethread_lock_initialize(rb_nativethread_lock_t *lock);
void rb_nativethread_lock_destroy(rb_nativethread_lock_t *lock);
void rb_nativethread_lock_lock(rb_nativethread_lock_t *lock);
void rb_nativethread_lock_unlock(rb_nativethread_lock_t *lock);

#pragma GCC visibility pop
# 80 "./vm_core.h" 2

# 1 "./thread_pthread.h" 1
# 21 "./thread_pthread.h"
typedef pthread_cond_t rb_nativethread_cond_t;

typedef struct native_thread_data_struct {
  union {
    struct list_node ubf;
    struct list_node gvl;
  } node;

  struct

  {
    rb_nativethread_cond_t intr;
    rb_nativethread_cond_t gvlq;
  } cond;
} native_thread_data_t;

typedef struct rb_global_vm_lock_struct {

  const struct rb_thread_struct *owner;
  rb_nativethread_lock_t lock;
# 64 "./thread_pthread.h"
  struct list_head waitq;
  const struct rb_thread_struct *timer;
  int timer_err;

  rb_nativethread_cond_t switch_cond;
  rb_nativethread_cond_t switch_wait_cond;
  int need_yield;
  int wait_yield;
} rb_global_vm_lock_t;
# 84 "./vm_core.h" 2

# 1 "/usr/include/setjmp.h" 1 3 4
# 37 "/usr/include/setjmp.h" 3 4
typedef int jmp_buf[((9 * 2) + 3 + 16)];
typedef int sigjmp_buf[((9 * 2) + 3 + 16) + 1];
# 87 "/usr/include/setjmp.h" 3 4
extern int setjmp(jmp_buf);
extern void longjmp(jmp_buf, int) __attribute__((noreturn));

int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int) __attribute__((noreturn));
int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int) __attribute__((noreturn));

void longjmperror(void);
# 87 "./vm_core.h" 2
# 1 "/usr/include/signal.h" 1 3 4
# 69 "/usr/include/signal.h" 3 4
extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];

int raise(int);

void (*_Nullable bsd_signal(int, void (*_Nullable)(int)))(int);
int kill(pid_t, int) __asm("_"
                           "kill");
int killpg(pid_t, int) __asm("_"
                             "killpg");
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_"
                                                             "pthread_sigmask");
int sigaction(int, const struct sigaction *restrict,
              struct sigaction *restrict);
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t *restrict, stack_t *restrict) __asm("_"
                                                                  "sigaltstack")
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_"
                        "sigpause");
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);
int sigrelse(int);
void (*_Nullable sigset(int, void (*_Nullable)(int)))(int);
int sigsuspend(const sigset_t *) __asm("_"
                                       "sigsuspend");
int sigwait(const sigset_t *restrict, int *restrict) __asm("_"
                                                           "sigwait");

void psignal(unsigned int, const char *);
int sigblock(int);
int sigsetmask(int);
int sigvec(int, struct sigvec *, struct sigvec *);

inline __attribute__((__always_inline__)) int __sigbits(int __signo) {
  return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 88 "./vm_core.h" 2
# 133 "./vm_core.h"
void *rb_register_sigaltstack(void);
# 177 "./vm_core.h"
void rb_vm_encoded_insn_data_table_init(void);
typedef unsigned long rb_num_t;
typedef signed long rb_snum_t;

enum ruby_tag_type {
  RUBY_TAG_NONE = 0x0,
  RUBY_TAG_RETURN = 0x1,
  RUBY_TAG_BREAK = 0x2,
  RUBY_TAG_NEXT = 0x3,
  RUBY_TAG_RETRY = 0x4,
  RUBY_TAG_REDO = 0x5,
  RUBY_TAG_RAISE = 0x6,
  RUBY_TAG_THROW = 0x7,
  RUBY_TAG_FATAL = 0x8,
  RUBY_TAG_MASK = 0xf
};
# 205 "./vm_core.h"
enum ruby_vm_throw_flags {
  VM_THROW_NO_ESCAPE_FLAG = 0x8000,
  VM_THROW_STATE_MASK = 0xff
};

struct rb_thread_struct;
struct rb_control_frame_struct;

typedef struct rb_compile_option_struct rb_compile_option_t;

struct iseq_inline_cache_entry {
  rb_serial_t ic_serial;
  const rb_cref_t *ic_cref;
  union {
    size_t index;
    VALUE value;
  } ic_value;
};

union iseq_inline_storage_entry {
  struct {
    struct rb_thread_struct *running_thread;
    VALUE value;
  } once;
  struct iseq_inline_cache_entry cache;
};

enum method_missing_reason {
  MISSING_NOENTRY = 0x00,
  MISSING_PRIVATE = 0x01,
  MISSING_PROTECTED = 0x02,
  MISSING_FCALL = 0x04,
  MISSING_VCALL = 0x08,
  MISSING_SUPER = 0x10,
  MISSING_MISSING = 0x20,
  MISSING_NONE = 0x40
};

struct rb_call_info {

  ID mid;
  unsigned int flag;
  int orig_argc;
};

struct rb_call_info_kw_arg {
  int keyword_len;
  VALUE keywords[1];
};

struct rb_call_info_with_kwarg {
  struct rb_call_info ci;
  struct rb_call_info_kw_arg *kw_arg;
};

struct rb_calling_info {
  VALUE block_handler;
  VALUE recv;
  int argc;
};

struct rb_call_cache;
struct rb_execution_context_struct;
typedef VALUE (*vm_call_handler)(struct rb_execution_context_struct *ec,
                                 struct rb_control_frame_struct *cfp,
                                 struct rb_calling_info *calling,
                                 const struct rb_call_info *ci,
                                 struct rb_call_cache *cc);

struct rb_call_cache {

  rb_serial_t method_state;
  rb_serial_t class_serial;

  const rb_callable_method_entry_t *me;

  vm_call_handler call;

  union {
    unsigned int index;
    enum method_missing_reason method_missing_reason;
    int inc_sp;
  } aux;
};
# 296 "./vm_core.h"
typedef struct rb_iseq_location_struct {
  VALUE pathobj;
  VALUE base_label;
  VALUE label;
  VALUE first_lineno;
  int node_id;
  rb_code_location_t code_location;
} rb_iseq_location_t;

static inline VALUE pathobj_path(VALUE pathobj) {
  if ((((RUBY_T_STRING) == RUBY_T_FIXNUM)
           ? (((int)(long)(pathobj)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_STRING) == RUBY_T_TRUE)
                 ? ((pathobj) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_STRING) == RUBY_T_FALSE)
                       ? ((pathobj) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_STRING) == RUBY_T_NIL)
                             ? ((pathobj) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                   ? ((pathobj) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_STRING) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(pathobj) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   pathobj)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(pathobj) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(pathobj))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_STRING) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(pathobj)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         pathobj)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(pathobj) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(pathobj))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        pathobj)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(pathobj) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(pathobj))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_STRING)))) {
    return pathobj;
  } else {
    ((void)0);
    return (rb_array_const_ptr_transient(pathobj)[0]);
  }
}

static inline VALUE pathobj_realpath(VALUE pathobj) {
  if ((((RUBY_T_STRING) == RUBY_T_FIXNUM)
           ? (((int)(long)(pathobj)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_STRING) == RUBY_T_TRUE)
                 ? ((pathobj) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_STRING) == RUBY_T_FALSE)
                       ? ((pathobj) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_STRING) == RUBY_T_NIL)
                             ? ((pathobj) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                   ? ((pathobj) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_STRING) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(pathobj) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   pathobj)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(pathobj) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(pathobj))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_STRING) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(pathobj)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         pathobj)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(pathobj) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(pathobj))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        pathobj)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(pathobj) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(pathobj))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_STRING)))) {
    return pathobj;
  } else {
    ((void)0);
    return (rb_array_const_ptr_transient(pathobj)[1]);
  }
}

struct rb_mjit_unit;

struct rb_iseq_constant_body {
  enum iseq_type {
    ISEQ_TYPE_TOP,
    ISEQ_TYPE_METHOD,
    ISEQ_TYPE_BLOCK,
    ISEQ_TYPE_CLASS,
    ISEQ_TYPE_RESCUE,
    ISEQ_TYPE_ENSURE,
    ISEQ_TYPE_EVAL,
    ISEQ_TYPE_MAIN,
    ISEQ_TYPE_PLAIN
  } type;

  unsigned int iseq_size;
  const VALUE *iseq_encoded;
# 374 "./vm_core.h"
  struct {
    struct {
      unsigned int has_lead : 1;
      unsigned int has_opt : 1;
      unsigned int has_rest : 1;
      unsigned int has_post : 1;
      unsigned int has_kw : 1;
      unsigned int has_kwrest : 1;
      unsigned int has_block : 1;

      unsigned int ambiguous_param0 : 1;
    } flags;

    unsigned int size;

    int lead_num;
    int opt_num;
    int rest_start;
    int post_start;
    int post_num;
    int block_start;

    const VALUE *opt_table;
# 411 "./vm_core.h"
    const struct rb_iseq_param_keyword {
      int num;
      int required_num;
      int bits_start;
      int rest_start;
      const ID *table;
      const VALUE *default_values;
    } * keyword;
  } param;

  rb_iseq_location_t location;

  struct iseq_insn_info {
    const struct iseq_insn_info_entry *body;
    unsigned int *positions;
    unsigned int size;

    struct succ_index_table *succ_index_table;

  } insns_info;

  const ID *local_table;

  const struct iseq_catch_table *catch_table;

  const struct rb_iseq_struct *parent_iseq;
  struct rb_iseq_struct *local_iseq;

  union iseq_inline_storage_entry *is_entries;
  struct rb_call_info *ci_entries;

  struct rb_call_cache *cc_entries;

  struct {
    rb_snum_t flip_count;
    VALUE coverage;
    VALUE pc2branchindex;
    VALUE *original_iseq;
  } variable;

  unsigned int local_table_size;
  unsigned int is_size;
  unsigned int ci_size;
  unsigned int ci_kw_size;
  unsigned int stack_max;

  VALUE (*jit_func)
  (struct rb_execution_context_struct *, struct rb_control_frame_struct *);
  long unsigned total_calls;
  struct rb_mjit_unit *jit_unit;

  char catch_except_p;
};

struct rb_iseq_struct {
  VALUE flags;
  VALUE reserved1;
  struct rb_iseq_constant_body *body;

  union {
    struct iseq_compile_data *compile_data;

    struct {
      VALUE obj;
      int index;
    } loader;

    rb_event_flag_t trace_events;
  } aux;
};
# 500 "./vm_core.h"
static inline const rb_iseq_t *rb_iseq_check(const rb_iseq_t *iseq) {

  return iseq;
}

static inline const rb_iseq_t *def_iseq_ptr(rb_method_definition_t *def) {

  return rb_iseq_check(def->body.iseq.iseqptr);
}

enum ruby_special_exceptions {
  ruby_error_reenter,
  ruby_error_nomemory,
  ruby_error_sysstack,
  ruby_error_stackfatal,
  ruby_error_stream_closed,
  ruby_special_error_count
};

enum ruby_basic_operators {
  BOP_PLUS,
  BOP_MINUS,
  BOP_MULT,
  BOP_DIV,
  BOP_MOD,
  BOP_EQ,
  BOP_EQQ,
  BOP_LT,
  BOP_LE,
  BOP_LTLT,
  BOP_AREF,
  BOP_ASET,
  BOP_LENGTH,
  BOP_SIZE,
  BOP_EMPTY_P,
  BOP_SUCC,
  BOP_GT,
  BOP_GE,
  BOP_NOT,
  BOP_NEQ,
  BOP_MATCH,
  BOP_FREEZE,
  BOP_UMINUS,
  BOP_MAX,
  BOP_MIN,
  BOP_CALL,
  BOP_AND,
  BOP_OR,

  BOP_LAST_
};

struct rb_vm_struct;
typedef void rb_vm_at_exit_func(struct rb_vm_struct *);

typedef struct rb_at_exit_list {
  rb_vm_at_exit_func *func;
  struct rb_at_exit_list *next;
} rb_at_exit_list;

struct rb_objspace;
struct rb_objspace *rb_objspace_alloc(void);
void rb_objspace_free(struct rb_objspace *);

typedef struct rb_hook_list_struct {
  struct rb_event_hook_struct *hooks;
  rb_event_flag_t events;
  int need_clean;
} rb_hook_list_t;

typedef struct rb_vm_struct {
  VALUE self;

  rb_global_vm_lock_t gvl;

  struct rb_thread_struct *main_thread;

  const struct rb_thread_struct *running_thread;

  void *main_altstack;

  rb_serial_t fork_gen;
  rb_nativethread_lock_t waitpid_lock;
  struct list_head waiting_pids;
  struct list_head waiting_grps;
  struct list_head waiting_fds;
  struct list_head living_threads;
  VALUE thgroup_default;
  int living_thread_num;

  unsigned int running : 1;
  unsigned int thread_abort_on_exception : 1;
  unsigned int thread_report_on_exception : 1;

  unsigned int safe_level_ : 1;

  int trace_running;
  int sleeper;

  VALUE mark_object_ary;
  const VALUE special_exceptions[ruby_special_error_count];

  VALUE top_self;
  VALUE load_path;
  VALUE load_path_snapshot;
  VALUE load_path_check_cache;
  VALUE expanded_load_path;
  VALUE loaded_features;
  VALUE loaded_features_snapshot;
  struct st_table *loaded_features_index;
  struct st_table *loading_table;

  struct {
    VALUE cmd[32];
    unsigned char safe[32];
  } trap_list;

  rb_hook_list_t event_hooks;

  struct st_table *ensure_rollback_table;

  struct rb_postponed_job_struct *postponed_job_buffer;
  int postponed_job_index;

  int src_encoding_index;

  VALUE verbose, debug, orig_progname, progname;
  VALUE coverages;
  int coverage_mode;

  VALUE defined_module_hash;

  struct rb_objspace *objspace;

  rb_at_exit_list *at_exit;

  VALUE *defined_strings;
  st_table *frozen_strings;

  struct {
    size_t thread_vm_stack_size;
    size_t thread_machine_stack_size;
    size_t fiber_vm_stack_size;
    size_t fiber_machine_stack_size;
  } default_params;

  short redefined_flag[BOP_LAST_];
} rb_vm_t;
# 715 "./vm_core.h"
struct rb_captured_block {
  VALUE self;
  const VALUE *ep;
  union {
    const rb_iseq_t *iseq;
    const struct vm_ifunc *ifunc;
    VALUE val;
  } code;
};

enum rb_block_handler_type {
  block_handler_type_iseq,
  block_handler_type_ifunc,
  block_handler_type_symbol,
  block_handler_type_proc
};

enum rb_block_type {
  block_type_iseq,
  block_type_ifunc,
  block_type_symbol,
  block_type_proc
};

struct rb_block {
  union {
    struct rb_captured_block captured;
    VALUE symbol;
    VALUE proc;
  } as;
  enum rb_block_type type;
};

typedef struct rb_control_frame_struct {
  const VALUE *pc;
  VALUE *sp;
  const rb_iseq_t *iseq;
  VALUE self;
  const VALUE *ep;
  const void *block_code;
  const VALUE *bp;

} rb_control_frame_t;

extern const rb_data_type_t ruby_threadptr_data_type;

static inline struct rb_thread_struct *rb_thread_ptr(VALUE thval) {
  return (struct rb_thread_struct *)rb_check_typeddata(
      thval, &ruby_threadptr_data_type);
}

enum rb_thread_status {
  THREAD_RUNNABLE,
  THREAD_STOPPED,
  THREAD_STOPPED_FOREVER,
  THREAD_KILLED
};

typedef sigjmp_buf rb_jmpbuf_t;

struct rb_vm_tag {
  VALUE tag;
  VALUE retval;
  rb_jmpbuf_t buf;
  struct rb_vm_tag *prev;
  enum ruby_tag_type state;
};

_Static_assert(__builtin_offsetof(struct rb_vm_tag, buf) > 0,
               "rb_vm_tag_buf_offset"
               ": "
               "offsetof(struct rb_vm_tag, buf) > 0");
_Static_assert(__builtin_offsetof(struct rb_vm_tag, buf) + sizeof(rb_jmpbuf_t) <
                   sizeof(struct rb_vm_tag),
               "rb_vm_tag_buf_end"
               ": "
               "offsetof(struct rb_vm_tag, buf) + sizeof(rb_jmpbuf_t) < "
               "sizeof(struct rb_vm_tag)");

struct rb_vm_protect_tag {
  struct rb_vm_protect_tag *prev;
};

struct rb_unblock_callback {
  rb_unblock_function_t *func;
  void *arg;
};

struct rb_mutex_struct;

typedef struct rb_thread_list_struct {
  struct rb_thread_list_struct *next;
  struct rb_thread_struct *th;
} rb_thread_list_t;

typedef struct rb_ensure_entry {
  VALUE marker;
  VALUE (*e_proc)();
  VALUE data2;
} rb_ensure_entry_t;

typedef struct rb_ensure_list {
  struct rb_ensure_list *next;
  struct rb_ensure_entry entry;
} rb_ensure_list_t;

typedef char rb_thread_id_string_t[sizeof(rb_nativethread_id_t) * 2 + 3];

typedef struct rb_fiber_struct rb_fiber_t;

typedef struct rb_execution_context_struct {

  VALUE *vm_stack;
  size_t vm_stack_size;
  rb_control_frame_t *cfp;

  struct rb_vm_tag *tag;
  struct rb_vm_protect_tag *protect_tag;

  rb_atomic_t interrupt_flag;
  rb_atomic_t interrupt_mask;

  rb_fiber_t *fiber_ptr;
  struct rb_thread_struct *thread_ptr;

  st_table *local_storage;
  VALUE local_storage_recursive_hash;
  VALUE local_storage_recursive_hash_for_trace;

  const VALUE *root_lep;
  VALUE root_svar;

  rb_ensure_list_t *ensure_list;

  struct rb_trace_arg_struct *trace_arg;

  VALUE errinfo;
  VALUE passed_block_handler;

  uint8_t raised_flag;

  enum method_missing_reason method_missing_reason : 8;

  VALUE private_const_reference;

  struct {
    VALUE *stack_start;
    VALUE *stack_end;
    size_t stack_maxsize;

    __attribute__((__aligned__(8))) jmp_buf regs;
  } machine;
} rb_execution_context_t;

void ec_set_vm_stack(rb_execution_context_t *ec, VALUE *stack, size_t size);

typedef struct rb_thread_struct {
  struct list_node vmlt_node;
  VALUE self;
  rb_vm_t *vm;

  rb_execution_context_t *ec;

  VALUE last_status;

  struct rb_calling_info *calling;

  VALUE top_self;
  VALUE top_wrapper;

  rb_nativethread_id_t thread_id;

  enum rb_thread_status status : 2;

  unsigned int to_kill : 1;
  unsigned int abort_on_exception : 1;
  unsigned int report_on_exception : 1;
  unsigned int pending_interrupt_queue_checked : 1;
  int8_t priority;
  uint32_t running_time_us;

  native_thread_data_t native_thread_data;
  void *blocking_region_buffer;

  VALUE thgroup;
  VALUE value;

  VALUE pending_interrupt_queue;
  VALUE pending_interrupt_mask_stack;

  rb_nativethread_lock_t interrupt_lock;
  struct rb_unblock_callback unblock;
  VALUE locking_mutex;
  struct rb_mutex_struct *keeping_mutexes;

  rb_thread_list_t *join_list;

  union {
    struct {
      VALUE proc;
      VALUE args;
    } proc;
    struct {
      VALUE (*func)();
      void *arg;
    } func;
  } invoke_arg;

  enum {
    thread_invoke_type_none = 0,
    thread_invoke_type_proc,
    thread_invoke_type_func
  } invoke_type;

  VALUE stat_insn_usage;

  rb_fiber_t *root_fiber;
  rb_jmpbuf_t root_jmpbuf;

  VALUE name;

} rb_thread_t;

typedef enum {
  VM_DEFINECLASS_TYPE_CLASS = 0x00,
  VM_DEFINECLASS_TYPE_SINGLETON_CLASS = 0x01,
  VM_DEFINECLASS_TYPE_MODULE = 0x02,

  VM_DEFINECLASS_TYPE_MASK = 0x07
} rb_vm_defineclass_type_t;
# 983 "./vm_core.h"
#pragma GCC visibility push(default)

rb_iseq_t *rb_iseq_new(const rb_ast_body_t *ast, VALUE name, VALUE path,
                       VALUE realpath, const rb_iseq_t *parent, enum iseq_type);
rb_iseq_t *rb_iseq_new_top(const rb_ast_body_t *ast, VALUE name, VALUE path,
                           VALUE realpath, const rb_iseq_t *parent);
rb_iseq_t *rb_iseq_new_main(const rb_ast_body_t *ast, VALUE path,
                            VALUE realpath, const rb_iseq_t *parent);
rb_iseq_t *rb_iseq_new_with_opt(const rb_ast_body_t *ast, VALUE name,
                                VALUE path, VALUE realpath, VALUE first_lineno,
                                const rb_iseq_t *parent, enum iseq_type,
                                const rb_compile_option_t *);
rb_iseq_t *rb_iseq_new_ifunc(const struct vm_ifunc *ifunc, VALUE name,
                             VALUE path, VALUE realpath, VALUE first_lineno,
                             const rb_iseq_t *parent, enum iseq_type,
                             const rb_compile_option_t *);

rb_iseq_t *rb_iseq_compile(VALUE src, VALUE file, VALUE line);
rb_iseq_t *rb_iseq_compile_on_base(VALUE src, VALUE file, VALUE line,
                                   const struct rb_block *base_block);
rb_iseq_t *rb_iseq_compile_with_option(VALUE src, VALUE file, VALUE realpath,
                                       VALUE line,
                                       const struct rb_block *base_block,
                                       VALUE opt);

VALUE rb_iseq_disasm(const rb_iseq_t *iseq);
int rb_iseq_disasm_insn(VALUE str, const VALUE *iseqval, size_t pos,
                        const rb_iseq_t *iseq, VALUE child);
const char *ruby_node_name(int node);

VALUE rb_iseq_coverage(const rb_iseq_t *iseq);

extern VALUE rb_cISeq;
extern VALUE rb_cRubyVM;
extern VALUE rb_mRubyVMFrozenCore;
#pragma GCC visibility pop

typedef struct {
  const struct rb_block block;
  unsigned int is_from_method : 1;
  unsigned int is_lambda : 1;
} rb_proc_t;

typedef struct {
  VALUE flags;
  const rb_iseq_t *iseq;
  const VALUE *ep;
  const VALUE *env;
  unsigned int env_size;
} rb_env_t;

extern const rb_data_type_t ruby_binding_data_type;

typedef struct {
  const struct rb_block block;
  const VALUE pathobj;
  unsigned short first_lineno;
} rb_binding_t;

enum vm_check_match_type {
  VM_CHECKMATCH_TYPE_WHEN = 1,
  VM_CHECKMATCH_TYPE_CASE = 2,
  VM_CHECKMATCH_TYPE_RESCUE = 3
};

enum vm_call_flag_bits {
  VM_CALL_ARGS_SPLAT_bit,
  VM_CALL_ARGS_BLOCKARG_bit,
  VM_CALL_FCALL_bit,
  VM_CALL_VCALL_bit,
  VM_CALL_ARGS_SIMPLE_bit,
  VM_CALL_BLOCKISEQ_bit,
  VM_CALL_KWARG_bit,
  VM_CALL_KW_SPLAT_bit,
  VM_CALL_TAILCALL_bit,
  VM_CALL_SUPER_bit,
  VM_CALL_ZSUPER_bit,
  VM_CALL_OPT_SEND_bit,
  VM_CALL__END
};
# 1078 "./vm_core.h"
enum vm_special_object_type {
  VM_SPECIAL_OBJECT_VMCORE = 1,
  VM_SPECIAL_OBJECT_CBASE,
  VM_SPECIAL_OBJECT_CONST_BASE
};

enum vm_svar_index {
  VM_SVAR_LASTLINE = 0,
  VM_SVAR_BACKREF = 1,

  VM_SVAR_EXTRA_START = 2,
  VM_SVAR_FLIPFLOP_START = 2
};

typedef struct iseq_inline_cache_entry *IC;
typedef union iseq_inline_storage_entry *ISE;
typedef struct rb_call_info *CALL_INFO;
typedef struct rb_call_cache *CALL_CACHE;

void rb_vm_change_state(void);

typedef VALUE CDHASH;

typedef rb_control_frame_t *(*rb_insn_func_t)(rb_execution_context_t *,
                                              rb_control_frame_t *);
# 1116 "./vm_core.h"
enum {
# 1127 "./vm_core.h"
  VM_FRAME_MAGIC_METHOD = 0x11110001,
  VM_FRAME_MAGIC_BLOCK = 0x22220001,
  VM_FRAME_MAGIC_CLASS = 0x33330001,
  VM_FRAME_MAGIC_TOP = 0x44440001,
  VM_FRAME_MAGIC_CFUNC = 0x55550001,
  VM_FRAME_MAGIC_IFUNC = 0x66660001,
  VM_FRAME_MAGIC_EVAL = 0x77770001,
  VM_FRAME_MAGIC_RESCUE = 0x78880001,
  VM_FRAME_MAGIC_DUMMY = 0x79990001,

  VM_FRAME_MAGIC_MASK = 0x7fff0001,

  VM_FRAME_FLAG_PASSED = 0x0010,
  VM_FRAME_FLAG_FINISH = 0x0020,
  VM_FRAME_FLAG_BMETHOD = 0x0040,
  VM_FRAME_FLAG_CFRAME = 0x0080,
  VM_FRAME_FLAG_LAMBDA = 0x0100,
  VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM = 0x0200,

  VM_ENV_FLAG_LOCAL = 0x0002,
  VM_ENV_FLAG_ESCAPED = 0x0004,
  VM_ENV_FLAG_WB_REQUIRED = 0x0008
};
# 1162 "./vm_core.h"
static inline void VM_FORCE_WRITE_SPECIAL_CONST(const VALUE *ptr,
                                                VALUE special_const_value);

static inline void VM_ENV_FLAGS_SET(const VALUE *ep, VALUE flag) {
  VALUE flags = ep[(0)];
  ((void)0);
  VM_FORCE_WRITE_SPECIAL_CONST(&ep[(0)], flags | flag);
}

static inline void VM_ENV_FLAGS_UNSET(const VALUE *ep, VALUE flag) {
  VALUE flags = ep[(0)];
  ((void)0);
  VM_FORCE_WRITE_SPECIAL_CONST(&ep[(0)], flags & ~flag);
}

static inline unsigned long VM_ENV_FLAGS(const VALUE *ep, long flag) {
  VALUE flags = ep[(0)];
  ((void)0);
  return flags & flag;
}

static inline unsigned long VM_FRAME_TYPE(const rb_control_frame_t *cfp) {
  return VM_ENV_FLAGS(cfp->ep, VM_FRAME_MAGIC_MASK);
}

static inline int VM_FRAME_LAMBDA_P(const rb_control_frame_t *cfp) {
  return VM_ENV_FLAGS(cfp->ep, VM_FRAME_FLAG_LAMBDA) != 0;
}

static inline int VM_FRAME_FINISHED_P(const rb_control_frame_t *cfp) {
  return VM_ENV_FLAGS(cfp->ep, VM_FRAME_FLAG_FINISH) != 0;
}

static inline int VM_FRAME_BMETHOD_P(const rb_control_frame_t *cfp) {
  return VM_ENV_FLAGS(cfp->ep, VM_FRAME_FLAG_BMETHOD) != 0;
}

static inline int rb_obj_is_iseq(VALUE iseq) {
  return imemo_type_p(iseq, imemo_iseq);
}

static inline int VM_FRAME_CFRAME_P(const rb_control_frame_t *cfp) {
  int cframe_p = VM_ENV_FLAGS(cfp->ep, VM_FRAME_FLAG_CFRAME) != 0;
  ((void)0);
  return cframe_p;
}

static inline int VM_FRAME_RUBYFRAME_P(const rb_control_frame_t *cfp) {
  return !VM_FRAME_CFRAME_P(cfp);
}

static inline int VM_ENV_LOCAL_P(const VALUE *ep) {
  return VM_ENV_FLAGS(ep, VM_ENV_FLAG_LOCAL) ? 1 : 0;
}

static inline const VALUE *VM_ENV_PREV_EP(const VALUE *ep) {
  ((void)0);
  return ((void *)(((ep[(-1)])) & ~0x03));
}

static inline VALUE VM_ENV_BLOCK_HANDLER(const VALUE *ep) {
  ((void)0);
  return ep[(-1)];
}

static inline int VM_ENV_ESCAPED_P(const VALUE *ep) {
  ((void)0);
  return VM_ENV_FLAGS(ep, VM_ENV_FLAG_ESCAPED) ? 1 : 0;
}
# 1282 "./vm_core.h"
static inline VALUE VM_ENV_ENVVAL(const VALUE *ep) {
  VALUE envval = ep[(1)];
  ((void)0);
  ((void)0);
  return envval;
}

static inline const rb_env_t *VM_ENV_ENVVAL_PTR(const VALUE *ep) {
  return (const rb_env_t *)VM_ENV_ENVVAL(ep);
}

static inline const rb_env_t *vm_env_new(VALUE *env_ep, VALUE *env_body,
                                         unsigned int env_size,
                                         const rb_iseq_t *iseq) {
  rb_env_t *env = (rb_env_t *)rb_imemo_new(imemo_env, (VALUE)env_ep,
                                           (VALUE)env_body, 0, (VALUE)iseq);
  env->env_size = env_size;
  env_ep[(1)] = (VALUE)env;
  return env;
}

static inline void VM_FORCE_WRITE(const VALUE *ptr, VALUE v) {
  *((VALUE *)ptr) = v;
}

static inline void VM_FORCE_WRITE_SPECIAL_CONST(const VALUE *ptr,
                                                VALUE special_const_value) {
  ((void)0);
  VM_FORCE_WRITE(ptr, special_const_value);
}

static inline void VM_STACK_ENV_WRITE(const VALUE *ep, int index, VALUE v) {
  ((void)0);
  VM_FORCE_WRITE(&ep[index], v);
}

const VALUE *rb_vm_ep_local_ep(const VALUE *ep);
const VALUE *rb_vm_proc_local_ep(VALUE proc);
void rb_vm_block_ep_update(VALUE obj, const struct rb_block *dst,
                           const VALUE *ep);
void rb_vm_block_copy(VALUE obj, const struct rb_block *dst,
                      const struct rb_block *src);

VALUE rb_vm_frame_block_handler(const rb_control_frame_t *cfp);

static inline const rb_control_frame_t *
RUBY_VM_END_CONTROL_FRAME(const rb_execution_context_t *ec) {
  return (rb_control_frame_t *)(ec->vm_stack + ec->vm_stack_size);
}

static inline int
RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(const rb_execution_context_t *ec,
                                       const rb_control_frame_t *cfp) {
  return !((void *)(RUBY_VM_END_CONTROL_FRAME(ec)) > (void *)(cfp));
}

static inline int VM_BH_ISEQ_BLOCK_P(VALUE block_handler) {
  if ((block_handler & 0x03) == 0x01) {

    return 1;
  } else {
    return 0;
  }
}

static inline VALUE
VM_BH_FROM_ISEQ_BLOCK(const struct rb_captured_block *captured) {
  VALUE block_handler = ((VALUE)(captured) | (0x01));
  ((void)0);
  return block_handler;
}

static inline const struct rb_captured_block *
VM_BH_TO_ISEQ_BLOCK(VALUE block_handler) {
  struct rb_captured_block *captured = ((void *)((block_handler) & ~0x03));
  ((void)0);
  return captured;
}

static inline int VM_BH_IFUNC_P(VALUE block_handler) {
  if ((block_handler & 0x03) == 0x03) {

    return 1;
  } else {
    return 0;
  }
}

static inline VALUE
VM_BH_FROM_IFUNC_BLOCK(const struct rb_captured_block *captured) {
  VALUE block_handler = ((VALUE)(captured) | (0x03));
  ((void)0);
  return block_handler;
}

static inline const struct rb_captured_block *
VM_BH_TO_IFUNC_BLOCK(VALUE block_handler) {
  struct rb_captured_block *captured = ((void *)((block_handler) & ~0x03));
  ((void)0);
  return captured;
}

static inline const struct rb_captured_block *
VM_BH_TO_CAPT_BLOCK(VALUE block_handler) {
  struct rb_captured_block *captured = ((void *)((block_handler) & ~0x03));
  ((void)0);
  return captured;
}

static inline enum rb_block_handler_type
vm_block_handler_type(VALUE block_handler) {
  if (VM_BH_ISEQ_BLOCK_P(block_handler)) {
    return block_handler_type_iseq;
  } else if (VM_BH_IFUNC_P(block_handler)) {
    return block_handler_type_ifunc;
  } else if (((((VALUE)(block_handler) &
                ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) == RUBY_SYMBOL_FLAG) ||
              (!(((VALUE)(block_handler)&RUBY_IMMEDIATE_MASK) ||
                 !!(((VALUE)(block_handler) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                    0)) &&
               (int)(((struct RBasic *)(block_handler))->flags & RUBY_T_MASK) ==
                   (RUBY_T_SYMBOL)))) {
    return block_handler_type_symbol;
  } else {
    ((void)0);
    return block_handler_type_proc;
  }
}

static inline void vm_block_handler_verify(__attribute__((__unused__))
                                           VALUE block_handler) {
  ((void)0);
}

static inline enum rb_block_type vm_block_type(const struct rb_block *block) {
# 1465 "./vm_core.h"
  return block->type;
}

static inline void vm_block_type_set(const struct rb_block *block,
                                     enum rb_block_type type) {
  struct rb_block *mb = (struct rb_block *)block;
  mb->type = type;
}

static inline const struct rb_block *vm_proc_block(VALUE procval) {
  ((void)0);
  return &((rb_proc_t *)(((struct RTypedData *)(procval))->data))->block;
}

static inline const rb_iseq_t *vm_block_iseq(const struct rb_block *block);
static inline const VALUE *vm_block_ep(const struct rb_block *block);

static inline const rb_iseq_t *vm_proc_iseq(VALUE procval) {
  return vm_block_iseq(vm_proc_block(procval));
}

static inline const VALUE *vm_proc_ep(VALUE procval) {
  return vm_block_ep(vm_proc_block(procval));
}

static inline const rb_iseq_t *vm_block_iseq(const struct rb_block *block) {
  switch (vm_block_type(block)) {
  case block_type_iseq:
    return rb_iseq_check(block->as.captured.code.iseq);
  case block_type_proc:
    return vm_proc_iseq(block->as.proc);
  case block_type_ifunc:
  case block_type_symbol:
    return ((void *)0);
  }
  __builtin_unreachable();
  return ((void *)0);
}

static inline const VALUE *vm_block_ep(const struct rb_block *block) {
  switch (vm_block_type(block)) {
  case block_type_iseq:
  case block_type_ifunc:
    return block->as.captured.ep;
  case block_type_proc:
    return vm_proc_ep(block->as.proc);
  case block_type_symbol:
    return ((void *)0);
  }
  __builtin_unreachable();
  return ((void *)0);
}

static inline VALUE vm_block_self(const struct rb_block *block) {
  switch (vm_block_type(block)) {
  case block_type_iseq:
  case block_type_ifunc:
    return block->as.captured.self;
  case block_type_proc:
    return vm_block_self(vm_proc_block(block->as.proc));
  case block_type_symbol:
    return ((VALUE)RUBY_Qundef);
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qundef);
}

static inline VALUE VM_BH_TO_SYMBOL(VALUE block_handler) {
  ((void)0);
  return block_handler;
}

static inline VALUE VM_BH_FROM_SYMBOL(VALUE symbol) {
  ((void)0);
  return symbol;
}

static inline VALUE VM_BH_TO_PROC(VALUE block_handler) {
  ((void)0);
  return block_handler;
}

static inline VALUE VM_BH_FROM_PROC(VALUE procval) {
  ((void)0);
  return procval;
}

VALUE rb_thread_alloc(VALUE klass);
VALUE rb_binding_alloc(VALUE klass);
VALUE rb_proc_alloc(VALUE klass);
VALUE rb_proc_dup(VALUE self);

extern void rb_vmdebug_stack_dump_raw(const rb_execution_context_t *ec,
                                      const rb_control_frame_t *cfp);
extern void rb_vmdebug_debug_print_pre(const rb_execution_context_t *ec,
                                       const rb_control_frame_t *cfp,
                                       const VALUE *_pc);
extern void rb_vmdebug_debug_print_post(const rb_execution_context_t *ec,
                                        const rb_control_frame_t *cfp);

void rb_vm_bugreport(const void *);
__attribute__((__noreturn__)) void rb_bug_context(const void *, const char *fmt,
                                                  ...);

#pragma GCC visibility push(default)
VALUE rb_iseq_eval(const rb_iseq_t *iseq);
VALUE rb_iseq_eval_main(const rb_iseq_t *iseq);
VALUE rb_iseq_path(const rb_iseq_t *iseq);
VALUE rb_iseq_realpath(const rb_iseq_t *iseq);
#pragma GCC visibility pop

VALUE rb_iseq_pathobj_new(VALUE path, VALUE realpath);
void rb_iseq_pathobj_set(const rb_iseq_t *iseq, VALUE path, VALUE realpath);

int rb_ec_frame_method_id_and_class(const rb_execution_context_t *ec, ID *idp,
                                    ID *called_idp, VALUE *klassp);
void rb_ec_setup_exception(const rb_execution_context_t *ec, VALUE mesg,
                           VALUE cause);

VALUE rb_vm_invoke_proc(rb_execution_context_t *ec, rb_proc_t *proc, int argc,
                        const VALUE *argv, VALUE block_handler);

VALUE rb_vm_make_proc_lambda(const rb_execution_context_t *ec,
                             const struct rb_captured_block *captured,
                             VALUE klass, int8_t is_lambda);
static inline VALUE rb_vm_make_proc(const rb_execution_context_t *ec,
                                    const struct rb_captured_block *captured,
                                    VALUE klass) {
  return rb_vm_make_proc_lambda(ec, captured, klass, 0);
}

static inline VALUE rb_vm_make_lambda(const rb_execution_context_t *ec,
                                      const struct rb_captured_block *captured,
                                      VALUE klass) {
  return rb_vm_make_proc_lambda(ec, captured, klass, 1);
}

VALUE rb_vm_make_binding(const rb_execution_context_t *ec,
                         const rb_control_frame_t *src_cfp);
VALUE rb_vm_env_local_variables(const rb_env_t *env);
const rb_env_t *rb_vm_env_prev_env(const rb_env_t *env);
const VALUE *rb_binding_add_dynavars(VALUE bindval, rb_binding_t *bind,
                                     int dyncount, const ID *dynvars);
void rb_vm_inc_const_missing_count(void);
void rb_vm_gvl_destroy(rb_vm_t *vm);
VALUE rb_vm_call(rb_execution_context_t *ec, VALUE recv, VALUE id, int argc,
                 const VALUE *argv, const rb_callable_method_entry_t *me);
void rb_vm_pop_frame(rb_execution_context_t *ec);

void rb_thread_start_timer_thread(void);
void rb_thread_stop_timer_thread(void);
void rb_thread_reset_timer_thread(void);
void rb_thread_wakeup_timer_thread(int);

static inline void rb_vm_living_threads_init(rb_vm_t *vm) {
  list_head_init(&vm->waiting_fds);
  list_head_init(&vm->waiting_pids);
  list_head_init(&vm->waiting_grps);
  list_head_init(&vm->living_threads);
  vm->living_thread_num = 0;
}

static inline void rb_vm_living_threads_insert(rb_vm_t *vm, rb_thread_t *th) {
  list_add_tail_(&vm->living_threads, &th->vmlt_node,
                 "./vm_core.h"
                 ":"
                 "1640");
  vm->living_thread_num++;
}

static inline void rb_vm_living_threads_remove(rb_vm_t *vm, rb_thread_t *th) {
  list_del_(&th->vmlt_node, "./vm_core.h"
                            ":"
                            "1647");
  vm->living_thread_num--;
}

typedef int rb_backtrace_iter_func(void *, VALUE, int, VALUE);
rb_control_frame_t *
rb_vm_get_ruby_level_next_cfp(const rb_execution_context_t *ec,
                              const rb_control_frame_t *cfp);
rb_control_frame_t *
rb_vm_get_binding_creatable_next_cfp(const rb_execution_context_t *ec,
                                     const rb_control_frame_t *cfp);
int rb_vm_get_sourceline(const rb_control_frame_t *);
VALUE rb_name_err_mesg_new(VALUE mesg, VALUE recv, VALUE method);
void rb_vm_stack_to_heap(rb_execution_context_t *ec);
void ruby_thread_init_stack(rb_thread_t *th);
int rb_vm_control_frame_id_and_class(const rb_control_frame_t *cfp, ID *idp,
                                     ID *called_idp, VALUE *klassp);
void rb_vm_rewind_cfp(rb_execution_context_t *ec, rb_control_frame_t *cfp);
VALUE rb_vm_bh_to_procval(const rb_execution_context_t *ec,
                          VALUE block_handler);

void rb_vm_register_special_exception_str(enum ruby_special_exceptions sp,
                                          VALUE exception_class, VALUE mesg);

void rb_gc_mark_machine_stack(const rb_execution_context_t *ec);

void rb_vm_rewrite_cref(rb_cref_t *node, VALUE old_klass, VALUE new_klass,
                        rb_cref_t **new_cref_ptr);

const rb_callable_method_entry_t *
rb_vm_frame_method_entry(const rb_control_frame_t *cfp);
# 1687 "./vm_core.h"
VALUE rb_catch_protect(VALUE t, rb_block_call_func *func, VALUE data,
                       enum ruby_tag_type *stateptr);

#pragma GCC visibility push(default)

extern rb_vm_t *ruby_current_vm_ptr;
extern rb_execution_context_t *ruby_current_execution_context_ptr;
extern rb_event_flag_t ruby_vm_event_flags;
extern rb_event_flag_t ruby_vm_event_enabled_flags;

#pragma GCC visibility pop

static inline rb_thread_t *rb_ec_thread_ptr(const rb_execution_context_t *ec) {
  return ec->thread_ptr;
}

static inline rb_vm_t *rb_ec_vm_ptr(const rb_execution_context_t *ec) {
  const rb_thread_t *th = rb_ec_thread_ptr(ec);
  if (th) {
    return th->vm;
  } else {
    return ((void *)0);
  }
}

static inline rb_execution_context_t *rb_current_execution_context(void) {
  return ruby_current_execution_context_ptr;
}

static inline rb_thread_t *rb_current_thread(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  return rb_ec_thread_ptr(ec);
}

static inline rb_vm_t *rb_current_vm(void) {
  ((void)0);

  return ruby_current_vm_ptr;
}
# 1759 "./vm_core.h"
enum {
  TIMER_INTERRUPT_MASK = 0x01,
  PENDING_INTERRUPT_MASK = 0x02,
  POSTPONED_JOB_INTERRUPT_MASK = 0x04,
  TRAP_INTERRUPT_MASK = 0x08
};
# 1774 "./vm_core.h"
VALUE rb_exc_set_backtrace(VALUE exc, VALUE bt);
int rb_signal_buff_size(void);
int rb_signal_exec(rb_thread_t *th, int sig);
void rb_threadptr_check_signal(rb_thread_t *mth);
void rb_threadptr_signal_raise(rb_thread_t *th, int sig);
void rb_threadptr_signal_exit(rb_thread_t *th);
int rb_threadptr_execute_interrupts(rb_thread_t *, int);
void rb_threadptr_interrupt(rb_thread_t *th);
void rb_threadptr_unlock_all_locking_mutexes(rb_thread_t *th);
void rb_threadptr_pending_interrupt_clear(rb_thread_t *th);
void rb_threadptr_pending_interrupt_enque(rb_thread_t *th, VALUE v);
void rb_ec_error_print(rb_execution_context_t *volatile ec,
                       volatile VALUE errinfo);
void rb_execution_context_mark(const rb_execution_context_t *ec);
void rb_fiber_close(rb_fiber_t *fib);
void Init_native_thread(rb_thread_t *th);

static inline void rb_vm_check_ints(rb_execution_context_t *ec) {
  ((void)0);
  if ((__builtin_expect(!!(((ec)->interrupt_flag & ~(ec)->interrupt_mask)),
                        0))) {
    rb_threadptr_execute_interrupts(rb_ec_thread_ptr(ec), 0);
  }
}

struct rb_trace_arg_struct {
  rb_event_flag_t event;
  rb_execution_context_t *ec;
  const rb_control_frame_t *cfp;
  VALUE self;
  ID id;
  ID called_id;
  VALUE klass;
  VALUE data;

  int klass_solved;

  int lineno;
  VALUE path;
};

void rb_exec_event_hooks(struct rb_trace_arg_struct *trace_arg, int pop_p);
# 1828 "./vm_core.h"
static inline void rb_exec_event_hook_orig(rb_execution_context_t *ec,
                                           const rb_event_flag_t flag,
                                           VALUE self, ID id, ID called_id,
                                           VALUE klass, VALUE data, int pop_p) {
  struct rb_trace_arg_struct trace_arg;

  ((void)0);
  ((void)0);

  trace_arg.event = flag;
  trace_arg.ec = ec;
  trace_arg.cfp = ec->cfp;
  trace_arg.self = self;
  trace_arg.id = id;
  trace_arg.called_id = called_id;
  trace_arg.klass = klass;
  trace_arg.data = data;
  trace_arg.path = ((VALUE)RUBY_Qundef);
  trace_arg.klass_solved = 0;
  rb_exec_event_hooks(&trace_arg, pop_p);
}

#pragma GCC visibility push(default)

int rb_thread_check_trap_pending(void);

extern VALUE rb_get_coverages(void);
extern void rb_set_coverages(VALUE, int, VALUE);
extern void rb_clear_coverages(void);
extern void rb_reset_coverages(void);

void rb_postponed_job_flush(rb_vm_t *vm);

#pragma GCC visibility pop
# 19 "vm.c" 2
# 1 "./vm_debug.h" 1
# 18 "./vm_debug.h"
#pragma GCC visibility push(default)

VALUE ruby_debug_print_value(int level, int debug_level, const char *header,
                             VALUE v);
ID ruby_debug_print_id(int level, int debug_level, const char *header, ID id);
NODE *ruby_debug_print_node(int level, int debug_level, const char *header,
                            const NODE *node);
int ruby_debug_print_indent(int level, int debug_level, int indent_level);
void ruby_debug_breakpoint(void);
void ruby_debug_gc_check_func(void);
void ruby_set_debug_option(const char *str);

#pragma GCC visibility pop
# 20 "vm.c" 2
# 1 "./iseq.h" 1
# 15 "./iseq.h"
extern const int ruby_api_version[];
# 24 "./iseq.h"
static inline size_t rb_call_info_kw_arg_bytes(int keyword_len) {
  return sizeof(struct rb_call_info_kw_arg) + sizeof(VALUE) * (keyword_len - 1);
}
# 40 "./iseq.h"
static inline rb_snum_t ISEQ_FLIP_CNT_INCREMENT(const rb_iseq_t *iseq) {
  rb_snum_t cnt = iseq->body->variable.flip_count;
  iseq->body->variable.flip_count += 1;
  return cnt;
}

static inline VALUE *ISEQ_ORIGINAL_ISEQ(const rb_iseq_t *iseq) {
  return iseq->body->variable.original_iseq;
}

static inline void ISEQ_ORIGINAL_ISEQ_CLEAR(const rb_iseq_t *iseq) {
  void *ptr = iseq->body->variable.original_iseq;
  iseq->body->variable.original_iseq = ((void *)0);
  if (ptr) {
    ruby_xfree(ptr);
  }
}

static inline VALUE *ISEQ_ORIGINAL_ISEQ_ALLOC(const rb_iseq_t *iseq,
                                              long size) {
  return iseq->body->variable.original_iseq =
             ruby_xmalloc2(size, sizeof(VALUE));
}
# 86 "./iseq.h"
struct iseq_compile_data {

  const VALUE err_info;
  VALUE mark_ary;
  const VALUE catch_table_ary;

  struct iseq_label_data *start_label;
  struct iseq_label_data *end_label;
  struct iseq_label_data *redo_label;
  const rb_iseq_t *current_block;
  VALUE ensure_node;
  VALUE for_iseq;
  struct iseq_compile_data_ensure_node_stack *ensure_node_stack;
  struct iseq_compile_data_storage *storage_head;
  struct iseq_compile_data_storage *storage_current;
  int loopval_popped;
  int last_line;
  int label_no;
  int node_level;
  unsigned int ci_index;
  unsigned int ci_kw_index;
  const rb_compile_option_t *option;
  struct rb_id_table *ivar_cache_table;
};

static inline struct iseq_compile_data *
ISEQ_COMPILE_DATA(const rb_iseq_t *iseq) {
  if (iseq->flags & ((VALUE)RUBY_FL_USER6)) {
    return iseq->aux.compile_data;
  } else {
    return ((void *)0);
  }
}

static inline void ISEQ_COMPILE_DATA_ALLOC(rb_iseq_t *iseq) {
  iseq->flags |= ((VALUE)RUBY_FL_USER6);
  iseq->aux.compile_data = (((struct iseq_compile_data *)ruby_xcalloc(
      (size_t)(1), sizeof(struct iseq_compile_data))));
}

static inline void ISEQ_COMPILE_DATA_CLEAR(rb_iseq_t *iseq) {
  iseq->flags &= ~((VALUE)RUBY_FL_USER6);
  iseq->aux.compile_data = ((void *)0);
}

static inline rb_iseq_t *iseq_imemo_alloc(void) {
  return (rb_iseq_t *)rb_imemo_new(imemo_iseq, 0, 0, 0, 0);
}

VALUE rb_iseq_ibf_dump(const rb_iseq_t *iseq, VALUE opt);
void rb_ibf_load_iseq_complete(rb_iseq_t *iseq);
const rb_iseq_t *rb_iseq_ibf_load(VALUE str);
VALUE rb_iseq_ibf_load_extra_data(VALUE str);
void rb_iseq_init_trace(rb_iseq_t *iseq);

unsigned int *
rb_iseq_insns_info_decode_positions(const struct rb_iseq_constant_body *body);

#pragma GCC visibility push(default)

VALUE rb_iseq_compile_node(rb_iseq_t *iseq, const NODE *node);
VALUE rb_iseq_compile_ifunc(rb_iseq_t *iseq, const struct vm_ifunc *ifunc);
int rb_iseq_translate_threaded_code(rb_iseq_t *iseq);
VALUE *rb_iseq_original_iseq(const rb_iseq_t *iseq);
void rb_iseq_build_from_ary(rb_iseq_t *iseq, VALUE misc, VALUE locals,
                            VALUE args, VALUE exception, VALUE body);

VALUE rb_iseq_load(VALUE data, VALUE parent, VALUE opt);
VALUE rb_iseq_parameters(const rb_iseq_t *iseq, int is_proc);
struct st_table *ruby_insn_make_insn_table(void);
unsigned int rb_iseq_line_no(const rb_iseq_t *iseq, size_t pos);
void rb_iseq_trace_set(const rb_iseq_t *iseq, rb_event_flag_t turnon_events);
void rb_iseq_trace_set_all(rb_event_flag_t turnon_events);
void rb_iseq_trace_on_all(void);
void rb_iseq_insns_info_encode_positions(const rb_iseq_t *iseq);

VALUE rb_iseqw_new(const rb_iseq_t *iseq);
const rb_iseq_t *rb_iseqw_to_iseq(VALUE iseqw);

VALUE rb_iseq_absolute_path(const rb_iseq_t *iseq);
VALUE rb_iseq_label(const rb_iseq_t *iseq);
VALUE rb_iseq_base_label(const rb_iseq_t *iseq);
VALUE rb_iseq_first_lineno(const rb_iseq_t *iseq);
VALUE rb_iseq_method_name(const rb_iseq_t *iseq);
void rb_iseq_code_location(const rb_iseq_t *iseq, int *first_lineno,
                           int *first_column, int *last_lineno,
                           int *last_column);

void rb_iseq_remove_coverage_all(void);

const rb_iseq_t *rb_method_iseq(VALUE body);
const rb_iseq_t *rb_proc_get_iseq(VALUE proc, int *is_proc);

struct rb_compile_option_struct {
  unsigned int inline_const_cache : 1;
  unsigned int peephole_optimization : 1;
  unsigned int tailcall_optimization : 1;
  unsigned int specialized_instruction : 1;
  unsigned int operands_unification : 1;
  unsigned int instructions_unification : 1;
  unsigned int stack_caching : 1;
  unsigned int frozen_string_literal : 1;
  unsigned int debug_frozen_string_literal : 1;
  unsigned int coverage_enabled : 1;
  int debug_level;
};

struct iseq_insn_info_entry {
  int line_no;
  rb_event_flag_t events;
};

struct iseq_catch_table_entry {
  enum catch_type {
    CATCH_TYPE_RESCUE = (((VALUE)(1)) << 1 | RUBY_FIXNUM_FLAG),
    CATCH_TYPE_ENSURE = (((VALUE)(2)) << 1 | RUBY_FIXNUM_FLAG),
    CATCH_TYPE_RETRY = (((VALUE)(3)) << 1 | RUBY_FIXNUM_FLAG),
    CATCH_TYPE_BREAK = (((VALUE)(4)) << 1 | RUBY_FIXNUM_FLAG),
    CATCH_TYPE_REDO = (((VALUE)(5)) << 1 | RUBY_FIXNUM_FLAG),
    CATCH_TYPE_NEXT = (((VALUE)(6)) << 1 | RUBY_FIXNUM_FLAG)
  } type;
# 234 "./iseq.h"
  const rb_iseq_t *iseq;

  unsigned int start;
  unsigned int end;
  unsigned int cont;
  unsigned int sp;
};

struct iseq_catch_table {
  unsigned int size;
  struct iseq_catch_table_entry entries[];
} __attribute__((packed));

static inline int iseq_catch_table_bytes(int n) {
  enum {
    catch_table_entry_size = sizeof(struct iseq_catch_table_entry),
    catch_table_entries_max =
        (2147483647 - __builtin_offsetof(struct iseq_catch_table, entries)) /
        catch_table_entry_size
  };
  if (n > catch_table_entries_max)
    rb_fatal("too large iseq_catch_table - %d", n);
  return (int)(__builtin_offsetof(struct iseq_catch_table, entries) +
               n * catch_table_entry_size);
}

struct iseq_compile_data_storage {
  struct iseq_compile_data_storage *next;
  unsigned int pos;
  unsigned int size;
  char buff[];
};

enum defined_type {
  DEFINED_NOT_DEFINED,
  DEFINED_NIL = 1,
  DEFINED_IVAR,
  DEFINED_LVAR,
  DEFINED_GVAR,
  DEFINED_CVAR,
  DEFINED_CONST,
  DEFINED_METHOD,
  DEFINED_YIELD,
  DEFINED_ZSUPER,
  DEFINED_SELF,
  DEFINED_TRUE,
  DEFINED_FALSE,
  DEFINED_ASGN,
  DEFINED_EXPR,
  DEFINED_IVAR2,
  DEFINED_REF,
  DEFINED_FUNC
};

VALUE rb_iseq_defined_string(enum defined_type type);
void rb_iseq_make_compile_option(struct rb_compile_option_struct *option,
                                 VALUE opt);

VALUE rb_iseq_local_variables(const rb_iseq_t *iseq);

#pragma GCC visibility pop
# 21 "vm.c" 2
# 1 "./eval_intern.h" 1

static inline void vm_passed_block_handler_set(rb_execution_context_t *ec,
                                               VALUE block_handler) {
  vm_block_handler_verify(block_handler);
  ec->passed_block_handler = block_handler;
}

static inline void pass_passed_block_handler(rb_execution_context_t *ec) {
  VALUE block_handler = rb_vm_frame_block_handler(ec->cfp);
  vm_passed_block_handler_set(ec, block_handler);
  VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_PASSED);
}
# 40 "./eval_intern.h"
# 1 "/usr/include/crt_externs.h" 1 3 4
# 37 "/usr/include/crt_externs.h" 3 4
extern char ***_NSGetArgv(void);
extern int *_NSGetArgc(void);
extern char ***_NSGetEnviron(void);
extern char **_NSGetProgname(void);

extern struct mach_header_64 *

_NSGetMachExecuteHeader(void);
# 41 "./eval_intern.h" 2
# 71 "./eval_intern.h"
# 1 "/usr/include/errno.h" 1 3 4
# 23 "/usr/include/errno.h" 3 4
# 1 "/usr/include/sys/errno.h" 1 3 4
# 80 "/usr/include/sys/errno.h" 3 4
extern int *__error(void);
# 24 "/usr/include/errno.h" 2 3 4
# 72 "./eval_intern.h" 2
# 89 "./eval_intern.h"
# 1 "/usr/include/sys/param.h" 1 3 4
# 107 "/usr/include/sys/param.h" 3 4
# 1 "/usr/include/machine/param.h" 1 3 4
# 35 "/usr/include/machine/param.h" 3 4
# 1 "/usr/include/i386/param.h" 1 3 4
# 75 "/usr/include/i386/param.h" 3 4
# 1 "/usr/include/i386/_param.h" 1 3 4
# 76 "/usr/include/i386/param.h" 2 3 4
# 36 "/usr/include/machine/param.h" 2 3 4
# 108 "/usr/include/sys/param.h" 2 3 4
# 90 "./eval_intern.h" 2
# 178 "./eval_intern.h"
static inline int rb_ec_tag_state(const rb_execution_context_t *ec) {
  enum ruby_tag_type state = ec->tag->state;
  ec->tag->state = RUBY_TAG_NONE;
  return state;
}

__attribute__((__noreturn__)) static inline void
rb_ec_tag_jump(const rb_execution_context_t *ec, enum ruby_tag_type st);
static inline void rb_ec_tag_jump(const rb_execution_context_t *ec,
                                  enum ruby_tag_type st) {
  ec->tag->state = st;
  siglongjmp(((ec->tag->buf)), (1));
}
# 210 "./eval_intern.h"
static inline VALUE CREF_CLASS(const rb_cref_t *cref) { return cref->klass; }

static inline rb_cref_t *CREF_NEXT(const rb_cref_t *cref) { return cref->next; }

static inline const rb_scope_visibility_t *
CREF_SCOPE_VISI(const rb_cref_t *cref) {
  return &cref->scope_visi;
}

static inline VALUE CREF_REFINEMENTS(const rb_cref_t *cref) {
  return cref->refinements;
}

static inline void CREF_REFINEMENTS_SET(rb_cref_t *cref, VALUE refs) {
  __extension__({
# 237 "./eval_intern.h"
#pragma clang diagnostic push
# 237 "./eval_intern.h"
    ;
# 237 "./eval_intern.h"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 237 "./eval_intern.h"
    ;
    typeof(rb_obj_write((VALUE)(cref), (VALUE *)(&cref->refinements),
                        (VALUE)(refs), "./eval_intern.h", 237))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(cref), (VALUE *)(&cref->refinements),
                          (VALUE)(refs), "./eval_intern.h", 237));
# 237 "./eval_intern.h"
#pragma clang diagnostic pop
# 237 "./eval_intern.h"
    ;
    unaligned_member_access_result;
  });
}

static inline int CREF_PUSHED_BY_EVAL(const rb_cref_t *cref) {
  return cref->flags & ((VALUE)RUBY_FL_USER5);
}

static inline void CREF_PUSHED_BY_EVAL_SET(rb_cref_t *cref) {
  cref->flags |= ((VALUE)RUBY_FL_USER5);
}

static inline int CREF_OMOD_SHARED(const rb_cref_t *cref) {
  return cref->flags & ((VALUE)RUBY_FL_USER6);
}

static inline void CREF_OMOD_SHARED_SET(rb_cref_t *cref) {
  cref->flags |= ((VALUE)RUBY_FL_USER6);
}

static inline void CREF_OMOD_SHARED_UNSET(rb_cref_t *cref) {
  cref->flags &= ~((VALUE)RUBY_FL_USER6);
}

void rb_thread_cleanup(void);
void rb_thread_wait_other_threads(void);

enum { RAISED_EXCEPTION = 1, RAISED_STACKOVERFLOW = 2, RAISED_NOMEMORY = 4 };

int rb_ec_set_raised(rb_execution_context_t *ec);
int rb_ec_reset_raised(rb_execution_context_t *ec);
int rb_ec_stack_check(rb_execution_context_t *ec);

VALUE rb_f_eval(int argc, const VALUE *argv, VALUE self);
VALUE rb_make_exception(int argc, const VALUE *argv);

__attribute__((__noreturn__)) void rb_method_name_error(VALUE, VALUE);

__attribute__((__noreturn__)) void rb_fiber_start(void);

__attribute__((__noreturn__)) void rb_print_undef(VALUE, ID,
                                                  rb_method_visibility_t);
__attribute__((__noreturn__)) void rb_print_undef_str(VALUE, VALUE);
__attribute__((__noreturn__)) void
    rb_print_inaccessible(VALUE, ID, rb_method_visibility_t);
__attribute__((__noreturn__)) void rb_vm_localjump_error(const char *, VALUE,
                                                         int);

VALUE rb_vm_make_jump_tag_but_local_jump(int state, VALUE val);
rb_cref_t *rb_vm_cref(void);
rb_cref_t *rb_vm_cref_replace_with_duplicated_cref(void);
VALUE rb_vm_call_cfunc(VALUE recv, VALUE (*func)(VALUE), VALUE arg,
                       VALUE block_handler, VALUE filename);
void rb_vm_set_progname(VALUE filename);
void rb_thread_terminate_all(void);
VALUE rb_vm_cbase(void);

VALUE rb_ec_backtrace_object(const rb_execution_context_t *ec);
VALUE rb_ec_backtrace_str_ary(const rb_execution_context_t *ec, long lev,
                              long n);
# 22 "vm.c" 2

# 1 "./probes.h" 1
# 252 "./probes.h"
extern void __dtrace_probe$ruby$array__create$v1$6c6f6e67$63686172202a$696e74(
    long, const char *, int);
extern int __dtrace_isenabled$ruby$array__create$v1(void);
extern void
__dtrace_probe$ruby$cmethod__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
    const char *, const char *, const char *, int);
extern int __dtrace_isenabled$ruby$cmethod__entry$v1(void);
extern void
__dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
    const char *, const char *, const char *, int);
extern int __dtrace_isenabled$ruby$cmethod__return$v1(void);
extern void
__dtrace_probe$ruby$find__require__entry$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$find__require__entry$v1(void);
extern void
__dtrace_probe$ruby$find__require__return$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$find__require__return$v1(void);
extern void __dtrace_probe$ruby$gc__mark__begin$v1(void);
extern int __dtrace_isenabled$ruby$gc__mark__begin$v1(void);
extern void __dtrace_probe$ruby$gc__mark__end$v1(void);
extern int __dtrace_isenabled$ruby$gc__mark__end$v1(void);
extern void __dtrace_probe$ruby$gc__sweep__begin$v1(void);
extern int __dtrace_isenabled$ruby$gc__sweep__begin$v1(void);
extern void __dtrace_probe$ruby$gc__sweep__end$v1(void);
extern int __dtrace_isenabled$ruby$gc__sweep__end$v1(void);
extern void __dtrace_probe$ruby$hash__create$v1$6c6f6e67$63686172202a$696e74(
    long, const char *, int);
extern int __dtrace_isenabled$ruby$hash__create$v1(void);
extern void __dtrace_probe$ruby$load__entry$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$load__entry$v1(void);
extern void
__dtrace_probe$ruby$load__return$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$load__return$v1(void);
extern void
__dtrace_probe$ruby$method__cache__clear$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$method__cache__clear$v1(void);
extern void
__dtrace_probe$ruby$method__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
    const char *, const char *, const char *, int);
extern int __dtrace_isenabled$ruby$method__entry$v1(void);
extern void
__dtrace_probe$ruby$method__return$v1$63686172202a$63686172202a$63686172202a$696e74(
    const char *, const char *, const char *, int);
extern int __dtrace_isenabled$ruby$method__return$v1(void);
extern void
__dtrace_probe$ruby$object__create$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$object__create$v1(void);
extern void
__dtrace_probe$ruby$parse__begin$v1$63686172202a$696e74(const char *, int);
extern int __dtrace_isenabled$ruby$parse__begin$v1(void);
extern void __dtrace_probe$ruby$parse__end$v1$63686172202a$696e74(const char *,
                                                                  int);
extern int __dtrace_isenabled$ruby$parse__end$v1(void);
extern void __dtrace_probe$ruby$raise$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$raise$v1(void);
extern void
__dtrace_probe$ruby$require__entry$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$require__entry$v1(void);
extern void
__dtrace_probe$ruby$require__return$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$require__return$v1(void);
extern void __dtrace_probe$ruby$string__create$v1$6c6f6e67$63686172202a$696e74(
    long, const char *, int);
extern int __dtrace_isenabled$ruby$string__create$v1(void);
extern void
__dtrace_probe$ruby$symbol__create$v1$63686172202a$63686172202a$696e74(
    const char *, const char *, int);
extern int __dtrace_isenabled$ruby$symbol__create$v1(void);
# 24 "vm.c" 2

# 1 "./probes_helper.h" 1

struct ruby_dtrace_method_hook_args {
  const char *classname;
  const char *methodname;
  const char *filename;
  int line_no;
  volatile VALUE klass;
  volatile VALUE name;
};

__attribute__((__noinline__)) int
rb_dtrace_setup(rb_execution_context_t *, VALUE, ID,
                struct ruby_dtrace_method_hook_args *);
# 28 "vm.c" 2

VALUE rb_str_concat_literals(size_t, const VALUE *);

__attribute__((__pure__)) static inline const VALUE *VM_EP_LEP(const VALUE *);
static inline const VALUE *VM_EP_LEP(const VALUE *ep) {
  while (!VM_ENV_LOCAL_P(ep)) {
    ep = VM_ENV_PREV_EP(ep);
  }
  return ep;
}

static inline const rb_control_frame_t *
rb_vm_search_cf_from_ep(const rb_execution_context_t *ec,
                        const rb_control_frame_t *cfp, const VALUE *const ep) {
  if (!ep) {
    return ((void *)0);
  } else {
    const rb_control_frame_t *const eocfp = RUBY_VM_END_CONTROL_FRAME(ec);

    while (cfp < eocfp) {
      if (cfp->ep == ep) {
        return cfp;
      }
      cfp = ((cfp) + 1);
    }

    return ((void *)0);
  }
}

const VALUE *rb_vm_ep_local_ep(const VALUE *ep) { return VM_EP_LEP(ep); }

__attribute__((__pure__)) static inline const VALUE *
VM_CF_LEP(const rb_control_frame_t *const cfp);
static inline const VALUE *VM_CF_LEP(const rb_control_frame_t *const cfp) {
  return VM_EP_LEP(cfp->ep);
}

static inline const VALUE *VM_CF_PREV_EP(const rb_control_frame_t *const cfp) {
  return VM_ENV_PREV_EP(cfp->ep);
}

__attribute__((__pure__)) static inline VALUE
VM_CF_BLOCK_HANDLER(const rb_control_frame_t *const cfp);
static inline VALUE VM_CF_BLOCK_HANDLER(const rb_control_frame_t *const cfp) {
  const VALUE *ep = VM_CF_LEP(cfp);
  return VM_ENV_BLOCK_HANDLER(ep);
}

VALUE
rb_vm_frame_block_handler(const rb_control_frame_t *cfp) {
  return VM_CF_BLOCK_HANDLER(cfp);
}
# 154 "vm.c"
static struct rb_captured_block *
VM_CFP_TO_CAPTURED_BLOCK(const rb_control_frame_t *cfp) {
  ((void)0);
  return (struct rb_captured_block *)&cfp->self;
}

static rb_control_frame_t *
VM_CAPTURED_BLOCK_TO_CFP(const struct rb_captured_block *captured) {
  rb_control_frame_t *cfp = ((rb_control_frame_t *)((VALUE *)(captured)-3));
  ((void)0);
  ((void)0);
  return cfp;
}

static int VM_BH_FROM_CFP_P(VALUE block_handler,
                            const rb_control_frame_t *cfp) {
  const struct rb_captured_block *captured = VM_CFP_TO_CAPTURED_BLOCK(cfp);
  return ((void *)((block_handler) & ~0x03)) == captured;
}

static VALUE vm_passed_block_handler(rb_execution_context_t *ec) {
  VALUE block_handler = ec->passed_block_handler;
  ec->passed_block_handler = 0;
  vm_block_handler_verify(block_handler);
  return block_handler;
}

static rb_cref_t *vm_cref_new0(VALUE klass, rb_method_visibility_t visi,
                               int module_func, rb_cref_t *prev_cref,
                               int pushed_by_eval, int use_prev_prev) {
  VALUE refinements = ((VALUE)RUBY_Qnil);
  int omod_shared = 0;
  rb_cref_t *cref;

  union {
    rb_scope_visibility_t visi;
    VALUE value;
  } scope_visi;

  scope_visi.visi.method_visi = visi;
  scope_visi.visi.module_func = module_func;

  if (prev_cref != ((void *)0) && prev_cref != (void *)1) {
    refinements = CREF_REFINEMENTS(prev_cref);

    if (!!((VALUE)(refinements) != ((VALUE)RUBY_Qnil))) {
      omod_shared = 1;
      CREF_OMOD_SHARED_SET(prev_cref);
    }
  }

  cref = (rb_cref_t *)rb_imemo_new(
      imemo_cref, klass,
      (VALUE)(use_prev_prev ? CREF_NEXT(prev_cref) : prev_cref),
      scope_visi.value, refinements);

  if (pushed_by_eval)
    CREF_PUSHED_BY_EVAL_SET(cref);
  if (omod_shared)
    CREF_OMOD_SHARED_SET(cref);

  return cref;
}

static rb_cref_t *vm_cref_new(VALUE klass, rb_method_visibility_t visi,
                              int module_func, rb_cref_t *prev_cref,
                              int pushed_by_eval) {
  return vm_cref_new0(klass, visi, module_func, prev_cref, pushed_by_eval, 0);
}

static rb_cref_t *vm_cref_new_use_prev(VALUE klass, rb_method_visibility_t visi,
                                       int module_func, rb_cref_t *prev_cref,
                                       int pushed_by_eval) {
  return vm_cref_new0(klass, visi, module_func, prev_cref, pushed_by_eval, 1);
}

static rb_cref_t *vm_cref_dup(const rb_cref_t *cref) {
  VALUE klass = CREF_CLASS(cref);
  const rb_scope_visibility_t *visi = CREF_SCOPE_VISI(cref);
  rb_cref_t *next_cref = CREF_NEXT(cref), *new_cref;
  int pushed_by_eval = CREF_PUSHED_BY_EVAL(cref);

  new_cref = vm_cref_new(klass, visi->method_visi, visi->module_func, next_cref,
                         pushed_by_eval);

  if (!!((VALUE)(CREF_REFINEMENTS(cref)) != ((VALUE)RUBY_Qnil))) {
    CREF_REFINEMENTS_SET(new_cref, rb_hash_dup(CREF_REFINEMENTS(cref)));
    CREF_OMOD_SHARED_UNSET(new_cref);
  }

  return new_cref;
}

static rb_cref_t *vm_cref_new_toplevel(rb_execution_context_t *ec) {
  rb_cref_t *cref =
      vm_cref_new(rb_cObject, METHOD_VISI_PRIVATE, 0, ((void *)0), 0);
  VALUE top_wrapper = rb_ec_thread_ptr(ec)->top_wrapper;

  if (top_wrapper) {
    cref = vm_cref_new(top_wrapper, METHOD_VISI_PRIVATE, 0, cref, 0);
  }

  return cref;
}

rb_cref_t *rb_vm_cref_new_toplevel(void) {
  return vm_cref_new_toplevel(rb_current_execution_context());
}

static void vm_cref_dump(const char *mesg, const rb_cref_t *cref) {
  fprintf(__stderrp, "vm_cref_dump: %s (%p)\n", mesg, (void *)cref);

  while (cref) {
    fprintf(__stderrp, "= cref| klass: %s\n",
            (!(((struct RBasic *)(rb_class_path(CREF_CLASS(cref))))->flags &
               RSTRING_NOEMBED)
                 ? ((struct RString *)(rb_class_path(CREF_CLASS(cref))))->as.ary
                 : ((struct RString *)(rb_class_path(CREF_CLASS(cref))))
                       ->as.heap.ptr));
    cref = CREF_NEXT(cref);
  }
}

void rb_vm_block_ep_update(VALUE obj, const struct rb_block *dst,
                           const VALUE *ep) {
  *((const VALUE **)&dst->as.captured.ep) = ep;
  rb_obj_written((VALUE)(obj), (VALUE)(((VALUE)RUBY_Qundef)),
                 (VALUE)(VM_ENV_ENVVAL(ep)), "vm.c", 284);
}

static void vm_bind_update_env(VALUE bindval, rb_binding_t *bind,
                               VALUE envval) {
  const rb_env_t *env = (rb_env_t *)envval;
  __extension__({
# 291 "vm.c"
#pragma clang diagnostic push
# 291 "vm.c"
    ;
# 291 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 291 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(bindval),
                        (VALUE *)(&bind->block.as.captured.code.iseq),
                        (VALUE)(env->iseq), "vm.c", 291))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(bindval),
                          (VALUE *)(&bind->block.as.captured.code.iseq),
                          (VALUE)(env->iseq), "vm.c", 291));
# 291 "vm.c"
#pragma clang diagnostic pop
# 291 "vm.c"
    ;
    unaligned_member_access_result;
  });
  rb_vm_block_ep_update(bindval, &bind->block, env->ep);
}

static VALUE vm_make_env_object(const rb_execution_context_t *ec,
                                rb_control_frame_t *cfp);
extern VALUE rb_vm_invoke_bmethod(rb_execution_context_t *ec, rb_proc_t *proc,
                                  VALUE self, int argc, const VALUE *argv,
                                  VALUE block_handler,
                                  const rb_callable_method_entry_t *me);
static VALUE vm_invoke_proc(rb_execution_context_t *ec, rb_proc_t *proc,
                            VALUE self, int argc, const VALUE *argv,
                            VALUE block_handler);

static VALUE rb_block_param_proxy;

# 1 "./mjit.h" 1
# 18 "./mjit.h"
enum rb_mjit_iseq_func {

  NOT_ADDED_JIT_ISEQ_FUNC = 0,

  NOT_READY_JIT_ISEQ_FUNC = 1,

  NOT_COMPILED_JIT_ISEQ_FUNC = 2,

  LAST_JIT_ISEQ_FUNC = 3
};

struct mjit_options {

  char on;

  char save_temps;

  char warnings;

  char debug;

  unsigned int wait;

  unsigned int min_calls;

  int verbose;

  int max_cache_size;
};

typedef VALUE (*mjit_func_t)(rb_execution_context_t *, rb_control_frame_t *);

#pragma GCC visibility push(default)
extern struct mjit_options mjit_opts;
extern int mjit_call_p;

extern void mjit_add_iseq_to_process(const rb_iseq_t *iseq);
extern VALUE mjit_wait_call(rb_execution_context_t *ec,
                            struct rb_iseq_constant_body *body);
#pragma GCC visibility pop

extern int mjit_compile(FILE *f, const struct rb_iseq_constant_body *body,
                        const char *funcname, struct rb_call_cache *cc_entries,
                        union iseq_inline_storage_entry *is_entries);
extern void mjit_init(struct mjit_options *opts);
extern void mjit_finish(void);
extern void mjit_gc_start_hook(void);
extern void mjit_gc_finish_hook(void);
extern void mjit_free_iseq(const rb_iseq_t *iseq);
extern void mjit_mark(void);
extern struct mjit_cont *mjit_cont_new(rb_execution_context_t *ec);
extern void mjit_cont_free(struct mjit_cont *cont);
extern void mjit_add_class_serial(rb_serial_t class_serial);
extern void mjit_remove_class_serial(rb_serial_t class_serial);

static inline int mjit_target_iseq_p(struct rb_iseq_constant_body *body) {
  return (body->type == ISEQ_TYPE_METHOD || body->type == ISEQ_TYPE_BLOCK) &&
         body->iseq_size < 1000;
}

static inline VALUE mjit_exec(rb_execution_context_t *ec) {
  const rb_iseq_t *iseq;
  struct rb_iseq_constant_body *body;
  long unsigned total_calls;
  mjit_func_t func;

  if (!mjit_call_p)
    return ((VALUE)RUBY_Qundef);

  iseq = ec->cfp->iseq;
  body = iseq->body;
  total_calls = ++body->total_calls;

  func = body->jit_func;
  if ((__builtin_expect(!!((uintptr_t)func <= (uintptr_t)LAST_JIT_ISEQ_FUNC),
                        0))) {
    switch ((enum rb_mjit_iseq_func)func) {
    case NOT_ADDED_JIT_ISEQ_FUNC:
      if (total_calls == mjit_opts.min_calls && mjit_target_iseq_p(body)) {
        mjit_add_iseq_to_process(iseq);
        if ((__builtin_expect(!!(mjit_opts.wait), 0))) {
          return mjit_wait_call(ec, body);
        }
      }
      return ((VALUE)RUBY_Qundef);
    case NOT_READY_JIT_ISEQ_FUNC:
    case NOT_COMPILED_JIT_ISEQ_FUNC:
      return ((VALUE)RUBY_Qundef);
    default:
      break;
    }
  }

  return func(ec, ec->cfp);
}

void mjit_child_after_fork(void);
# 310 "vm.c" 2
# 1 "./vm_insnhelper.h" 1
# 15 "./vm_insnhelper.h"
#pragma GCC visibility push(default)

extern VALUE ruby_vm_const_missing_count;
extern rb_serial_t ruby_vm_global_method_state;
extern rb_serial_t ruby_vm_global_constant_state;
extern rb_serial_t ruby_vm_class_serial;

#pragma GCC visibility pop
# 39 "./vm_insnhelper.h"
static inline int rb_obj_hidden_p(VALUE obj) {
  if ((((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return 0;
  } else {
    return (((struct RBasic *)(obj))->klass) ? 0 : 1;
  }
}
# 74 "./vm_insnhelper.h"
enum vm_regan_regtype {
  VM_REGAN_PC = 0,
  VM_REGAN_SP = 1,
  VM_REGAN_EP = 2,
  VM_REGAN_CFP = 3,
  VM_REGAN_SELF = 4,
  VM_REGAN_ISEQ = 5
};
enum vm_regan_acttype { VM_REGAN_ACT_GET = 0, VM_REGAN_ACT_SET = 1 };
# 244 "./vm_insnhelper.h"
extern rb_method_definition_t *
rb_method_definition_create(rb_method_type_t type, ID mid);
extern void rb_method_definition_set(const rb_method_entry_t *me,
                                     rb_method_definition_t *def, void *opts);
extern int rb_method_definition_eq(const rb_method_definition_t *d1,
                                   const rb_method_definition_t *d2);

extern VALUE rb_make_no_method_exception(VALUE exc, VALUE format, VALUE obj,
                                         int argc, const VALUE *argv, int priv);

static inline struct vm_throw_data *
THROW_DATA_NEW(VALUE val, const rb_control_frame_t *cf, VALUE st) {
  return (struct vm_throw_data *)rb_imemo_new(imemo_throw_data, val, (VALUE)cf,
                                              st, 0);
}

static inline VALUE THROW_DATA_VAL(const struct vm_throw_data *obj) {
  ((void)0);
  return obj->throw_obj;
}

static inline const rb_control_frame_t *
THROW_DATA_CATCH_FRAME(const struct vm_throw_data *obj) {
  ((void)0);
  return obj->catch_frame;
}

static inline int THROW_DATA_STATE(const struct vm_throw_data *obj) {
  ((void)0);
  return (int)obj->throw_state;
}

static inline int THROW_DATA_CONSUMED_P(const struct vm_throw_data *obj) {
  ((void)0);
  return obj->flags & ((VALUE)RUBY_FL_USER4);
}

static inline void THROW_DATA_CATCH_FRAME_SET(struct vm_throw_data *obj,
                                              const rb_control_frame_t *cfp) {
  ((void)0);
  obj->catch_frame = cfp;
}

static inline void THROW_DATA_STATE_SET(struct vm_throw_data *obj, int st) {
  ((void)0);
  obj->throw_state = (VALUE)st;
}

static inline void THROW_DATA_CONSUMED_SET(struct vm_throw_data *obj) {
  if ((((RUBY_T_IMEMO) == RUBY_T_FIXNUM)
           ? (((int)(long)((VALUE)(obj))) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_IMEMO) == RUBY_T_TRUE)
                 ? (((VALUE)(obj)) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_IMEMO) == RUBY_T_FALSE)
                       ? (((VALUE)(obj)) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_IMEMO) == RUBY_T_NIL)
                             ? (((VALUE)(obj)) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_IMEMO) == RUBY_T_UNDEF)
                                   ? (((VALUE)(obj)) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_IMEMO) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)((VALUE)(obj)) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)((VALUE)(obj)) &
                                                RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)((VALUE)(obj)) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)((VALUE)(
                                                        obj)))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_IMEMO) == RUBY_T_FLOAT)
                                               ? (((((int)(long)((VALUE)(
                                                        obj))) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)((VALUE)(obj)) &
                                                      RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)((VALUE)(obj)) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)((
                                                              VALUE)(obj)))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)((VALUE)(obj)) &
                                                     RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)((VALUE)(obj)) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)((
                                                             VALUE)(obj)))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_IMEMO))) &&
      THROW_DATA_STATE(obj) == RUBY_TAG_BREAK) {
    obj->flags |= ((VALUE)RUBY_FL_USER4);
  }
}
# 311 "vm.c" 2
# 1 "./vm_exec.h" 1
# 15 "./vm_exec.h"
typedef long OFFSET;
typedef unsigned long lindex_t;
typedef VALUE GENTRY;
typedef rb_iseq_t *ISEQ;
# 312 "vm.c" 2
# 1 "./vm_insnhelper.c" 1
# 12 "./vm_insnhelper.c"
# 1 "./insns.inc" 1
# 42 "./insns.inc"
enum ruby_vminsn_type {
  YARVINSN_nop,
  YARVINSN_getlocal,
  YARVINSN_setlocal,
  YARVINSN_getblockparam,
  YARVINSN_setblockparam,
  YARVINSN_getblockparamproxy,
  YARVINSN_getspecial,
  YARVINSN_setspecial,
  YARVINSN_getinstancevariable,
  YARVINSN_setinstancevariable,
  YARVINSN_getclassvariable,
  YARVINSN_setclassvariable,
  YARVINSN_getconstant,
  YARVINSN_setconstant,
  YARVINSN_getglobal,
  YARVINSN_setglobal,
  YARVINSN_putnil,
  YARVINSN_putself,
  YARVINSN_putobject,
  YARVINSN_putspecialobject,
  YARVINSN_putiseq,
  YARVINSN_putstring,
  YARVINSN_concatstrings,
  YARVINSN_tostring,
  YARVINSN_freezestring,
  YARVINSN_toregexp,
  YARVINSN_intern,
  YARVINSN_newarray,
  YARVINSN_duparray,
  YARVINSN_expandarray,
  YARVINSN_concatarray,
  YARVINSN_splatarray,
  YARVINSN_newhash,
  YARVINSN_newhashfromarray,
  YARVINSN_newrange,
  YARVINSN_pop,
  YARVINSN_dup,
  YARVINSN_dupn,
  YARVINSN_swap,
  YARVINSN_reverse,
  YARVINSN_reput,
  YARVINSN_topn,
  YARVINSN_setn,
  YARVINSN_adjuststack,
  YARVINSN_defined,
  YARVINSN_checkmatch,
  YARVINSN_checkkeyword,
  YARVINSN_checktype,
  YARVINSN_defineclass,
  YARVINSN_send,
  YARVINSN_opt_send_without_block,
  YARVINSN_opt_str_freeze,
  YARVINSN_opt_str_uminus,
  YARVINSN_opt_newarray_max,
  YARVINSN_opt_newarray_min,
  YARVINSN_invokesuper,
  YARVINSN_invokeblock,
  YARVINSN_leave,
  YARVINSN_throw,
  YARVINSN_jump,
  YARVINSN_branchif,
  YARVINSN_branchunless,
  YARVINSN_branchnil,
  YARVINSN_opt_getinlinecache,
  YARVINSN_opt_setinlinecache,
  YARVINSN_once,
  YARVINSN_opt_case_dispatch,
  YARVINSN_opt_plus,
  YARVINSN_opt_minus,
  YARVINSN_opt_mult,
  YARVINSN_opt_div,
  YARVINSN_opt_mod,
  YARVINSN_opt_eq,
  YARVINSN_opt_neq,
  YARVINSN_opt_lt,
  YARVINSN_opt_le,
  YARVINSN_opt_gt,
  YARVINSN_opt_ge,
  YARVINSN_opt_ltlt,
  YARVINSN_opt_and,
  YARVINSN_opt_or,
  YARVINSN_opt_aref,
  YARVINSN_opt_aset,
  YARVINSN_opt_aset_with,
  YARVINSN_opt_aref_with,
  YARVINSN_opt_length,
  YARVINSN_opt_size,
  YARVINSN_opt_empty_p,
  YARVINSN_opt_succ,
  YARVINSN_opt_not,
  YARVINSN_opt_regexpmatch1,
  YARVINSN_opt_regexpmatch2,
  YARVINSN_opt_call_c_function,
  YARVINSN_bitblt,
  YARVINSN_answer,
  YARVINSN_getlocal_WC_0,
  YARVINSN_getlocal_WC_1,
  YARVINSN_setlocal_WC_0,
  YARVINSN_setlocal_WC_1,
  YARVINSN_putobject_INT2FIX_0_,
  YARVINSN_putobject_INT2FIX_1_,
  YARVINSN_trace_nop,
  YARVINSN_trace_getlocal,
  YARVINSN_trace_setlocal,
  YARVINSN_trace_getblockparam,
  YARVINSN_trace_setblockparam,
  YARVINSN_trace_getblockparamproxy,
  YARVINSN_trace_getspecial,
  YARVINSN_trace_setspecial,
  YARVINSN_trace_getinstancevariable,
  YARVINSN_trace_setinstancevariable,
  YARVINSN_trace_getclassvariable,
  YARVINSN_trace_setclassvariable,
  YARVINSN_trace_getconstant,
  YARVINSN_trace_setconstant,
  YARVINSN_trace_getglobal,
  YARVINSN_trace_setglobal,
  YARVINSN_trace_putnil,
  YARVINSN_trace_putself,
  YARVINSN_trace_putobject,
  YARVINSN_trace_putspecialobject,
  YARVINSN_trace_putiseq,
  YARVINSN_trace_putstring,
  YARVINSN_trace_concatstrings,
  YARVINSN_trace_tostring,
  YARVINSN_trace_freezestring,
  YARVINSN_trace_toregexp,
  YARVINSN_trace_intern,
  YARVINSN_trace_newarray,
  YARVINSN_trace_duparray,
  YARVINSN_trace_expandarray,
  YARVINSN_trace_concatarray,
  YARVINSN_trace_splatarray,
  YARVINSN_trace_newhash,
  YARVINSN_trace_newhashfromarray,
  YARVINSN_trace_newrange,
  YARVINSN_trace_pop,
  YARVINSN_trace_dup,
  YARVINSN_trace_dupn,
  YARVINSN_trace_swap,
  YARVINSN_trace_reverse,
  YARVINSN_trace_reput,
  YARVINSN_trace_topn,
  YARVINSN_trace_setn,
  YARVINSN_trace_adjuststack,
  YARVINSN_trace_defined,
  YARVINSN_trace_checkmatch,
  YARVINSN_trace_checkkeyword,
  YARVINSN_trace_checktype,
  YARVINSN_trace_defineclass,
  YARVINSN_trace_send,
  YARVINSN_trace_opt_send_without_block,
  YARVINSN_trace_opt_str_freeze,
  YARVINSN_trace_opt_str_uminus,
  YARVINSN_trace_opt_newarray_max,
  YARVINSN_trace_opt_newarray_min,
  YARVINSN_trace_invokesuper,
  YARVINSN_trace_invokeblock,
  YARVINSN_trace_leave,
  YARVINSN_trace_throw,
  YARVINSN_trace_jump,
  YARVINSN_trace_branchif,
  YARVINSN_trace_branchunless,
  YARVINSN_trace_branchnil,
  YARVINSN_trace_opt_getinlinecache,
  YARVINSN_trace_opt_setinlinecache,
  YARVINSN_trace_once,
  YARVINSN_trace_opt_case_dispatch,
  YARVINSN_trace_opt_plus,
  YARVINSN_trace_opt_minus,
  YARVINSN_trace_opt_mult,
  YARVINSN_trace_opt_div,
  YARVINSN_trace_opt_mod,
  YARVINSN_trace_opt_eq,
  YARVINSN_trace_opt_neq,
  YARVINSN_trace_opt_lt,
  YARVINSN_trace_opt_le,
  YARVINSN_trace_opt_gt,
  YARVINSN_trace_opt_ge,
  YARVINSN_trace_opt_ltlt,
  YARVINSN_trace_opt_and,
  YARVINSN_trace_opt_or,
  YARVINSN_trace_opt_aref,
  YARVINSN_trace_opt_aset,
  YARVINSN_trace_opt_aset_with,
  YARVINSN_trace_opt_aref_with,
  YARVINSN_trace_opt_length,
  YARVINSN_trace_opt_size,
  YARVINSN_trace_opt_empty_p,
  YARVINSN_trace_opt_succ,
  YARVINSN_trace_opt_not,
  YARVINSN_trace_opt_regexpmatch1,
  YARVINSN_trace_opt_regexpmatch2,
  YARVINSN_trace_opt_call_c_function,
  YARVINSN_trace_bitblt,
  YARVINSN_trace_answer,
  YARVINSN_trace_getlocal_WC_0,
  YARVINSN_trace_getlocal_WC_1,
  YARVINSN_trace_setlocal_WC_0,
  YARVINSN_trace_setlocal_WC_1,
  YARVINSN_trace_putobject_INT2FIX_0_,
  YARVINSN_trace_putobject_INT2FIX_1_,
  VM_INSTRUCTION_SIZE
};
# 13 "./vm_insnhelper.c" 2

# 1 "./insns_info.inc" 1
# 39 "./insns_info.inc"
enum ruby_insn_type_chars {
  TS_VARIABLE = '.',
  TS_CALLCACHE = 'E',
  TS_CALLINFO = 'C',
  TS_CDHASH = 'H',
  TS_GENTRY = 'G',
  TS_IC = 'K',
  TS_ID = 'I',
  TS_ISE = 'T',
  TS_ISEQ = 'S',
  TS_OFFSET = 'O',
  TS_VALUE = 'V',
  TS_LINDEX = 'L',
  TS_FUNCPTR = 'F',
  TS_NUM = 'N'
};

__attribute__((__const__)) __attribute__((__unused__)) static const char *
insn_name(VALUE insn);
extern const char *rb_vm_insn_name_info;
#pragma GCC visibility push(default)
extern const unsigned short rb_vm_insn_name_offset[];
#pragma GCC visibility pop
# 263 "./insns_info.inc"
const char *insn_name(VALUE i) {
  return &rb_vm_insn_name_info[rb_vm_insn_name_offset[i]];
}

__attribute__((__const__)) __attribute__((__unused__)) static int
insn_len(VALUE insn);
extern const char rb_vm_insn_len_info[];
# 286 "./insns_info.inc"
int insn_len(VALUE i) { return rb_vm_insn_len_info[i]; }

__attribute__((__const__)) __attribute__((__unused__)) static const char *
insn_op_types(VALUE insn);
__attribute__((__const__)) __attribute__((__unused__)) static int
insn_op_type(VALUE insn, long pos);
extern const char *rb_vm_insn_op_info;
extern const unsigned short rb_vm_insn_op_offset[];
# 420 "./insns_info.inc"
const char *insn_op_types(VALUE i) {
  return &rb_vm_insn_op_info[rb_vm_insn_op_offset[i]];
}

int insn_op_type(VALUE i, long j) {
  if (j >= insn_len(i)) {
    return 0;
  } else {
    return insn_op_types(i)[j];
  }
}

static _Bool leafness_of_getglobal(VALUE gentry) {
  const struct rb_global_entry *e = (void *)gentry;

  if ((__builtin_expect(!!(rb_gvar_is_traced(e)), 0))) {
    return 0;
  } else {

    static rb_gvar_getter_t *const allowlist[] = {
        rb_gvar_val_getter,
        rb_gvar_var_getter,
        rb_gvar_undef_getter,
    };
    rb_gvar_getter_t *f = rb_gvar_getter_function_of(e);
    int i;

    for (i = 0; i < ((int)(sizeof(allowlist) / sizeof((allowlist)[0]))); i++) {
      if (f == allowlist[i]) {
        return 1;
      }
    }
    return 0;
  }
}

static _Bool leafness_of_setglobal(VALUE gentry) {
  const struct rb_global_entry *e = (void *)gentry;

  if ((__builtin_expect(!!(rb_gvar_is_traced(e)), 0))) {
    return 0;
  } else {

    static rb_gvar_setter_t *const allowlist[] = {
        rb_gvar_val_setter,
        rb_gvar_readonly_setter,
        rb_gvar_var_setter,
        rb_gvar_undef_setter,
    };
    rb_gvar_setter_t *f = rb_gvar_setter_function_of(e);
    int i;

    for (i = 0; i < ((int)(sizeof(allowlist) / sizeof((allowlist)[0]))); i++) {
      if (f == allowlist[i]) {
        return 1;
      }
    }
    return 0;
  }
}

static _Bool leafness_of_defined(rb_num_t op_type) {

  switch (op_type) {
  case DEFINED_IVAR:
  case DEFINED_IVAR2:
  case DEFINED_GVAR:
  case DEFINED_CVAR:
  case DEFINED_YIELD:
  case DEFINED_REF:
  case DEFINED_ZSUPER:
    return 0;
  case DEFINED_CONST:

    return 0;
  case DEFINED_FUNC:
  case DEFINED_METHOD:

    return 0;
  default:
    rb_bug("unknown operand %ld: blame @shyouhei.", op_type);
  }
}

static _Bool leafness_of_checkmatch(rb_num_t flag) {

  if (flag == VM_CHECKMATCH_TYPE_WHEN) {
    return 1;
  } else {

    return 0;
  }
}
# 543 "./insns_info.inc"
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_nop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_nop(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setlocal(lindex_t idx, rb_num_t level);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setblockparam(lindex_t idx, rb_num_t level);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getblockparamproxy(lindex_t idx, rb_num_t level);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getspecial(rb_num_t key, rb_num_t type);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setspecial(rb_num_t key);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setspecial(rb_num_t key);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getinstancevariable(ID id, IC ic);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setinstancevariable(ID id, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setinstancevariable(ID id, IC ic);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getclassvariable(ID id);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setclassvariable(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setclassvariable(ID id);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getconstant(ID id);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setconstant(ID id);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setconstant(ID id);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getglobal(GENTRY entry);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setglobal(GENTRY entry);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setglobal(GENTRY entry);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putnil(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putnil(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putself(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putself(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putobject(VALUE val);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putobject(VALUE val);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putspecialobject(rb_num_t value_type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putspecialobject(rb_num_t value_type);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putiseq(ISEQ iseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putiseq(ISEQ iseq);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putstring(VALUE str);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putstring(VALUE str);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_concatstrings(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_concatstrings(rb_num_t num);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_tostring(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_tostring(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_freezestring(VALUE debug_info);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_freezestring(VALUE debug_info);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_toregexp(rb_num_t opt, rb_num_t cnt);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_intern(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_intern(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_newarray(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_newarray(rb_num_t num);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_duparray(VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_duparray(VALUE ary);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_expandarray(rb_num_t num, rb_num_t flag);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_concatarray(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_concatarray(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_splatarray(VALUE flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_splatarray(VALUE flag);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_newhash(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_newhash(rb_num_t num);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_newhashfromarray(rb_num_t num, VALUE ary);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_newrange(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_newrange(rb_num_t flag);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_pop(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_pop(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_dup(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_dup(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_dupn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_dupn(rb_num_t n);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_swap(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_swap(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_reverse(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_reverse(rb_num_t n);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_reput(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_reput(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_topn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_topn(rb_num_t n);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setn(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setn(rb_num_t n);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_adjuststack(rb_num_t n);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_adjuststack(rb_num_t n);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_defined(rb_num_t op_type, VALUE obj, VALUE needstr);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_checkmatch(rb_num_t flag);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_checkmatch(rb_num_t flag);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_checkkeyword(lindex_t kw_bits_index, lindex_t keyword_index);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_checktype(rb_num_t type);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_checktype(rb_num_t type);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_defineclass(ID id, ISEQ class_iseq, rb_num_t flags);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_send(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_send_without_block(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_str_freeze(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_str_uminus(VALUE str, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_newarray_max(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_newarray_max(rb_num_t num);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_newarray_min(rb_num_t num);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_newarray_min(rb_num_t num);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_invokesuper(CALL_INFO ci, CALL_CACHE cc, ISEQ blockiseq);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_invokeblock(CALL_INFO ci);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_invokeblock(CALL_INFO ci);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_leave(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_leave(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_throw(rb_num_t throw_state);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_throw(rb_num_t throw_state);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_jump(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_jump(OFFSET dst);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_branchif(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_branchif(OFFSET dst);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_branchunless(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_branchunless(OFFSET dst);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_branchnil(OFFSET dst);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_branchnil(OFFSET dst);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_getinlinecache(OFFSET dst, IC ic);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_setinlinecache(IC ic);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_setinlinecache(IC ic);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_once(ISEQ iseq, ISE ise);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_once(ISEQ iseq, ISE ise);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_case_dispatch(CDHASH hash, OFFSET else_offset);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_plus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_minus(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_mult(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_div(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_mod(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_eq(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                 CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                        CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                  CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                  CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                  CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                  CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                  CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                    CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_neq(CALL_INFO ci_eq, CALL_CACHE cc_eq, CALL_INFO ci,
                   CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_lt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_le(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_gt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_ge(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_ltlt(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_and(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_or(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_aref(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_aset(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_aset_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_aref_with(VALUE key, CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_length(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_size(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_empty_p(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_succ(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_not(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_regexpmatch1(VALUE recv);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_regexpmatch2(CALL_INFO ci, CALL_CACHE cc);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_opt_call_c_function(rb_insn_func_t funcptr);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_bitblt(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_bitblt(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_answer(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_answer(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getlocal_WC_0(lindex_t idx);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_getlocal_WC_1(lindex_t idx);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setlocal_WC_0(lindex_t idx);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_setlocal_WC_1(lindex_t idx);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putobject_INT2FIX_0_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putobject_INT2FIX_0_(void);
__attribute__((__pure__))
__attribute__((__unused__)) static enum ruby_vminsn_type
attr_bin_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_handles_sp_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static _Bool
attr_leaf_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static const char *
attr_name_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_open_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_popn_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_retn_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_snum_t
attr_sp_inc_putobject_INT2FIX_1_(void);
__attribute__((__pure__)) __attribute__((__unused__)) static rb_num_t
attr_width_putobject_INT2FIX_1_(void);

enum ruby_vminsn_type attr_bin_nop(void) { return YARVINSN_nop; }

_Bool attr_handles_sp_nop(void) { return 0; }

_Bool attr_leaf_nop(void) { return 1; }

const char *attr_name_nop(void) { return insn_name(YARVINSN_nop); }

rb_num_t attr_open_nop(void) { return 0; }

rb_num_t attr_popn_nop(void) { return 0; }

rb_num_t attr_retn_nop(void) { return 0; }

rb_snum_t attr_sp_inc_nop(void) { return 0; }

rb_num_t attr_width_nop(void) { return 1; }

enum ruby_vminsn_type attr_bin_getlocal(__attribute__((__unused__))
                                        lindex_t idx,
                                        __attribute__((__unused__))
                                        rb_num_t level) {
  return YARVINSN_getlocal;
}

_Bool attr_handles_sp_getlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

_Bool attr_leaf_getlocal(__attribute__((__unused__)) lindex_t idx,
                         __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

const char *attr_name_getlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return insn_name(YARVINSN_getlocal);
}

rb_num_t attr_open_getlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 2;
}

rb_num_t attr_popn_getlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

rb_num_t attr_retn_getlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

rb_snum_t attr_sp_inc_getlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

rb_num_t attr_width_getlocal(__attribute__((__unused__)) lindex_t idx,
                             __attribute__((__unused__)) rb_num_t level) {
  return 3;
}

enum ruby_vminsn_type attr_bin_setlocal(__attribute__((__unused__))
                                        lindex_t idx,
                                        __attribute__((__unused__))
                                        rb_num_t level) {
  return YARVINSN_setlocal;
}

_Bool attr_handles_sp_setlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

_Bool attr_leaf_setlocal(__attribute__((__unused__)) lindex_t idx,
                         __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

const char *attr_name_setlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return insn_name(YARVINSN_setlocal);
}

rb_num_t attr_open_setlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 2;
}

rb_num_t attr_popn_setlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

rb_num_t attr_retn_setlocal(__attribute__((__unused__)) lindex_t idx,
                            __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

rb_snum_t attr_sp_inc_setlocal(__attribute__((__unused__)) lindex_t idx,
                               __attribute__((__unused__)) rb_num_t level) {
  return -1;
}

rb_num_t attr_width_setlocal(__attribute__((__unused__)) lindex_t idx,
                             __attribute__((__unused__)) rb_num_t level) {
  return 3;
}

enum ruby_vminsn_type attr_bin_getblockparam(__attribute__((__unused__))
                                             lindex_t idx,
                                             __attribute__((__unused__))
                                             rb_num_t level) {
  return YARVINSN_getblockparam;
}

_Bool attr_handles_sp_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return 0;
}

_Bool attr_leaf_getblockparam(__attribute__((__unused__)) lindex_t idx,
                              __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

const char *attr_name_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return insn_name(YARVINSN_getblockparam);
}

rb_num_t attr_open_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 2;
}

rb_num_t attr_popn_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

rb_num_t attr_retn_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

rb_snum_t attr_sp_inc_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return 1;
}

rb_num_t attr_width_getblockparam(__attribute__((__unused__)) lindex_t idx,
                                  __attribute__((__unused__)) rb_num_t level) {
  return 3;
}

enum ruby_vminsn_type attr_bin_setblockparam(__attribute__((__unused__))
                                             lindex_t idx,
                                             __attribute__((__unused__))
                                             rb_num_t level) {
  return YARVINSN_setblockparam;
}

_Bool attr_handles_sp_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return 0;
}

_Bool attr_leaf_setblockparam(__attribute__((__unused__)) lindex_t idx,
                              __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

const char *attr_name_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return insn_name(YARVINSN_setblockparam);
}

rb_num_t attr_open_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 2;
}

rb_num_t attr_popn_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

rb_num_t attr_retn_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                 __attribute__((__unused__)) rb_num_t level) {
  return 0;
}

rb_snum_t attr_sp_inc_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                    __attribute__((__unused__))
                                    rb_num_t level) {
  return -1;
}

rb_num_t attr_width_setblockparam(__attribute__((__unused__)) lindex_t idx,
                                  __attribute__((__unused__)) rb_num_t level) {
  return 3;
}

enum ruby_vminsn_type attr_bin_getblockparamproxy(__attribute__((__unused__))
                                                  lindex_t idx,
                                                  __attribute__((__unused__))
                                                  rb_num_t level) {
  return YARVINSN_getblockparamproxy;
}

_Bool attr_handles_sp_getblockparamproxy(__attribute__((__unused__))
                                         lindex_t idx,
                                         __attribute__((__unused__))
                                         rb_num_t level) {
  return 0;
}

_Bool attr_leaf_getblockparamproxy(__attribute__((__unused__)) lindex_t idx,
                                   __attribute__((__unused__)) rb_num_t level) {
  return 1;
}

const char *attr_name_getblockparamproxy(__attribute__((__unused__))
                                         lindex_t idx,
                                         __attribute__((__unused__))
                                         rb_num_t level) {
  return insn_name(YARVINSN_getblockparamproxy);
}

rb_num_t attr_open_getblockparamproxy(__attribute__((__unused__)) lindex_t idx,
                                      __attribute__((__unused__))
                                      rb_num_t level) {
  return 2;
}

rb_num_t attr_popn_getblockparamproxy(__attribute__((__unused__)) lindex_t idx,
                                      __attribute__((__unused__))
                                      rb_num_t level) {
  return 0;
}

rb_num_t attr_retn_getblockparamproxy(__attribute__((__unused__)) lindex_t idx,
                                      __attribute__((__unused__))
                                      rb_num_t level) {
  return 1;
}

rb_snum_t attr_sp_inc_getblockparamproxy(__attribute__((__unused__))
                                         lindex_t idx,
                                         __attribute__((__unused__))
                                         rb_num_t level) {
  return 1;
}

rb_num_t attr_width_getblockparamproxy(__attribute__((__unused__)) lindex_t idx,
                                       __attribute__((__unused__))
                                       rb_num_t level) {
  return 3;
}

enum ruby_vminsn_type attr_bin_getspecial(__attribute__((__unused__))
                                          rb_num_t key,
                                          __attribute__((__unused__))
                                          rb_num_t type) {
  return YARVINSN_getspecial;
}

_Bool attr_handles_sp_getspecial(__attribute__((__unused__)) rb_num_t key,
                                 __attribute__((__unused__)) rb_num_t type) {
  return 0;
}

_Bool attr_leaf_getspecial(__attribute__((__unused__)) rb_num_t key,
                           __attribute__((__unused__)) rb_num_t type) {
  return 1;
}

const char *attr_name_getspecial(__attribute__((__unused__)) rb_num_t key,
                                 __attribute__((__unused__)) rb_num_t type) {
  return insn_name(YARVINSN_getspecial);
}

rb_num_t attr_open_getspecial(__attribute__((__unused__)) rb_num_t key,
                              __attribute__((__unused__)) rb_num_t type) {
  return 2;
}

rb_num_t attr_popn_getspecial(__attribute__((__unused__)) rb_num_t key,
                              __attribute__((__unused__)) rb_num_t type) {
  return 0;
}

rb_num_t attr_retn_getspecial(__attribute__((__unused__)) rb_num_t key,
                              __attribute__((__unused__)) rb_num_t type) {
  return 1;
}

rb_snum_t attr_sp_inc_getspecial(__attribute__((__unused__)) rb_num_t key,
                                 __attribute__((__unused__)) rb_num_t type) {
  return 1;
}

rb_num_t attr_width_getspecial(__attribute__((__unused__)) rb_num_t key,
                               __attribute__((__unused__)) rb_num_t type) {
  return 3;
}

enum ruby_vminsn_type attr_bin_setspecial(__attribute__((__unused__))
                                          rb_num_t key) {
  return YARVINSN_setspecial;
}

_Bool attr_handles_sp_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 0;
}

_Bool attr_leaf_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 1;
}

const char *attr_name_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return insn_name(YARVINSN_setspecial);
}

rb_num_t attr_open_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 1;
}

rb_num_t attr_popn_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 1;
}

rb_num_t attr_retn_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 0;
}

rb_snum_t attr_sp_inc_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return -1;
}

rb_num_t attr_width_setspecial(__attribute__((__unused__)) rb_num_t key) {
  return 2;
}

enum ruby_vminsn_type attr_bin_getinstancevariable(__attribute__((__unused__))
                                                   ID id,
                                                   __attribute__((__unused__))
                                                   IC ic) {
  return YARVINSN_getinstancevariable;
}

_Bool attr_handles_sp_getinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return 0;
}

_Bool attr_leaf_getinstancevariable(__attribute__((__unused__)) ID id,
                                    __attribute__((__unused__)) IC ic) {
  return
# 212 "insns.def"
      0;
# 2150 "insns_info.inc"
}

const char *attr_name_getinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return insn_name(YARVINSN_getinstancevariable);
}

rb_num_t attr_open_getinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 2;
}

rb_num_t attr_popn_getinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 0;
}

rb_num_t attr_retn_getinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 1;
}

rb_snum_t attr_sp_inc_getinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return 1;
}

rb_num_t attr_width_getinstancevariable(__attribute__((__unused__)) ID id,
                                        __attribute__((__unused__)) IC ic) {
  return 3;
}

enum ruby_vminsn_type attr_bin_setinstancevariable(__attribute__((__unused__))
                                                   ID id,
                                                   __attribute__((__unused__))
                                                   IC ic) {
  return YARVINSN_setinstancevariable;
}

_Bool attr_handles_sp_setinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return 0;
}

_Bool attr_leaf_setinstancevariable(__attribute__((__unused__)) ID id,
                                    __attribute__((__unused__)) IC ic) {
  return 1;
}

const char *attr_name_setinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return insn_name(YARVINSN_setinstancevariable);
}

rb_num_t attr_open_setinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 2;
}

rb_num_t attr_popn_setinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 1;
}

rb_num_t attr_retn_setinstancevariable(__attribute__((__unused__)) ID id,
                                       __attribute__((__unused__)) IC ic) {
  return 0;
}

rb_snum_t attr_sp_inc_setinstancevariable(__attribute__((__unused__)) ID id,
                                          __attribute__((__unused__)) IC ic) {
  return -1;
}

rb_num_t attr_width_setinstancevariable(__attribute__((__unused__)) ID id,
                                        __attribute__((__unused__)) IC ic) {
  return 3;
}

enum ruby_vminsn_type attr_bin_getclassvariable(__attribute__((__unused__))
                                                ID id) {
  return YARVINSN_getclassvariable;
}

_Bool attr_handles_sp_getclassvariable(__attribute__((__unused__)) ID id) {
  return 0;
}

_Bool attr_leaf_getclassvariable(__attribute__((__unused__)) ID id) {
  return
# 234 "insns.def"
      0;
# 2324 "insns_info.inc"
}

const char *attr_name_getclassvariable(__attribute__((__unused__)) ID id) {
  return insn_name(YARVINSN_getclassvariable);
}

rb_num_t attr_open_getclassvariable(__attribute__((__unused__)) ID id) {
  return 1;
}

rb_num_t attr_popn_getclassvariable(__attribute__((__unused__)) ID id) {
  return 0;
}

rb_num_t attr_retn_getclassvariable(__attribute__((__unused__)) ID id) {
  return 1;
}

rb_snum_t attr_sp_inc_getclassvariable(__attribute__((__unused__)) ID id) {
  return 1;
}

rb_num_t attr_width_getclassvariable(__attribute__((__unused__)) ID id) {
  return 2;
}

enum ruby_vminsn_type attr_bin_setclassvariable(__attribute__((__unused__))
                                                ID id) {
  return YARVINSN_setclassvariable;
}

_Bool attr_handles_sp_setclassvariable(__attribute__((__unused__)) ID id) {
  return 0;
}

_Bool attr_leaf_setclassvariable(__attribute__((__unused__)) ID id) {
  return
# 246 "insns.def"
      0;
# 2390 "insns_info.inc"
}

const char *attr_name_setclassvariable(__attribute__((__unused__)) ID id) {
  return insn_name(YARVINSN_setclassvariable);
}

rb_num_t attr_open_setclassvariable(__attribute__((__unused__)) ID id) {
  return 1;
}

rb_num_t attr_popn_setclassvariable(__attribute__((__unused__)) ID id) {
  return 1;
}

rb_num_t attr_retn_setclassvariable(__attribute__((__unused__)) ID id) {
  return 0;
}

rb_snum_t attr_sp_inc_setclassvariable(__attribute__((__unused__)) ID id) {
  return -1;
}

rb_num_t attr_width_setclassvariable(__attribute__((__unused__)) ID id) {
  return 2;
}

enum ruby_vminsn_type attr_bin_getconstant(__attribute__((__unused__)) ID id) {
  return YARVINSN_getconstant;
}

_Bool attr_handles_sp_getconstant(__attribute__((__unused__)) ID id) {
  return 0;
}

_Bool attr_leaf_getconstant(__attribute__((__unused__)) ID id) {
  return
# 262 "insns.def"
      0;
# 2456 "insns_info.inc"
}

const char *attr_name_getconstant(__attribute__((__unused__)) ID id) {
  return insn_name(YARVINSN_getconstant);
}

rb_num_t attr_open_getconstant(__attribute__((__unused__)) ID id) { return 1; }

rb_num_t attr_popn_getconstant(__attribute__((__unused__)) ID id) { return 1; }

rb_num_t attr_retn_getconstant(__attribute__((__unused__)) ID id) { return 1; }

rb_snum_t attr_sp_inc_getconstant(__attribute__((__unused__)) ID id) {
  return 0;
}

rb_num_t attr_width_getconstant(__attribute__((__unused__)) ID id) { return 2; }

enum ruby_vminsn_type attr_bin_setconstant(__attribute__((__unused__)) ID id) {
  return YARVINSN_setconstant;
}

_Bool attr_handles_sp_setconstant(__attribute__((__unused__)) ID id) {
  return 0;
}

_Bool attr_leaf_setconstant(__attribute__((__unused__)) ID id) {
  return
# 278 "insns.def"
      0;
# 2522 "insns_info.inc"
}

const char *attr_name_setconstant(__attribute__((__unused__)) ID id) {
  return insn_name(YARVINSN_setconstant);
}

rb_num_t attr_open_setconstant(__attribute__((__unused__)) ID id) { return 1; }

rb_num_t attr_popn_setconstant(__attribute__((__unused__)) ID id) { return 2; }

rb_num_t attr_retn_setconstant(__attribute__((__unused__)) ID id) { return 0; }

rb_snum_t attr_sp_inc_setconstant(__attribute__((__unused__)) ID id) {
  return -2;
}

rb_num_t attr_width_setconstant(__attribute__((__unused__)) ID id) { return 2; }

enum ruby_vminsn_type attr_bin_getglobal(__attribute__((__unused__))
                                         GENTRY entry) {
  return YARVINSN_getglobal;
}

_Bool attr_handles_sp_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 0;
}

_Bool attr_leaf_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return
# 291 "insns.def"
      leafness_of_getglobal(entry);
# 2588 "insns_info.inc"
}

const char *attr_name_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return insn_name(YARVINSN_getglobal);
}

rb_num_t attr_open_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 1;
}

rb_num_t attr_popn_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 0;
}

rb_num_t attr_retn_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 1;
}

rb_snum_t attr_sp_inc_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 1;
}

rb_num_t attr_width_getglobal(__attribute__((__unused__)) GENTRY entry) {
  return 2;
}

enum ruby_vminsn_type attr_bin_setglobal(__attribute__((__unused__))
                                         GENTRY entry) {
  return YARVINSN_setglobal;
}

_Bool attr_handles_sp_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return 0;
}

_Bool attr_leaf_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return
# 302 "insns.def"
      leafness_of_setglobal(entry);
# 2654 "insns_info.inc"
}

const char *attr_name_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return insn_name(YARVINSN_setglobal);
}

rb_num_t attr_open_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return 1;
}

rb_num_t attr_popn_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return 1;
}

rb_num_t attr_retn_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return 0;
}

rb_snum_t attr_sp_inc_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return -1;
}

rb_num_t attr_width_setglobal(__attribute__((__unused__)) GENTRY entry) {
  return 2;
}

enum ruby_vminsn_type attr_bin_putnil(void) { return YARVINSN_putnil; }

_Bool attr_handles_sp_putnil(void) { return 0; }

_Bool attr_leaf_putnil(void) { return 1; }

const char *attr_name_putnil(void) { return insn_name(YARVINSN_putnil); }

rb_num_t attr_open_putnil(void) { return 0; }

rb_num_t attr_popn_putnil(void) { return 0; }

rb_num_t attr_retn_putnil(void) { return 1; }

rb_snum_t attr_sp_inc_putnil(void) { return 1; }

rb_num_t attr_width_putnil(void) { return 1; }

enum ruby_vminsn_type attr_bin_putself(void) { return YARVINSN_putself; }

_Bool attr_handles_sp_putself(void) { return 0; }

_Bool attr_leaf_putself(void) { return 1; }

const char *attr_name_putself(void) { return insn_name(YARVINSN_putself); }

rb_num_t attr_open_putself(void) { return 0; }

rb_num_t attr_popn_putself(void) { return 0; }

rb_num_t attr_retn_putself(void) { return 1; }

rb_snum_t attr_sp_inc_putself(void) { return 1; }

rb_num_t attr_width_putself(void) { return 1; }

enum ruby_vminsn_type attr_bin_putobject(__attribute__((__unused__))
                                         VALUE val) {
  return YARVINSN_putobject;
}

_Bool attr_handles_sp_putobject(__attribute__((__unused__)) VALUE val) {
  return 0;
}

_Bool attr_leaf_putobject(__attribute__((__unused__)) VALUE val) { return 1; }

const char *attr_name_putobject(__attribute__((__unused__)) VALUE val) {
  return insn_name(YARVINSN_putobject);
}

rb_num_t attr_open_putobject(__attribute__((__unused__)) VALUE val) {
  return 1;
}

rb_num_t attr_popn_putobject(__attribute__((__unused__)) VALUE val) {
  return 0;
}

rb_num_t attr_retn_putobject(__attribute__((__unused__)) VALUE val) {
  return 1;
}

rb_snum_t attr_sp_inc_putobject(__attribute__((__unused__)) VALUE val) {
  return 1;
}

rb_num_t attr_width_putobject(__attribute__((__unused__)) VALUE val) {
  return 2;
}

enum ruby_vminsn_type attr_bin_putspecialobject(__attribute__((__unused__))
                                                rb_num_t value_type) {
  return YARVINSN_putspecialobject;
}

_Bool attr_handles_sp_putspecialobject(__attribute__((__unused__))
                                       rb_num_t value_type) {
  return 0;
}

_Bool attr_leaf_putspecialobject(__attribute__((__unused__))
                                 rb_num_t value_type) {
  return 1;
}

const char *attr_name_putspecialobject(__attribute__((__unused__))
                                       rb_num_t value_type) {
  return insn_name(YARVINSN_putspecialobject);
}

rb_num_t attr_open_putspecialobject(__attribute__((__unused__))
                                    rb_num_t value_type) {
  return 1;
}

rb_num_t attr_popn_putspecialobject(__attribute__((__unused__))
                                    rb_num_t value_type) {
  return 0;
}

rb_num_t attr_retn_putspecialobject(__attribute__((__unused__))
                                    rb_num_t value_type) {
  return 1;
}

rb_snum_t attr_sp_inc_putspecialobject(__attribute__((__unused__))
                                       rb_num_t value_type) {
  return 1;
}

rb_num_t attr_width_putspecialobject(__attribute__((__unused__))
                                     rb_num_t value_type) {
  return 2;
}

enum ruby_vminsn_type attr_bin_putiseq(__attribute__((__unused__)) ISEQ iseq) {
  return YARVINSN_putiseq;
}

_Bool attr_handles_sp_putiseq(__attribute__((__unused__)) ISEQ iseq) {
  return
# 362 "insns.def"
      0;
# 2965 "insns_info.inc"
}

_Bool attr_leaf_putiseq(__attribute__((__unused__)) ISEQ iseq) { return 1; }

const char *attr_name_putiseq(__attribute__((__unused__)) ISEQ iseq) {
  return insn_name(YARVINSN_putiseq);
}

rb_num_t attr_open_putiseq(__attribute__((__unused__)) ISEQ iseq) { return 1; }

rb_num_t attr_popn_putiseq(__attribute__((__unused__)) ISEQ iseq) { return 0; }

rb_num_t attr_retn_putiseq(__attribute__((__unused__)) ISEQ iseq) { return 1; }

rb_snum_t attr_sp_inc_putiseq(__attribute__((__unused__)) ISEQ iseq) {
  return 1;
}

rb_num_t attr_width_putiseq(__attribute__((__unused__)) ISEQ iseq) { return 2; }

enum ruby_vminsn_type attr_bin_putstring(__attribute__((__unused__))
                                         VALUE str) {
  return YARVINSN_putstring;
}

_Bool attr_handles_sp_putstring(__attribute__((__unused__)) VALUE str) {
  return 0;
}

_Bool attr_leaf_putstring(__attribute__((__unused__)) VALUE str) { return 1; }

const char *attr_name_putstring(__attribute__((__unused__)) VALUE str) {
  return insn_name(YARVINSN_putstring);
}

rb_num_t attr_open_putstring(__attribute__((__unused__)) VALUE str) {
  return 1;
}

rb_num_t attr_popn_putstring(__attribute__((__unused__)) VALUE str) {
  return 0;
}

rb_num_t attr_retn_putstring(__attribute__((__unused__)) VALUE str) {
  return 1;
}

rb_snum_t attr_sp_inc_putstring(__attribute__((__unused__)) VALUE str) {
  return 1;
}

rb_num_t attr_width_putstring(__attribute__((__unused__)) VALUE str) {
  return 2;
}

enum ruby_vminsn_type attr_bin_concatstrings(__attribute__((__unused__))
                                             rb_num_t num) {
  return YARVINSN_concatstrings;
}

_Bool attr_handles_sp_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

_Bool attr_leaf_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

const char *attr_name_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return insn_name(YARVINSN_concatstrings);
}

rb_num_t attr_open_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_num_t attr_popn_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

rb_num_t attr_retn_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_snum_t attr_sp_inc_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return
# 383 "insns.def"
      1 - (rb_snum_t)num;
# 3136 "insns_info.inc"
}

rb_num_t attr_width_concatstrings(__attribute__((__unused__)) rb_num_t num) {
  return 2;
}

enum ruby_vminsn_type attr_bin_tostring(void) { return YARVINSN_tostring; }

_Bool attr_handles_sp_tostring(void) { return 0; }

_Bool attr_leaf_tostring(void) { return 1; }

const char *attr_name_tostring(void) { return insn_name(YARVINSN_tostring); }

rb_num_t attr_open_tostring(void) { return 0; }

rb_num_t attr_popn_tostring(void) { return 2; }

rb_num_t attr_retn_tostring(void) { return 1; }

rb_snum_t attr_sp_inc_tostring(void) { return -1; }

rb_num_t attr_width_tostring(void) { return 1; }

enum ruby_vminsn_type attr_bin_freezestring(__attribute__((__unused__))
                                            VALUE debug_info) {
  return YARVINSN_freezestring;
}

_Bool attr_handles_sp_freezestring(__attribute__((__unused__))
                                   VALUE debug_info) {
  return 0;
}

_Bool attr_leaf_freezestring(__attribute__((__unused__)) VALUE debug_info) {
  return 1;
}

const char *attr_name_freezestring(__attribute__((__unused__))
                                   VALUE debug_info) {
  return insn_name(YARVINSN_freezestring);
}

rb_num_t attr_open_freezestring(__attribute__((__unused__)) VALUE debug_info) {
  return 1;
}

rb_num_t attr_popn_freezestring(__attribute__((__unused__)) VALUE debug_info) {
  return 1;
}

rb_num_t attr_retn_freezestring(__attribute__((__unused__)) VALUE debug_info) {
  return 1;
}

rb_snum_t attr_sp_inc_freezestring(__attribute__((__unused__))
                                   VALUE debug_info) {
  return 0;
}

rb_num_t attr_width_freezestring(__attribute__((__unused__)) VALUE debug_info) {
  return 2;
}

enum ruby_vminsn_type attr_bin_toregexp(__attribute__((__unused__))
                                        rb_num_t opt,
                                        __attribute__((__unused__))
                                        rb_num_t cnt) {
  return YARVINSN_toregexp;
}

_Bool attr_handles_sp_toregexp(__attribute__((__unused__)) rb_num_t opt,
                               __attribute__((__unused__)) rb_num_t cnt) {
  return 0;
}

_Bool attr_leaf_toregexp(__attribute__((__unused__)) rb_num_t opt,
                         __attribute__((__unused__)) rb_num_t cnt) {
  return
# 418 "insns.def"
      1;
# 3302 "insns_info.inc"
}

const char *attr_name_toregexp(__attribute__((__unused__)) rb_num_t opt,
                               __attribute__((__unused__)) rb_num_t cnt) {
  return insn_name(YARVINSN_toregexp);
}

rb_num_t attr_open_toregexp(__attribute__((__unused__)) rb_num_t opt,
                            __attribute__((__unused__)) rb_num_t cnt) {
  return 2;
}

rb_num_t attr_popn_toregexp(__attribute__((__unused__)) rb_num_t opt,
                            __attribute__((__unused__)) rb_num_t cnt) {
  return 0;
}

rb_num_t attr_retn_toregexp(__attribute__((__unused__)) rb_num_t opt,
                            __attribute__((__unused__)) rb_num_t cnt) {
  return 1;
}

rb_snum_t attr_sp_inc_toregexp(__attribute__((__unused__)) rb_num_t opt,
                               __attribute__((__unused__)) rb_num_t cnt) {
  return
# 419 "insns.def"
      1 - (rb_snum_t)cnt;
# 3355 "insns_info.inc"
}

rb_num_t attr_width_toregexp(__attribute__((__unused__)) rb_num_t opt,
                             __attribute__((__unused__)) rb_num_t cnt) {
  return 3;
}

enum ruby_vminsn_type attr_bin_intern(void) { return YARVINSN_intern; }

_Bool attr_handles_sp_intern(void) { return 0; }

_Bool attr_leaf_intern(void) { return 1; }

const char *attr_name_intern(void) { return insn_name(YARVINSN_intern); }

rb_num_t attr_open_intern(void) { return 0; }

rb_num_t attr_popn_intern(void) { return 1; }

rb_num_t attr_retn_intern(void) { return 1; }

rb_snum_t attr_sp_inc_intern(void) { return 0; }

rb_num_t attr_width_intern(void) { return 1; }

enum ruby_vminsn_type attr_bin_newarray(__attribute__((__unused__))
                                        rb_num_t num) {
  return YARVINSN_newarray;
}

_Bool attr_handles_sp_newarray(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

_Bool attr_leaf_newarray(__attribute__((__unused__)) rb_num_t num) { return 1; }

const char *attr_name_newarray(__attribute__((__unused__)) rb_num_t num) {
  return insn_name(YARVINSN_newarray);
}

rb_num_t attr_open_newarray(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_num_t attr_popn_newarray(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

rb_num_t attr_retn_newarray(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_snum_t attr_sp_inc_newarray(__attribute__((__unused__)) rb_num_t num) {
  return
# 442 "insns.def"
      1 - (rb_snum_t)num;
# 3487 "insns_info.inc"
}

rb_num_t attr_width_newarray(__attribute__((__unused__)) rb_num_t num) {
  return 2;
}

enum ruby_vminsn_type attr_bin_duparray(__attribute__((__unused__)) VALUE ary) {
  return YARVINSN_duparray;
}

_Bool attr_handles_sp_duparray(__attribute__((__unused__)) VALUE ary) {
  return 0;
}

_Bool attr_leaf_duparray(__attribute__((__unused__)) VALUE ary) { return 1; }

const char *attr_name_duparray(__attribute__((__unused__)) VALUE ary) {
  return insn_name(YARVINSN_duparray);
}

rb_num_t attr_open_duparray(__attribute__((__unused__)) VALUE ary) { return 1; }

rb_num_t attr_popn_duparray(__attribute__((__unused__)) VALUE ary) { return 0; }

rb_num_t attr_retn_duparray(__attribute__((__unused__)) VALUE ary) { return 1; }

rb_snum_t attr_sp_inc_duparray(__attribute__((__unused__)) VALUE ary) {
  return 1;
}

rb_num_t attr_width_duparray(__attribute__((__unused__)) VALUE ary) {
  return 2;
}

enum ruby_vminsn_type attr_bin_expandarray(__attribute__((__unused__))
                                           rb_num_t num,
                                           __attribute__((__unused__))
                                           rb_num_t flag) {
  return YARVINSN_expandarray;
}

_Bool attr_handles_sp_expandarray(__attribute__((__unused__)) rb_num_t num,
                                  __attribute__((__unused__)) rb_num_t flag) {
  return 0;
}

_Bool attr_leaf_expandarray(__attribute__((__unused__)) rb_num_t num,
                            __attribute__((__unused__)) rb_num_t flag) {
  return
# 471 "insns.def"
      0;
# 3590 "insns_info.inc"
}

const char *attr_name_expandarray(__attribute__((__unused__)) rb_num_t num,
                                  __attribute__((__unused__)) rb_num_t flag) {
  return insn_name(YARVINSN_expandarray);
}

rb_num_t attr_open_expandarray(__attribute__((__unused__)) rb_num_t num,
                               __attribute__((__unused__)) rb_num_t flag) {
  return 2;
}

rb_num_t attr_popn_expandarray(__attribute__((__unused__)) rb_num_t num,
                               __attribute__((__unused__)) rb_num_t flag) {
  return 1;
}

rb_num_t attr_retn_expandarray(__attribute__((__unused__)) rb_num_t num,
                               __attribute__((__unused__)) rb_num_t flag) {
  return 0;
}

rb_snum_t attr_sp_inc_expandarray(__attribute__((__unused__)) rb_num_t num,
                                  __attribute__((__unused__)) rb_num_t flag) {
  return
# 472 "insns.def"
      (rb_snum_t)num - 1 + (flag & 1 ? 1 : 0);
# 3643 "insns_info.inc"
}

rb_num_t attr_width_expandarray(__attribute__((__unused__)) rb_num_t num,
                                __attribute__((__unused__)) rb_num_t flag) {
  return 3;
}

enum ruby_vminsn_type attr_bin_concatarray(void) {
  return YARVINSN_concatarray;
}

_Bool attr_handles_sp_concatarray(void) { return 0; }

_Bool attr_leaf_concatarray(void) {
  return
# 483 "insns.def"
      0;
# 3677 "insns_info.inc"
}

const char *attr_name_concatarray(void) {
  return insn_name(YARVINSN_concatarray);
}

rb_num_t attr_open_concatarray(void) { return 0; }

rb_num_t attr_popn_concatarray(void) { return 2; }

rb_num_t attr_retn_concatarray(void) { return 1; }

rb_snum_t attr_sp_inc_concatarray(void) { return -1; }

rb_num_t attr_width_concatarray(void) { return 1; }

enum ruby_vminsn_type attr_bin_splatarray(__attribute__((__unused__))
                                          VALUE flag) {
  return YARVINSN_splatarray;
}

_Bool attr_handles_sp_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 0;
}

_Bool attr_leaf_splatarray(__attribute__((__unused__)) VALUE flag) {
  return
# 494 "insns.def"
      0;
# 3743 "insns_info.inc"
}

const char *attr_name_splatarray(__attribute__((__unused__)) VALUE flag) {
  return insn_name(YARVINSN_splatarray);
}

rb_num_t attr_open_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 1;
}

rb_num_t attr_popn_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 1;
}

rb_num_t attr_retn_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 1;
}

rb_snum_t attr_sp_inc_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 0;
}

rb_num_t attr_width_splatarray(__attribute__((__unused__)) VALUE flag) {
  return 2;
}

enum ruby_vminsn_type attr_bin_newhash(__attribute__((__unused__))
                                       rb_num_t num) {
  return YARVINSN_newhash;
}

_Bool attr_handles_sp_newhash(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

_Bool attr_leaf_newhash(__attribute__((__unused__)) rb_num_t num) {
  return
# 505 "insns.def"
      0;
# 3809 "insns_info.inc"
}

const char *attr_name_newhash(__attribute__((__unused__)) rb_num_t num) {
  return insn_name(YARVINSN_newhash);
}

rb_num_t attr_open_newhash(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_num_t attr_popn_newhash(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

rb_num_t attr_retn_newhash(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_snum_t attr_sp_inc_newhash(__attribute__((__unused__)) rb_num_t num) {
  return
# 506 "insns.def"
      1 - (rb_snum_t)num;
# 3847 "insns_info.inc"
}

rb_num_t attr_width_newhash(__attribute__((__unused__)) rb_num_t num) {
  return 2;
}

enum ruby_vminsn_type attr_bin_newhashfromarray(__attribute__((__unused__))
                                                rb_num_t num,
                                                __attribute__((__unused__))
                                                VALUE ary) {
  return YARVINSN_newhashfromarray;
}

_Bool attr_handles_sp_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                       __attribute__((__unused__)) VALUE ary) {
  return 0;
}

_Bool attr_leaf_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                 __attribute__((__unused__)) VALUE ary) {
  return
# 523 "insns.def"
      0;
# 3887 "insns_info.inc"
}

const char *attr_name_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                       __attribute__((__unused__)) VALUE ary) {
  return insn_name(YARVINSN_newhashfromarray);
}

rb_num_t attr_open_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                    __attribute__((__unused__)) VALUE ary) {
  return 2;
}

rb_num_t attr_popn_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                    __attribute__((__unused__)) VALUE ary) {
  return 0;
}

rb_num_t attr_retn_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                    __attribute__((__unused__)) VALUE ary) {
  return 1;
}

rb_snum_t attr_sp_inc_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                       __attribute__((__unused__)) VALUE ary) {
  return 1;
}

rb_num_t attr_width_newhashfromarray(__attribute__((__unused__)) rb_num_t num,
                                     __attribute__((__unused__)) VALUE ary) {
  return 3;
}

enum ruby_vminsn_type attr_bin_newrange(__attribute__((__unused__))
                                        rb_num_t flag) {
  return YARVINSN_newrange;
}

_Bool attr_handles_sp_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return 0;
}

_Bool attr_leaf_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return
# 537 "insns.def"
      0;
# 3971 "insns_info.inc"
}

const char *attr_name_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return insn_name(YARVINSN_newrange);
}

rb_num_t attr_open_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return 1;
}

rb_num_t attr_popn_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return 2;
}

rb_num_t attr_retn_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return 1;
}

rb_snum_t attr_sp_inc_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return -1;
}

rb_num_t attr_width_newrange(__attribute__((__unused__)) rb_num_t flag) {
  return 2;
}

enum ruby_vminsn_type attr_bin_pop(void) { return YARVINSN_pop; }

_Bool attr_handles_sp_pop(void) { return 0; }

_Bool attr_leaf_pop(void) { return 1; }

const char *attr_name_pop(void) { return insn_name(YARVINSN_pop); }

rb_num_t attr_open_pop(void) { return 0; }

rb_num_t attr_popn_pop(void) { return 1; }

rb_num_t attr_retn_pop(void) { return 0; }

rb_snum_t attr_sp_inc_pop(void) { return -1; }

rb_num_t attr_width_pop(void) { return 1; }

enum ruby_vminsn_type attr_bin_dup(void) { return YARVINSN_dup; }

_Bool attr_handles_sp_dup(void) { return 0; }

_Bool attr_leaf_dup(void) { return 1; }

const char *attr_name_dup(void) { return insn_name(YARVINSN_dup); }

rb_num_t attr_open_dup(void) { return 0; }

rb_num_t attr_popn_dup(void) { return 1; }

rb_num_t attr_retn_dup(void) { return 2; }

rb_snum_t attr_sp_inc_dup(void) { return 1; }

rb_num_t attr_width_dup(void) { return 1; }

enum ruby_vminsn_type attr_bin_dupn(__attribute__((__unused__)) rb_num_t n) {
  return YARVINSN_dupn;
}

_Bool attr_handles_sp_dupn(__attribute__((__unused__)) rb_num_t n) { return 0; }

_Bool attr_leaf_dupn(__attribute__((__unused__)) rb_num_t n) { return 1; }

const char *attr_name_dupn(__attribute__((__unused__)) rb_num_t n) {
  return insn_name(YARVINSN_dupn);
}

rb_num_t attr_open_dupn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_num_t attr_popn_dupn(__attribute__((__unused__)) rb_num_t n) { return 0; }

rb_num_t attr_retn_dupn(__attribute__((__unused__)) rb_num_t n) { return 0; }

rb_snum_t attr_sp_inc_dupn(__attribute__((__unused__)) rb_num_t n) {
  return
# 573 "insns.def"
      n;
# 4198 "insns_info.inc"
}

rb_num_t attr_width_dupn(__attribute__((__unused__)) rb_num_t n) { return 2; }

enum ruby_vminsn_type attr_bin_swap(void) { return YARVINSN_swap; }

_Bool attr_handles_sp_swap(void) { return 0; }

_Bool attr_leaf_swap(void) { return 1; }

const char *attr_name_swap(void) { return insn_name(YARVINSN_swap); }

rb_num_t attr_open_swap(void) { return 0; }

rb_num_t attr_popn_swap(void) { return 2; }

rb_num_t attr_retn_swap(void) { return 2; }

rb_snum_t attr_sp_inc_swap(void) { return 0; }

rb_num_t attr_width_swap(void) { return 1; }

enum ruby_vminsn_type attr_bin_reverse(__attribute__((__unused__)) rb_num_t n) {
  return YARVINSN_reverse;
}

_Bool attr_handles_sp_reverse(__attribute__((__unused__)) rb_num_t n) {
  return 0;
}

_Bool attr_leaf_reverse(__attribute__((__unused__)) rb_num_t n) { return 1; }

const char *attr_name_reverse(__attribute__((__unused__)) rb_num_t n) {
  return insn_name(YARVINSN_reverse);
}

rb_num_t attr_open_reverse(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_num_t attr_popn_reverse(__attribute__((__unused__)) rb_num_t n) { return 0; }

rb_num_t attr_retn_reverse(__attribute__((__unused__)) rb_num_t n) { return 0; }

rb_snum_t attr_sp_inc_reverse(__attribute__((__unused__)) rb_num_t n) {
  return
# 597 "insns.def"
      0;
# 4327 "insns_info.inc"
}

rb_num_t attr_width_reverse(__attribute__((__unused__)) rb_num_t n) {
  return 2;
}

enum ruby_vminsn_type attr_bin_reput(void) { return YARVINSN_reput; }

_Bool attr_handles_sp_reput(void) { return 0; }

_Bool attr_leaf_reput(void) { return 1; }

const char *attr_name_reput(void) { return insn_name(YARVINSN_reput); }

rb_num_t attr_open_reput(void) { return 0; }

rb_num_t attr_popn_reput(void) { return 1; }

rb_num_t attr_retn_reput(void) { return 1; }

rb_snum_t attr_sp_inc_reput(void) {
  return
# 616 "insns.def"
      0;
# 4393 "insns_info.inc"
}

rb_num_t attr_width_reput(void) { return 1; }

enum ruby_vminsn_type attr_bin_topn(__attribute__((__unused__)) rb_num_t n) {
  return YARVINSN_topn;
}

_Bool attr_handles_sp_topn(__attribute__((__unused__)) rb_num_t n) { return 0; }

_Bool attr_leaf_topn(__attribute__((__unused__)) rb_num_t n) { return 1; }

const char *attr_name_topn(__attribute__((__unused__)) rb_num_t n) {
  return insn_name(YARVINSN_topn);
}

rb_num_t attr_open_topn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_num_t attr_popn_topn(__attribute__((__unused__)) rb_num_t n) { return 0; }

rb_num_t attr_retn_topn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_snum_t attr_sp_inc_topn(__attribute__((__unused__)) rb_num_t n) {
  return
# 627 "insns.def"
      1;
# 4459 "insns_info.inc"
}

rb_num_t attr_width_topn(__attribute__((__unused__)) rb_num_t n) { return 2; }

enum ruby_vminsn_type attr_bin_setn(__attribute__((__unused__)) rb_num_t n) {
  return YARVINSN_setn;
}

_Bool attr_handles_sp_setn(__attribute__((__unused__)) rb_num_t n) { return 0; }

_Bool attr_leaf_setn(__attribute__((__unused__)) rb_num_t n) { return 1; }

const char *attr_name_setn(__attribute__((__unused__)) rb_num_t n) {
  return insn_name(YARVINSN_setn);
}

rb_num_t attr_open_setn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_num_t attr_popn_setn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_num_t attr_retn_setn(__attribute__((__unused__)) rb_num_t n) { return 1; }

rb_snum_t attr_sp_inc_setn(__attribute__((__unused__)) rb_num_t n) {
  return
# 638 "insns.def"
      0;
# 4525 "insns_info.inc"
}

rb_num_t attr_width_setn(__attribute__((__unused__)) rb_num_t n) { return 2; }

enum ruby_vminsn_type attr_bin_adjuststack(__attribute__((__unused__))
                                           rb_num_t n) {
  return YARVINSN_adjuststack;
}

_Bool attr_handles_sp_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 0;
}

_Bool attr_leaf_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 1;
}

const char *attr_name_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return insn_name(YARVINSN_adjuststack);
}

rb_num_t attr_open_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 1;
}

rb_num_t attr_popn_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 0;
}

rb_num_t attr_retn_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 0;
}

rb_snum_t attr_sp_inc_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return
# 649 "insns.def"
      -(rb_snum_t)n;
# 4591 "insns_info.inc"
}

rb_num_t attr_width_adjuststack(__attribute__((__unused__)) rb_num_t n) {
  return 2;
}

enum ruby_vminsn_type attr_bin_defined(__attribute__((__unused__))
                                       rb_num_t op_type,
                                       __attribute__((__unused__)) VALUE obj,
                                       __attribute__((__unused__))
                                       VALUE needstr) {
  return YARVINSN_defined;
}

_Bool attr_handles_sp_defined(__attribute__((__unused__)) rb_num_t op_type,
                              __attribute__((__unused__)) VALUE obj,
                              __attribute__((__unused__)) VALUE needstr) {
  return 0;
}

_Bool attr_leaf_defined(__attribute__((__unused__)) rb_num_t op_type,
                        __attribute__((__unused__)) VALUE obj,
                        __attribute__((__unused__)) VALUE needstr) {
  return
# 664 "insns.def"
      leafness_of_defined(op_type);
# 4634 "insns_info.inc"
}

const char *attr_name_defined(__attribute__((__unused__)) rb_num_t op_type,
                              __attribute__((__unused__)) VALUE obj,
                              __attribute__((__unused__)) VALUE needstr) {
  return insn_name(YARVINSN_defined);
}

rb_num_t attr_open_defined(__attribute__((__unused__)) rb_num_t op_type,
                           __attribute__((__unused__)) VALUE obj,
                           __attribute__((__unused__)) VALUE needstr) {
  return 3;
}

rb_num_t attr_popn_defined(__attribute__((__unused__)) rb_num_t op_type,
                           __attribute__((__unused__)) VALUE obj,
                           __attribute__((__unused__)) VALUE needstr) {
  return 1;
}

rb_num_t attr_retn_defined(__attribute__((__unused__)) rb_num_t op_type,
                           __attribute__((__unused__)) VALUE obj,
                           __attribute__((__unused__)) VALUE needstr) {
  return 1;
}

rb_snum_t attr_sp_inc_defined(__attribute__((__unused__)) rb_num_t op_type,
                              __attribute__((__unused__)) VALUE obj,
                              __attribute__((__unused__)) VALUE needstr) {
  return 0;
}

rb_num_t attr_width_defined(__attribute__((__unused__)) rb_num_t op_type,
                            __attribute__((__unused__)) VALUE obj,
                            __attribute__((__unused__)) VALUE needstr) {
  return 4;
}

enum ruby_vminsn_type attr_bin_checkmatch(__attribute__((__unused__))
                                          rb_num_t flag) {
  return YARVINSN_checkmatch;
}

_Bool attr_handles_sp_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return 0;
}

_Bool attr_leaf_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return
# 681 "insns.def"
      leafness_of_checkmatch(flag);
# 4724 "insns_info.inc"
}

const char *attr_name_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return insn_name(YARVINSN_checkmatch);
}

rb_num_t attr_open_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return 1;
}

rb_num_t attr_popn_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return 2;
}

rb_num_t attr_retn_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return 1;
}

rb_snum_t attr_sp_inc_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return -1;
}

rb_num_t attr_width_checkmatch(__attribute__((__unused__)) rb_num_t flag) {
  return 2;
}

enum ruby_vminsn_type attr_bin_checkkeyword(__attribute__((__unused__))
                                            lindex_t kw_bits_index,
                                            __attribute__((__unused__))
                                            lindex_t keyword_index) {
  return YARVINSN_checkkeyword;
}

_Bool attr_handles_sp_checkkeyword(__attribute__((__unused__))
                                   lindex_t kw_bits_index,
                                   __attribute__((__unused__))
                                   lindex_t keyword_index) {
  return 0;
}

_Bool attr_leaf_checkkeyword(__attribute__((__unused__)) lindex_t kw_bits_index,
                             __attribute__((__unused__))
                             lindex_t keyword_index) {
  return 1;
}

const char *attr_name_checkkeyword(__attribute__((__unused__))
                                   lindex_t kw_bits_index,
                                   __attribute__((__unused__))
                                   lindex_t keyword_index) {
  return insn_name(YARVINSN_checkkeyword);
}

rb_num_t attr_open_checkkeyword(__attribute__((__unused__))
                                lindex_t kw_bits_index,
                                __attribute__((__unused__))
                                lindex_t keyword_index) {
  return 2;
}

rb_num_t attr_popn_checkkeyword(__attribute__((__unused__))
                                lindex_t kw_bits_index,
                                __attribute__((__unused__))
                                lindex_t keyword_index) {
  return 0;
}

rb_num_t attr_retn_checkkeyword(__attribute__((__unused__))
                                lindex_t kw_bits_index,
                                __attribute__((__unused__))
                                lindex_t keyword_index) {
  return 1;
}

rb_snum_t attr_sp_inc_checkkeyword(__attribute__((__unused__))
                                   lindex_t kw_bits_index,
                                   __attribute__((__unused__))
                                   lindex_t keyword_index) {
  return 1;
}

rb_num_t attr_width_checkkeyword(__attribute__((__unused__))
                                 lindex_t kw_bits_index,
                                 __attribute__((__unused__))
                                 lindex_t keyword_index) {
  return 3;
}

enum ruby_vminsn_type attr_bin_checktype(__attribute__((__unused__))
                                         rb_num_t type) {
  return YARVINSN_checktype;
}

_Bool attr_handles_sp_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 0;
}

_Bool attr_leaf_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 1;
}

const char *attr_name_checktype(__attribute__((__unused__)) rb_num_t type) {
  return insn_name(YARVINSN_checktype);
}

rb_num_t attr_open_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 1;
}

rb_num_t attr_popn_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 1;
}

rb_num_t attr_retn_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 1;
}

rb_snum_t attr_sp_inc_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 0;
}

rb_num_t attr_width_checktype(__attribute__((__unused__)) rb_num_t type) {
  return 2;
}

enum ruby_vminsn_type attr_bin_defineclass(__attribute__((__unused__)) ID id,
                                           __attribute__((__unused__))
                                           ISEQ class_iseq,
                                           __attribute__((__unused__))
                                           rb_num_t flags) {
  return YARVINSN_defineclass;
}

_Bool attr_handles_sp_defineclass(__attribute__((__unused__)) ID id,
                                  __attribute__((__unused__)) ISEQ class_iseq,
                                  __attribute__((__unused__)) rb_num_t flags) {
  return 1;
}

_Bool attr_leaf_defineclass(__attribute__((__unused__)) ID id,
                            __attribute__((__unused__)) ISEQ class_iseq,
                            __attribute__((__unused__)) rb_num_t flags) {
  return 0;
}

const char *attr_name_defineclass(__attribute__((__unused__)) ID id,
                                  __attribute__((__unused__)) ISEQ class_iseq,
                                  __attribute__((__unused__)) rb_num_t flags) {
  return insn_name(YARVINSN_defineclass);
}

rb_num_t attr_open_defineclass(__attribute__((__unused__)) ID id,
                               __attribute__((__unused__)) ISEQ class_iseq,
                               __attribute__((__unused__)) rb_num_t flags) {
  return 3;
}

rb_num_t attr_popn_defineclass(__attribute__((__unused__)) ID id,
                               __attribute__((__unused__)) ISEQ class_iseq,
                               __attribute__((__unused__)) rb_num_t flags) {
  return 2;
}

rb_num_t attr_retn_defineclass(__attribute__((__unused__)) ID id,
                               __attribute__((__unused__)) ISEQ class_iseq,
                               __attribute__((__unused__)) rb_num_t flags) {
  return 1;
}

rb_snum_t attr_sp_inc_defineclass(__attribute__((__unused__)) ID id,
                                  __attribute__((__unused__)) ISEQ class_iseq,
                                  __attribute__((__unused__)) rb_num_t flags) {
  return -1;
}

rb_num_t attr_width_defineclass(__attribute__((__unused__)) ID id,
                                __attribute__((__unused__)) ISEQ class_iseq,
                                __attribute__((__unused__)) rb_num_t flags) {
  return 4;
}

enum ruby_vminsn_type attr_bin_send(__attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc,
                                    __attribute__((__unused__))
                                    ISEQ blockiseq) {
  return YARVINSN_send;
}

_Bool attr_handles_sp_send(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc,
                           __attribute__((__unused__)) ISEQ blockiseq) {
  return 1;
}

_Bool attr_leaf_send(__attribute__((__unused__)) CALL_INFO ci,
                     __attribute__((__unused__)) CALL_CACHE cc,
                     __attribute__((__unused__)) ISEQ blockiseq) {
  return 0;
}

const char *attr_name_send(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc,
                           __attribute__((__unused__)) ISEQ blockiseq) {
  return insn_name(YARVINSN_send);
}

rb_num_t attr_open_send(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc,
                        __attribute__((__unused__)) ISEQ blockiseq) {
  return 3;
}

rb_num_t attr_popn_send(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc,
                        __attribute__((__unused__)) ISEQ blockiseq) {
  return 0;
}

rb_num_t attr_retn_send(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc,
                        __attribute__((__unused__)) ISEQ blockiseq) {
  return 1;
}

rb_snum_t attr_sp_inc_send(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc,
                           __attribute__((__unused__)) ISEQ blockiseq) {
  return
# 744 "insns.def"
      -(int)(ci->orig_argc +
             ((ci->flag & (0x01 << VM_CALL_ARGS_BLOCKARG_bit)) ? 1 : 0));
# 5109 "insns_info.inc"
}

rb_num_t attr_width_send(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc,
                         __attribute__((__unused__)) ISEQ blockiseq) {
  return 4;
}

enum ruby_vminsn_type
attr_bin_opt_send_without_block(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_send_without_block;
}

_Bool attr_handles_sp_opt_send_without_block(__attribute__((__unused__))
                                             CALL_INFO ci,
                                             __attribute__((__unused__))
                                             CALL_CACHE cc) {
  return
# 760 "insns.def"
      1;
# 5143 "insns_info.inc"
}

_Bool attr_leaf_opt_send_without_block(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return !attr_handles_sp_opt_send_without_block(ci, cc);
}

const char *attr_name_opt_send_without_block(__attribute__((__unused__))
                                             CALL_INFO ci,
                                             __attribute__((__unused__))
                                             CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_send_without_block);
}

rb_num_t attr_open_opt_send_without_block(__attribute__((__unused__))
                                          CALL_INFO ci,
                                          __attribute__((__unused__))
                                          CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_send_without_block(__attribute__((__unused__))
                                          CALL_INFO ci,
                                          __attribute__((__unused__))
                                          CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_retn_opt_send_without_block(__attribute__((__unused__))
                                          CALL_INFO ci,
                                          __attribute__((__unused__))
                                          CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_send_without_block(__attribute__((__unused__))
                                             CALL_INFO ci,
                                             __attribute__((__unused__))
                                             CALL_CACHE cc) {
  return
# 761 "insns.def"
      -ci->orig_argc;
# 5206 "insns_info.inc"
}

rb_num_t attr_width_opt_send_without_block(__attribute__((__unused__))
                                           CALL_INFO ci,
                                           __attribute__((__unused__))
                                           CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type
attr_bin_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                        __attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_str_freeze;
}

_Bool attr_handles_sp_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                               __attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_str_freeze);
}

rb_num_t attr_open_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

rb_num_t attr_popn_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_retn_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_width_opt_str_freeze(__attribute__((__unused__)) VALUE str,
                                   __attribute__((__unused__)) CALL_INFO ci,
                                   __attribute__((__unused__)) CALL_CACHE cc) {
  return 4;
}

enum ruby_vminsn_type
attr_bin_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                        __attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_str_uminus;
}

_Bool attr_handles_sp_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                               __attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_str_uminus);
}

rb_num_t attr_open_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

rb_num_t attr_popn_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_retn_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                     __attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_width_opt_str_uminus(__attribute__((__unused__)) VALUE str,
                                   __attribute__((__unused__)) CALL_INFO ci,
                                   __attribute__((__unused__)) CALL_CACHE cc) {
  return 4;
}

enum ruby_vminsn_type attr_bin_opt_newarray_max(__attribute__((__unused__))
                                                rb_num_t num) {
  return YARVINSN_opt_newarray_max;
}

_Bool attr_handles_sp_opt_newarray_max(__attribute__((__unused__))
                                       rb_num_t num) {
  return 0;
}

_Bool attr_leaf_opt_newarray_max(__attribute__((__unused__)) rb_num_t num) {
  return
# 806 "insns.def"
      0;
# 5438 "insns_info.inc"
}

const char *attr_name_opt_newarray_max(__attribute__((__unused__))
                                       rb_num_t num) {
  return insn_name(YARVINSN_opt_newarray_max);
}

rb_num_t attr_open_opt_newarray_max(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_num_t attr_popn_opt_newarray_max(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

rb_num_t attr_retn_opt_newarray_max(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_newarray_max(__attribute__((__unused__))
                                       rb_num_t num) {
  return
# 807 "insns.def"
      1 - (rb_snum_t)num;
# 5476 "insns_info.inc"
}

rb_num_t attr_width_opt_newarray_max(__attribute__((__unused__)) rb_num_t num) {
  return 2;
}

enum ruby_vminsn_type attr_bin_opt_newarray_min(__attribute__((__unused__))
                                                rb_num_t num) {
  return YARVINSN_opt_newarray_min;
}

_Bool attr_handles_sp_opt_newarray_min(__attribute__((__unused__))
                                       rb_num_t num) {
  return 0;
}

_Bool attr_leaf_opt_newarray_min(__attribute__((__unused__)) rb_num_t num) {
  return
# 818 "insns.def"
      0;
# 5507 "insns_info.inc"
}

const char *attr_name_opt_newarray_min(__attribute__((__unused__))
                                       rb_num_t num) {
  return insn_name(YARVINSN_opt_newarray_min);
}

rb_num_t attr_open_opt_newarray_min(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_num_t attr_popn_opt_newarray_min(__attribute__((__unused__)) rb_num_t num) {
  return 0;
}

rb_num_t attr_retn_opt_newarray_min(__attribute__((__unused__)) rb_num_t num) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_newarray_min(__attribute__((__unused__))
                                       rb_num_t num) {
  return
# 819 "insns.def"
      1 - (rb_snum_t)num;
# 5545 "insns_info.inc"
}

rb_num_t attr_width_opt_newarray_min(__attribute__((__unused__)) rb_num_t num) {
  return 2;
}

enum ruby_vminsn_type
attr_bin_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                     __attribute__((__unused__)) CALL_CACHE cc,
                     __attribute__((__unused__)) ISEQ blockiseq) {
  return YARVINSN_invokesuper;
}

_Bool attr_handles_sp_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc,
                                  __attribute__((__unused__)) ISEQ blockiseq) {
  return 1;
}

_Bool attr_leaf_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc,
                            __attribute__((__unused__)) ISEQ blockiseq) {
  return 0;
}

const char *attr_name_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc,
                                  __attribute__((__unused__)) ISEQ blockiseq) {
  return insn_name(YARVINSN_invokesuper);
}

rb_num_t attr_open_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc,
                               __attribute__((__unused__)) ISEQ blockiseq) {
  return 3;
}

rb_num_t attr_popn_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc,
                               __attribute__((__unused__)) ISEQ blockiseq) {
  return 0;
}

rb_num_t attr_retn_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc,
                               __attribute__((__unused__)) ISEQ blockiseq) {
  return 1;
}

rb_snum_t attr_sp_inc_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc,
                                  __attribute__((__unused__)) ISEQ blockiseq) {
  return
# 830 "insns.def"
      -(int)(ci->orig_argc +
             ((ci->flag & (0x01 << VM_CALL_ARGS_BLOCKARG_bit)) ? 1 : 0));
# 5643 "insns_info.inc"
}

rb_num_t attr_width_invokesuper(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc,
                                __attribute__((__unused__)) ISEQ blockiseq) {
  return 4;
}

enum ruby_vminsn_type attr_bin_invokeblock(__attribute__((__unused__))
                                           CALL_INFO ci) {
  return YARVINSN_invokeblock;
}

_Bool attr_handles_sp_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return
# 846 "insns.def"
      1;
# 5671 "insns_info.inc"
}

_Bool attr_leaf_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return !attr_handles_sp_invokeblock(ci);
}

const char *attr_name_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return insn_name(YARVINSN_invokeblock);
}

rb_num_t attr_open_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return 1;
}

rb_num_t attr_popn_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return 0;
}

rb_num_t attr_retn_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return 1;
}

rb_snum_t attr_sp_inc_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return
# 847 "insns.def"
      1 - ci->orig_argc;
# 5716 "insns_info.inc"
}

rb_num_t attr_width_invokeblock(__attribute__((__unused__)) CALL_INFO ci) {
  return 2;
}

enum ruby_vminsn_type attr_bin_leave(void) { return YARVINSN_leave; }

_Bool attr_handles_sp_leave(void) {
  return
# 877 "insns.def"
      1;
# 5740 "insns_info.inc"
}

_Bool attr_leaf_leave(void) {
  return
# 876 "insns.def"
      0;
# 5750 "insns_info.inc"
}

const char *attr_name_leave(void) { return insn_name(YARVINSN_leave); }

rb_num_t attr_open_leave(void) { return 0; }

rb_num_t attr_popn_leave(void) { return 1; }

rb_num_t attr_retn_leave(void) { return 1; }

rb_snum_t attr_sp_inc_leave(void) { return 0; }

rb_num_t attr_width_leave(void) { return 1; }

enum ruby_vminsn_type attr_bin_throw(__attribute__((__unused__))
                                     rb_num_t throw_state) {
  return YARVINSN_throw;
}

_Bool attr_handles_sp_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 0;
}

_Bool attr_leaf_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return
# 912 "insns.def"
      0;
# 5816 "insns_info.inc"
}

const char *attr_name_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return insn_name(YARVINSN_throw);
}

rb_num_t attr_open_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 1;
}

rb_num_t attr_popn_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 1;
}

rb_num_t attr_retn_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 1;
}

rb_snum_t attr_sp_inc_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 0;
}

rb_num_t attr_width_throw(__attribute__((__unused__)) rb_num_t throw_state) {
  return 2;
}

enum ruby_vminsn_type attr_bin_jump(__attribute__((__unused__)) OFFSET dst) {
  return YARVINSN_jump;
}

_Bool attr_handles_sp_jump(__attribute__((__unused__)) OFFSET dst) { return 0; }

_Bool attr_leaf_jump(__attribute__((__unused__)) OFFSET dst) {
  return
# 931 "insns.def"
      0;
# 5882 "insns_info.inc"
}

const char *attr_name_jump(__attribute__((__unused__)) OFFSET dst) {
  return insn_name(YARVINSN_jump);
}

rb_num_t attr_open_jump(__attribute__((__unused__)) OFFSET dst) { return 1; }

rb_num_t attr_popn_jump(__attribute__((__unused__)) OFFSET dst) { return 0; }

rb_num_t attr_retn_jump(__attribute__((__unused__)) OFFSET dst) { return 0; }

rb_snum_t attr_sp_inc_jump(__attribute__((__unused__)) OFFSET dst) { return 0; }

rb_num_t attr_width_jump(__attribute__((__unused__)) OFFSET dst) { return 2; }

enum ruby_vminsn_type attr_bin_branchif(__attribute__((__unused__))
                                        OFFSET dst) {
  return YARVINSN_branchif;
}

_Bool attr_handles_sp_branchif(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

_Bool attr_leaf_branchif(__attribute__((__unused__)) OFFSET dst) {
  return
# 944 "insns.def"
      0;
# 5948 "insns_info.inc"
}

const char *attr_name_branchif(__attribute__((__unused__)) OFFSET dst) {
  return insn_name(YARVINSN_branchif);
}

rb_num_t attr_open_branchif(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_popn_branchif(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_retn_branchif(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

rb_snum_t attr_sp_inc_branchif(__attribute__((__unused__)) OFFSET dst) {
  return -1;
}

rb_num_t attr_width_branchif(__attribute__((__unused__)) OFFSET dst) {
  return 2;
}

enum ruby_vminsn_type attr_bin_branchunless(__attribute__((__unused__))
                                            OFFSET dst) {
  return YARVINSN_branchunless;
}

_Bool attr_handles_sp_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

_Bool attr_leaf_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return
# 959 "insns.def"
      0;
# 6014 "insns_info.inc"
}

const char *attr_name_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return insn_name(YARVINSN_branchunless);
}

rb_num_t attr_open_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_popn_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_retn_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

rb_snum_t attr_sp_inc_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return -1;
}

rb_num_t attr_width_branchunless(__attribute__((__unused__)) OFFSET dst) {
  return 2;
}

enum ruby_vminsn_type attr_bin_branchnil(__attribute__((__unused__))
                                         OFFSET dst) {
  return YARVINSN_branchnil;
}

_Bool attr_handles_sp_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

_Bool attr_leaf_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return
# 974 "insns.def"
      0;
# 6080 "insns_info.inc"
}

const char *attr_name_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return insn_name(YARVINSN_branchnil);
}

rb_num_t attr_open_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_popn_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return 1;
}

rb_num_t attr_retn_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return 0;
}

rb_snum_t attr_sp_inc_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return -1;
}

rb_num_t attr_width_branchnil(__attribute__((__unused__)) OFFSET dst) {
  return 2;
}

enum ruby_vminsn_type attr_bin_opt_getinlinecache(__attribute__((__unused__))
                                                  OFFSET dst,
                                                  __attribute__((__unused__))
                                                  IC ic) {
  return YARVINSN_opt_getinlinecache;
}

_Bool attr_handles_sp_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                         __attribute__((__unused__)) IC ic) {
  return 0;
}

_Bool attr_leaf_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                   __attribute__((__unused__)) IC ic) {
  return 1;
}

const char *attr_name_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                         __attribute__((__unused__)) IC ic) {
  return insn_name(YARVINSN_opt_getinlinecache);
}

rb_num_t attr_open_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                      __attribute__((__unused__)) IC ic) {
  return 2;
}

rb_num_t attr_popn_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                      __attribute__((__unused__)) IC ic) {
  return 0;
}

rb_num_t attr_retn_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                      __attribute__((__unused__)) IC ic) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                         __attribute__((__unused__)) IC ic) {
  return 1;
}

rb_num_t attr_width_opt_getinlinecache(__attribute__((__unused__)) OFFSET dst,
                                       __attribute__((__unused__)) IC ic) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_setinlinecache(__attribute__((__unused__))
                                                  IC ic) {
  return YARVINSN_opt_setinlinecache;
}

_Bool attr_handles_sp_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 0;
}

_Bool attr_leaf_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 1;
}

const char *attr_name_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return insn_name(YARVINSN_opt_setinlinecache);
}

rb_num_t attr_open_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 1;
}

rb_num_t attr_popn_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 1;
}

rb_num_t attr_retn_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 0;
}

rb_num_t attr_width_opt_setinlinecache(__attribute__((__unused__)) IC ic) {
  return 2;
}

enum ruby_vminsn_type attr_bin_once(__attribute__((__unused__)) ISEQ iseq,
                                    __attribute__((__unused__)) ISE ise) {
  return YARVINSN_once;
}

_Bool attr_handles_sp_once(__attribute__((__unused__)) ISEQ iseq,
                           __attribute__((__unused__)) ISE ise) {
  return 1;
}

_Bool attr_leaf_once(__attribute__((__unused__)) ISEQ iseq,
                     __attribute__((__unused__)) ISE ise) {
  return 0;
}

const char *attr_name_once(__attribute__((__unused__)) ISEQ iseq,
                           __attribute__((__unused__)) ISE ise) {
  return insn_name(YARVINSN_once);
}

rb_num_t attr_open_once(__attribute__((__unused__)) ISEQ iseq,
                        __attribute__((__unused__)) ISE ise) {
  return 2;
}

rb_num_t attr_popn_once(__attribute__((__unused__)) ISEQ iseq,
                        __attribute__((__unused__)) ISE ise) {
  return 0;
}

rb_num_t attr_retn_once(__attribute__((__unused__)) ISEQ iseq,
                        __attribute__((__unused__)) ISE ise) {
  return 1;
}

rb_snum_t attr_sp_inc_once(__attribute__((__unused__)) ISEQ iseq,
                           __attribute__((__unused__)) ISE ise) {
  return 1;
}

rb_num_t attr_width_once(__attribute__((__unused__)) ISEQ iseq,
                         __attribute__((__unused__)) ISE ise) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_case_dispatch(__attribute__((__unused__))
                                                 CDHASH hash,
                                                 __attribute__((__unused__))
                                                 OFFSET else_offset) {
  return YARVINSN_opt_case_dispatch;
}

_Bool attr_handles_sp_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                        __attribute__((__unused__))
                                        OFFSET else_offset) {
  return 0;
}

_Bool attr_leaf_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                  __attribute__((__unused__))
                                  OFFSET else_offset) {
  return 1;
}

const char *attr_name_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                        __attribute__((__unused__))
                                        OFFSET else_offset) {
  return insn_name(YARVINSN_opt_case_dispatch);
}

rb_num_t attr_open_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                     __attribute__((__unused__))
                                     OFFSET else_offset) {
  return 2;
}

rb_num_t attr_popn_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                     __attribute__((__unused__))
                                     OFFSET else_offset) {
  return 1;
}

rb_num_t attr_retn_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                     __attribute__((__unused__))
                                     OFFSET else_offset) {
  return 0;
}

rb_snum_t attr_sp_inc_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                        __attribute__((__unused__))
                                        OFFSET else_offset) {
  return
# 1028 "insns.def"
      -1;
# 6448 "insns_info.inc"
}

rb_num_t attr_width_opt_case_dispatch(__attribute__((__unused__)) CDHASH hash,
                                      __attribute__((__unused__))
                                      OFFSET else_offset) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_plus(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_plus;
}

_Bool attr_handles_sp_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1047 "insns.def"
      0;
# 6491 "insns_info.inc"
}

const char *attr_name_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_plus);
}

rb_num_t attr_open_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_plus(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_minus(__attribute__((__unused__))
                                         CALL_INFO ci,
                                         __attribute__((__unused__))
                                         CALL_CACHE cc) {
  return YARVINSN_opt_minus;
}

_Bool attr_handles_sp_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_minus);
}

rb_num_t attr_open_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_minus(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_mult(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_mult;
}

_Bool attr_handles_sp_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_mult);
}

rb_num_t attr_open_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_mult(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return YARVINSN_opt_div;
}

_Bool attr_handles_sp_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_div);
}

rb_num_t attr_open_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_div(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return YARVINSN_opt_mod;
}

_Bool attr_handles_sp_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_mod);
}

rb_num_t attr_open_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_mod(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_eq;
}

_Bool attr_handles_sp_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1121 "insns.def"
      0;
# 6944 "insns_info.inc"
}

const char *attr_name_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_eq);
}

rb_num_t attr_open_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_eq(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type
attr_bin_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                 __attribute__((__unused__)) CALL_CACHE cc_eq,
                 __attribute__((__unused__)) CALL_INFO ci,
                 __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_neq;
}

_Bool attr_handles_sp_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                              __attribute__((__unused__)) CALL_CACHE cc_eq,
                              __attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                        __attribute__((__unused__)) CALL_CACHE cc_eq,
                        __attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1137 "insns.def"
      0;
# 7043 "insns_info.inc"
}

const char *attr_name_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                              __attribute__((__unused__)) CALL_CACHE cc_eq,
                              __attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_neq);
}

rb_num_t attr_open_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                           __attribute__((__unused__)) CALL_CACHE cc_eq,
                           __attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 4;
}

rb_num_t attr_popn_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                           __attribute__((__unused__)) CALL_CACHE cc_eq,
                           __attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                           __attribute__((__unused__)) CALL_CACHE cc_eq,
                           __attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                              __attribute__((__unused__)) CALL_CACHE cc_eq,
                              __attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_neq(__attribute__((__unused__)) CALL_INFO ci_eq,
                            __attribute__((__unused__)) CALL_CACHE cc_eq,
                            __attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 5;
}

enum ruby_vminsn_type attr_bin_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_lt;
}

_Bool attr_handles_sp_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_lt);
}

rb_num_t attr_open_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_lt(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_le;
}

_Bool attr_handles_sp_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_le);
}

rb_num_t attr_open_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_le(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_gt;
}

_Bool attr_handles_sp_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_gt);
}

rb_num_t attr_open_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_gt(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_ge;
}

_Bool attr_handles_sp_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_ge);
}

rb_num_t attr_open_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_ge(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_ltlt(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_ltlt;
}

_Bool attr_handles_sp_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_ltlt);
}

rb_num_t attr_open_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_ltlt(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return YARVINSN_opt_and;
}

_Bool attr_handles_sp_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_and);
}

rb_num_t attr_open_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_and(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                                      __attribute__((__unused__))
                                      CALL_CACHE cc) {
  return YARVINSN_opt_or;
}

_Bool attr_handles_sp_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_or);
}

rb_num_t attr_open_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                          __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_or(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_aref(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_aref;
}

_Bool attr_handles_sp_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1254 "insns.def"
      0;
# 7778 "insns_info.inc"
}

const char *attr_name_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_aref);
}

rb_num_t attr_open_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_aref(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_aset(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_aset;
}

_Bool attr_handles_sp_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1271 "insns.def"
      0;
# 7871 "insns_info.inc"
}

const char *attr_name_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_aset);
}

rb_num_t attr_open_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

rb_num_t attr_retn_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return -2;
}

rb_num_t attr_width_opt_aset(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type
attr_bin_opt_aset_with(__attribute__((__unused__)) VALUE key,
                       __attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_aset_with;
}

_Bool attr_handles_sp_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_aset_with(__attribute__((__unused__)) VALUE key,
                              __attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1287 "insns.def"
      0;
# 7967 "insns_info.inc"
}

const char *attr_name_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_aset_with);
}

rb_num_t attr_open_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

rb_num_t attr_popn_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_aset_with(__attribute__((__unused__)) VALUE key,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 4;
}

enum ruby_vminsn_type
attr_bin_opt_aref_with(__attribute__((__unused__)) VALUE key,
                       __attribute__((__unused__)) CALL_INFO ci,
                       __attribute__((__unused__)) CALL_CACHE cc) {
  return YARVINSN_opt_aref_with;
}

_Bool attr_handles_sp_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_aref_with(__attribute__((__unused__)) VALUE key,
                              __attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return
# 1310 "insns.def"
      0;
# 8069 "insns_info.inc"
}

const char *attr_name_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_aref_with);
}

rb_num_t attr_open_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

rb_num_t attr_popn_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                 __attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                    __attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_aref_with(__attribute__((__unused__)) VALUE key,
                                  __attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 4;
}

enum ruby_vminsn_type attr_bin_opt_length(__attribute__((__unused__))
                                          CALL_INFO ci,
                                          __attribute__((__unused__))
                                          CALL_CACHE cc) {
  return YARVINSN_opt_length;
}

_Bool attr_handles_sp_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_length);
}

rb_num_t attr_open_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_length(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_size(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_size;
}

_Bool attr_handles_sp_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_size);
}

rb_num_t attr_open_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_size(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_empty_p(__attribute__((__unused__))
                                           CALL_INFO ci,
                                           __attribute__((__unused__))
                                           CALL_CACHE cc) {
  return YARVINSN_opt_empty_p;
}

_Bool attr_handles_sp_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_empty_p);
}

rb_num_t attr_open_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                                  __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_empty_p(__attribute__((__unused__)) CALL_INFO ci,
                                __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_succ(__attribute__((__unused__))
                                        CALL_INFO ci,
                                        __attribute__((__unused__))
                                        CALL_CACHE cc) {
  return YARVINSN_opt_succ;
}

_Bool attr_handles_sp_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                         __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_succ);
}

rb_num_t attr_open_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                               __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_succ(__attribute__((__unused__)) CALL_INFO ci,
                             __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return YARVINSN_opt_not;
}

_Bool attr_handles_sp_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                        __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_not);
}

rb_num_t attr_open_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_num_t attr_retn_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                           __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                              __attribute__((__unused__)) CALL_CACHE cc) {
  return 0;
}

rb_num_t attr_width_opt_not(__attribute__((__unused__)) CALL_INFO ci,
                            __attribute__((__unused__)) CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_regexpmatch1(__attribute__((__unused__))
                                                VALUE recv) {
  return YARVINSN_opt_regexpmatch1;
}

_Bool attr_handles_sp_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 0;
}

_Bool attr_leaf_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return
# 1398 "insns.def"
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MATCH)] & ((1 << 8))) == 0),
          1)));
# 8609 "insns_info.inc"
}

const char *attr_name_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return insn_name(YARVINSN_opt_regexpmatch1);
}

rb_num_t attr_open_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 1;
}

rb_num_t attr_popn_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 1;
}

rb_num_t attr_retn_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 0;
}

rb_num_t attr_width_opt_regexpmatch1(__attribute__((__unused__)) VALUE recv) {
  return 2;
}

enum ruby_vminsn_type attr_bin_opt_regexpmatch2(__attribute__((__unused__))
                                                CALL_INFO ci,
                                                __attribute__((__unused__))
                                                CALL_CACHE cc) {
  return YARVINSN_opt_regexpmatch2;
}

_Bool attr_handles_sp_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return 0;
}

_Bool attr_leaf_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                 __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

const char *attr_name_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return insn_name(YARVINSN_opt_regexpmatch2);
}

rb_num_t attr_open_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_popn_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 2;
}

rb_num_t attr_retn_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                    __attribute__((__unused__)) CALL_CACHE cc) {
  return 1;
}

rb_snum_t attr_sp_inc_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                       __attribute__((__unused__))
                                       CALL_CACHE cc) {
  return -1;
}

rb_num_t attr_width_opt_regexpmatch2(__attribute__((__unused__)) CALL_INFO ci,
                                     __attribute__((__unused__))
                                     CALL_CACHE cc) {
  return 3;
}

enum ruby_vminsn_type attr_bin_opt_call_c_function(__attribute__((__unused__))
                                                   rb_insn_func_t funcptr) {
  return YARVINSN_opt_call_c_function;
}

_Bool attr_handles_sp_opt_call_c_function(__attribute__((__unused__))
                                          rb_insn_func_t funcptr) {
  return
# 1424 "insns.def"
      1;
# 8758 "insns_info.inc"
}

_Bool attr_leaf_opt_call_c_function(__attribute__((__unused__))
                                    rb_insn_func_t funcptr) {
  return
# 1423 "insns.def"
      0;
# 8768 "insns_info.inc"
}

const char *attr_name_opt_call_c_function(__attribute__((__unused__))
                                          rb_insn_func_t funcptr) {
  return insn_name(YARVINSN_opt_call_c_function);
}

rb_num_t attr_open_opt_call_c_function(__attribute__((__unused__))
                                       rb_insn_func_t funcptr) {
  return 1;
}

rb_num_t attr_popn_opt_call_c_function(__attribute__((__unused__))
                                       rb_insn_func_t funcptr) {
  return 0;
}

rb_num_t attr_retn_opt_call_c_function(__attribute__((__unused__))
                                       rb_insn_func_t funcptr) {
  return 0;
}

rb_snum_t attr_sp_inc_opt_call_c_function(__attribute__((__unused__))
                                          rb_insn_func_t funcptr) {
  return 0;
}

rb_num_t attr_width_opt_call_c_function(__attribute__((__unused__))
                                        rb_insn_func_t funcptr) {
  return 2;
}

enum ruby_vminsn_type attr_bin_bitblt(void) { return YARVINSN_bitblt; }

_Bool attr_handles_sp_bitblt(void) { return 0; }

_Bool attr_leaf_bitblt(void) { return 1; }

const char *attr_name_bitblt(void) { return insn_name(YARVINSN_bitblt); }

rb_num_t attr_open_bitblt(void) { return 0; }

rb_num_t attr_popn_bitblt(void) { return 0; }

rb_num_t attr_retn_bitblt(void) { return 1; }

rb_snum_t attr_sp_inc_bitblt(void) { return 1; }

rb_num_t attr_width_bitblt(void) { return 1; }

enum ruby_vminsn_type attr_bin_answer(void) { return YARVINSN_answer; }

_Bool attr_handles_sp_answer(void) { return 0; }

_Bool attr_leaf_answer(void) { return 1; }

const char *attr_name_answer(void) { return insn_name(YARVINSN_answer); }

rb_num_t attr_open_answer(void) { return 0; }

rb_num_t attr_popn_answer(void) { return 0; }

rb_num_t attr_retn_answer(void) { return 1; }

rb_snum_t attr_sp_inc_answer(void) { return 1; }

rb_num_t attr_width_answer(void) { return 1; }

enum ruby_vminsn_type attr_bin_getlocal_WC_0(__attribute__((__unused__))
                                             lindex_t idx) {
  return YARVINSN_getlocal_WC_0;
}

_Bool attr_handles_sp_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

_Bool attr_leaf_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

const char *attr_name_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return insn_name(YARVINSN_getlocal_WC_0);
}

rb_num_t attr_open_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_popn_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

rb_num_t attr_retn_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_snum_t attr_sp_inc_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_width_getlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 2;
}

enum ruby_vminsn_type attr_bin_getlocal_WC_1(__attribute__((__unused__))
                                             lindex_t idx) {
  return YARVINSN_getlocal_WC_1;
}

_Bool attr_handles_sp_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

_Bool attr_leaf_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

const char *attr_name_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return insn_name(YARVINSN_getlocal_WC_1);
}

rb_num_t attr_open_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_popn_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

rb_num_t attr_retn_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_snum_t attr_sp_inc_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_width_getlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 2;
}

enum ruby_vminsn_type attr_bin_setlocal_WC_0(__attribute__((__unused__))
                                             lindex_t idx) {
  return YARVINSN_setlocal_WC_0;
}

_Bool attr_handles_sp_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

_Bool attr_leaf_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

const char *attr_name_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return insn_name(YARVINSN_setlocal_WC_0);
}

rb_num_t attr_open_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_popn_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_retn_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

rb_snum_t attr_sp_inc_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return -1;
}

rb_num_t attr_width_setlocal_WC_0(__attribute__((__unused__)) lindex_t idx) {
  return 2;
}

enum ruby_vminsn_type attr_bin_setlocal_WC_1(__attribute__((__unused__))
                                             lindex_t idx) {
  return YARVINSN_setlocal_WC_1;
}

_Bool attr_handles_sp_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

_Bool attr_leaf_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

const char *attr_name_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return insn_name(YARVINSN_setlocal_WC_1);
}

rb_num_t attr_open_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_popn_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 1;
}

rb_num_t attr_retn_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 0;
}

rb_snum_t attr_sp_inc_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return -1;
}

rb_num_t attr_width_setlocal_WC_1(__attribute__((__unused__)) lindex_t idx) {
  return 2;
}

enum ruby_vminsn_type attr_bin_putobject_INT2FIX_0_(void) {
  return YARVINSN_putobject_INT2FIX_0_;
}

_Bool attr_handles_sp_putobject_INT2FIX_0_(void) { return 0; }

_Bool attr_leaf_putobject_INT2FIX_0_(void) { return 1; }

const char *attr_name_putobject_INT2FIX_0_(void) {
  return insn_name(YARVINSN_putobject_INT2FIX_0_);
}

rb_num_t attr_open_putobject_INT2FIX_0_(void) { return 0; }

rb_num_t attr_popn_putobject_INT2FIX_0_(void) { return 0; }

rb_num_t attr_retn_putobject_INT2FIX_0_(void) { return 1; }

rb_snum_t attr_sp_inc_putobject_INT2FIX_0_(void) { return 1; }

rb_num_t attr_width_putobject_INT2FIX_0_(void) { return 1; }

enum ruby_vminsn_type attr_bin_putobject_INT2FIX_1_(void) {
  return YARVINSN_putobject_INT2FIX_1_;
}

_Bool attr_handles_sp_putobject_INT2FIX_1_(void) { return 0; }

_Bool attr_leaf_putobject_INT2FIX_1_(void) { return 1; }

const char *attr_name_putobject_INT2FIX_1_(void) {
  return insn_name(YARVINSN_putobject_INT2FIX_1_);
}

rb_num_t attr_open_putobject_INT2FIX_1_(void) { return 0; }

rb_num_t attr_popn_putobject_INT2FIX_1_(void) { return 0; }

rb_num_t attr_retn_putobject_INT2FIX_1_(void) { return 1; }

rb_snum_t attr_sp_inc_putobject_INT2FIX_1_(void) { return 1; }

rb_num_t attr_width_putobject_INT2FIX_1_(void) { return 1; }

__attribute__((__pure__)) __attribute__((__unused__)) static int
insn_stack_increase(int depth, int insn, const VALUE *opes);
__attribute__((__pure__)) static rb_snum_t
insn_stack_increase_dispatch(enum ruby_vminsn_type insn, const VALUE *opes);

rb_snum_t insn_stack_increase_dispatch(enum ruby_vminsn_type insn,
                                       const VALUE *opes) {
  static const signed char t[] = {
      0,    1,    -1,   1,    -1,   1,  1,    -1, 1,  -1,   1,    -1,   0,
      -2,   1,    -1,   1,    1,    1,  1,    1,  1,  -127, -1,   0,    -127,
      0,    -127, 1,    -127, -1,   0,  -127, 1,  -1, -1,   1,    -127, 0,
      -127, -127, -127, -127, -127, 0,  -1,   1,  0,  -1,   -127, -127, 1,
      1,    -127, -127, -127, -127, 0,  0,    0,  -1, -1,   -1,   1,    0,
      1,    -127, -1,   -1,   -1,   -1, -1,   -1, -1, -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -2,   -1, 0,    0,  0,  0,    0,    0,    0,
      -1,   0,    1,    1,    1,    1,  -1,   -1, 1,  1,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,    0,  0,  0,    0,    0,    0,
      0,    0,    0,    0,    0,    0,  0,
  };
  signed char c = t[insn];

  _Static_assert(((int)(sizeof(t) / sizeof((t)[0]))) == VM_INSTRUCTION_SIZE,
                 "numberof_t"
                 ": "
                 "numberof(t) == VM_INSTRUCTION_SIZE");
  if (c != -127) {
    return c;
  } else
    switch (insn) {
    default:
      __builtin_unreachable();
    case YARVINSN_concatstrings:
      return attr_sp_inc_concatstrings(rb_num2long_inline(opes[0]));
    case YARVINSN_toregexp:
      return attr_sp_inc_toregexp(rb_num2long_inline(opes[0]),
                                  rb_num2long_inline(opes[1]));
    case YARVINSN_newarray:
      return attr_sp_inc_newarray(rb_num2long_inline(opes[0]));
    case YARVINSN_expandarray:
      return attr_sp_inc_expandarray(rb_num2long_inline(opes[0]),
                                     rb_num2long_inline(opes[1]));
    case YARVINSN_newhash:
      return attr_sp_inc_newhash(rb_num2long_inline(opes[0]));
    case YARVINSN_dupn:
      return attr_sp_inc_dupn(rb_num2long_inline(opes[0]));
    case YARVINSN_reverse:
      return attr_sp_inc_reverse(rb_num2long_inline(opes[0]));
    case YARVINSN_reput:
      return attr_sp_inc_reput();
    case YARVINSN_topn:
      return attr_sp_inc_topn(rb_num2long_inline(opes[0]));
    case YARVINSN_setn:
      return attr_sp_inc_setn(rb_num2long_inline(opes[0]));
    case YARVINSN_adjuststack:
      return attr_sp_inc_adjuststack(rb_num2long_inline(opes[0]));
    case YARVINSN_send:
      return attr_sp_inc_send((CALL_INFO)(opes[0]), (CALL_CACHE)(opes[1]),
                              (ISEQ)(opes[2]));
    case YARVINSN_opt_send_without_block:
      return attr_sp_inc_opt_send_without_block((CALL_INFO)(opes[0]),
                                                (CALL_CACHE)(opes[1]));
    case YARVINSN_opt_newarray_max:
      return attr_sp_inc_opt_newarray_max(rb_num2long_inline(opes[0]));
    case YARVINSN_opt_newarray_min:
      return attr_sp_inc_opt_newarray_min(rb_num2long_inline(opes[0]));
    case YARVINSN_invokesuper:
      return attr_sp_inc_invokesuper((CALL_INFO)(opes[0]),
                                     (CALL_CACHE)(opes[1]), (ISEQ)(opes[2]));
    case YARVINSN_invokeblock:
      return attr_sp_inc_invokeblock((CALL_INFO)(opes[0]));
    case YARVINSN_opt_case_dispatch:
      return attr_sp_inc_opt_case_dispatch((CDHASH)(opes[0]),
                                           (OFFSET)(opes[1]));
    }
}

int insn_stack_increase(int depth, int insn, const VALUE *opes) {
  enum ruby_vminsn_type itype = (enum ruby_vminsn_type)insn;
  return depth + (int)insn_stack_increase_dispatch(itype, opes);
}
# 15 "./vm_insnhelper.c" 2

# 1 "./constant.h" 1
# 14 "./constant.h"
typedef enum {
  CONST_DEPRECATED = 0x100,

  CONST_VISIBILITY_MASK = 0xff,
  CONST_PUBLIC = 0x00,
  CONST_PRIVATE,
  CONST_VISIBILITY_MAX
} rb_const_flag_t;
# 31 "./constant.h"
typedef struct rb_const_entry_struct {
  rb_const_flag_t flag;
  int line;
  const VALUE value;
  const VALUE file;
} rb_const_entry_t;

VALUE rb_mod_private_constant(int argc, const VALUE *argv, VALUE obj);
VALUE rb_mod_public_constant(int argc, const VALUE *argv, VALUE obj);
VALUE rb_mod_deprecate_constant(int argc, const VALUE *argv, VALUE obj);
void rb_free_const_table(struct rb_id_table *tbl);
VALUE rb_public_const_get(VALUE klass, ID id);
VALUE rb_public_const_get_at(VALUE klass, ID id);
VALUE rb_public_const_get_from(VALUE klass, ID id);
int rb_public_const_defined(VALUE klass, ID id);
int rb_public_const_defined_at(VALUE klass, ID id);
int rb_public_const_defined_from(VALUE klass, ID id);
rb_const_entry_t *rb_const_lookup(VALUE klass, ID id);
int rb_autoloading_value(VALUE mod, ID id, VALUE *value, rb_const_flag_t *flag);
# 18 "./vm_insnhelper.c" 2

# 1 "./debug_counter.h" 1
# 250 "./debug_counter.h"
enum rb_debug_counter_type {

# 1 "././debug_counter.h" 1
# 30 "././debug_counter.h"
  RB_DEBUG_COUNTER_mc_inline_hit,
  RB_DEBUG_COUNTER_mc_inline_miss,
  RB_DEBUG_COUNTER_mc_global_hit,
  RB_DEBUG_COUNTER_mc_global_miss,
  RB_DEBUG_COUNTER_mc_global_state_miss,
  RB_DEBUG_COUNTER_mc_class_serial_miss,
  RB_DEBUG_COUNTER_mc_cme_complement,
  RB_DEBUG_COUNTER_mc_cme_complement_hit,
  RB_DEBUG_COUNTER_mc_search_super,
# 50 "././debug_counter.h"
  RB_DEBUG_COUNTER_frame_push,
  RB_DEBUG_COUNTER_frame_push_method,
  RB_DEBUG_COUNTER_frame_push_block,
  RB_DEBUG_COUNTER_frame_push_class,
  RB_DEBUG_COUNTER_frame_push_top,
  RB_DEBUG_COUNTER_frame_push_cfunc,
  RB_DEBUG_COUNTER_frame_push_ifunc,
  RB_DEBUG_COUNTER_frame_push_eval,
  RB_DEBUG_COUNTER_frame_push_rescue,
  RB_DEBUG_COUNTER_frame_push_dummy,

  RB_DEBUG_COUNTER_frame_R2R,
  RB_DEBUG_COUNTER_frame_R2C,
  RB_DEBUG_COUNTER_frame_C2C,
  RB_DEBUG_COUNTER_frame_C2R,
# 77 "././debug_counter.h"
  RB_DEBUG_COUNTER_ivar_get_ic_hit,
  RB_DEBUG_COUNTER_ivar_get_ic_miss,
  RB_DEBUG_COUNTER_ivar_get_ic_miss_serial,
  RB_DEBUG_COUNTER_ivar_get_ic_miss_unset,
  RB_DEBUG_COUNTER_ivar_get_ic_miss_noobject,
  RB_DEBUG_COUNTER_ivar_set_ic_hit,
  RB_DEBUG_COUNTER_ivar_set_ic_miss,
  RB_DEBUG_COUNTER_ivar_set_ic_miss_serial,
  RB_DEBUG_COUNTER_ivar_set_ic_miss_unset,
  RB_DEBUG_COUNTER_ivar_set_ic_miss_oorange,
  RB_DEBUG_COUNTER_ivar_set_ic_miss_noobject,
  RB_DEBUG_COUNTER_ivar_get_base,
  RB_DEBUG_COUNTER_ivar_set_base,
# 98 "././debug_counter.h"
  RB_DEBUG_COUNTER_lvar_get,
  RB_DEBUG_COUNTER_lvar_get_dynamic,
  RB_DEBUG_COUNTER_lvar_set,
  RB_DEBUG_COUNTER_lvar_set_dynamic,
  RB_DEBUG_COUNTER_lvar_set_slowpath,
# 112 "././debug_counter.h"
  RB_DEBUG_COUNTER_gc_count,
  RB_DEBUG_COUNTER_gc_minor_newobj,
  RB_DEBUG_COUNTER_gc_minor_malloc,
  RB_DEBUG_COUNTER_gc_minor_method,
  RB_DEBUG_COUNTER_gc_minor_capi,
  RB_DEBUG_COUNTER_gc_minor_stress,
  RB_DEBUG_COUNTER_gc_major_nofree,
  RB_DEBUG_COUNTER_gc_major_oldgen,
  RB_DEBUG_COUNTER_gc_major_shady,
  RB_DEBUG_COUNTER_gc_major_force,
  RB_DEBUG_COUNTER_gc_major_oldmalloc,
# 159 "././debug_counter.h"
  RB_DEBUG_COUNTER_obj_newobj,
  RB_DEBUG_COUNTER_obj_newobj_slowpath,
  RB_DEBUG_COUNTER_obj_newobj_wb_unprotected,
  RB_DEBUG_COUNTER_obj_free,
  RB_DEBUG_COUNTER_obj_promote,
  RB_DEBUG_COUNTER_obj_wb_unprotect,

  RB_DEBUG_COUNTER_obj_obj_embed,
  RB_DEBUG_COUNTER_obj_obj_transient,
  RB_DEBUG_COUNTER_obj_obj_ptr,

  RB_DEBUG_COUNTER_obj_str_ptr,
  RB_DEBUG_COUNTER_obj_str_embed,
  RB_DEBUG_COUNTER_obj_str_shared,
  RB_DEBUG_COUNTER_obj_str_nofree,
  RB_DEBUG_COUNTER_obj_str_fstr,

  RB_DEBUG_COUNTER_obj_ary_embed,
  RB_DEBUG_COUNTER_obj_ary_transient,
  RB_DEBUG_COUNTER_obj_ary_ptr,

  RB_DEBUG_COUNTER_obj_hash_empty,
  RB_DEBUG_COUNTER_obj_hash_under4,
  RB_DEBUG_COUNTER_obj_hash_ge4,
  RB_DEBUG_COUNTER_obj_hash_ge8,
  RB_DEBUG_COUNTER_obj_hash_array,
  RB_DEBUG_COUNTER_obj_hash_st,
  RB_DEBUG_COUNTER_obj_hash_transient,

  RB_DEBUG_COUNTER_obj_hash_force_convert,

  RB_DEBUG_COUNTER_obj_struct_embed,
  RB_DEBUG_COUNTER_obj_struct_transient,
  RB_DEBUG_COUNTER_obj_struct_ptr,

  RB_DEBUG_COUNTER_obj_regexp_ptr,

  RB_DEBUG_COUNTER_obj_data_empty,
  RB_DEBUG_COUNTER_obj_data_xfree,
  RB_DEBUG_COUNTER_obj_data_imm_free,
  RB_DEBUG_COUNTER_obj_data_zombie,

  RB_DEBUG_COUNTER_obj_match_ptr,
  RB_DEBUG_COUNTER_obj_file_ptr,
  RB_DEBUG_COUNTER_obj_bignum_ptr,

  RB_DEBUG_COUNTER_obj_symbol,

  RB_DEBUG_COUNTER_obj_imemo_ment,
  RB_DEBUG_COUNTER_obj_imemo_iseq,
  RB_DEBUG_COUNTER_obj_imemo_env,
  RB_DEBUG_COUNTER_obj_imemo_tmpbuf,
  RB_DEBUG_COUNTER_obj_imemo_ast,
  RB_DEBUG_COUNTER_obj_imemo_cref,
  RB_DEBUG_COUNTER_obj_imemo_svar,
  RB_DEBUG_COUNTER_obj_imemo_throw_data,
  RB_DEBUG_COUNTER_obj_imemo_ifunc,
  RB_DEBUG_COUNTER_obj_imemo_memo,
  RB_DEBUG_COUNTER_obj_imemo_parser_strterm,

  RB_DEBUG_COUNTER_obj_iclass_ptr,
  RB_DEBUG_COUNTER_obj_class_ptr,
  RB_DEBUG_COUNTER_obj_module_ptr,

  RB_DEBUG_COUNTER_heap_xmalloc,
  RB_DEBUG_COUNTER_heap_xrealloc,
  RB_DEBUG_COUNTER_heap_xfree,

  RB_DEBUG_COUNTER_theap_alloc,
  RB_DEBUG_COUNTER_theap_alloc_fail,
  RB_DEBUG_COUNTER_theap_evacuate,
# 253 "././debug_counter.h" 2
  RB_DEBUG_COUNTER_MAX

};
# 281 "././debug_counter.h"
void rb_debug_counter_show_results(const char *msg);
# 21 "./vm_insnhelper.c" 2

static rb_control_frame_t *
vm_get_ruby_level_caller_cfp(const rb_execution_context_t *ec,
                             const rb_control_frame_t *cfp);

VALUE
ruby_vm_special_exception_copy(VALUE exc) {
  VALUE e = rb_obj_alloc(rb_class_real((((struct RBasic *)(exc))->klass)));
  rb_obj_copy_ivar(e, exc);
  return e;
}

__attribute__((__noreturn__)) static void
ec_stack_overflow(rb_execution_context_t *ec, int);
static void ec_stack_overflow(rb_execution_context_t *ec, int setup) {
  VALUE mesg = rb_ec_vm_ptr(ec)->special_exceptions[ruby_error_sysstack];
  ec->raised_flag = RAISED_STACKOVERFLOW;
  if (setup) {
    VALUE at = rb_ec_backtrace_object(ec);
    mesg = ruby_vm_special_exception_copy(mesg);
    rb_ivar_set(mesg, idBt, at);
    rb_ivar_set(mesg, idBt_locations, at);
  }
  ec->errinfo = mesg;
  rb_ec_tag_jump(ec, RUBY_TAG_RAISE);
}

__attribute__((__noreturn__)) static void vm_stackoverflow(void);

static void vm_stackoverflow(void) {
  ec_stack_overflow(rb_current_execution_context(), 1);
}

__attribute__((__noreturn__)) void
rb_ec_stack_overflow(rb_execution_context_t *ec, int crit);
void rb_ec_stack_overflow(rb_execution_context_t *ec, int crit) {
  if (crit || rb_during_gc()) {
    ec->raised_flag = RAISED_STACKOVERFLOW;
    ec->errinfo = rb_ec_vm_ptr(ec)->special_exceptions[ruby_error_stackfatal];
    rb_ec_tag_jump(ec, RUBY_TAG_RAISE);
  }

  ec_stack_overflow(ec, 1);
}
# 202 "./vm_insnhelper.c"
static inline rb_control_frame_t *
vm_push_frame(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE type,
              VALUE self, VALUE specval, VALUE cref_or_me, const VALUE *pc,
              VALUE *sp, int local_size, int stack_max) {
  rb_control_frame_t *const cfp = ec->cfp - 1;
  int i;

  ;
  ((void)0);

  if ((__builtin_expect(
          !!(!(!(1 / !!(sizeof(*(sp)) == sizeof(VALUE))) ||
               !(1 / !!(sizeof(*(cfp)) == sizeof(rb_control_frame_t))) ||
               ((rb_control_frame_t *)((sp) + (local_size + stack_max)) + 1) >=
                   (cfp))),
          1))) {
    (void)0;
  } else
    vm_stackoverflow();

  ec->cfp = cfp;

  cfp->pc = (VALUE *)pc;
  cfp->iseq = (rb_iseq_t *)iseq;
  cfp->self = self;
  cfp->block_code = ((void *)0);

  for (i = 0; i < local_size; i++) {
    *sp++ = ((VALUE)RUBY_Qnil);
  }

  ((void)0);
  ((void)0);
  ((void)0);
  *sp++ = cref_or_me;
  *sp++ = specval;
  *sp = type;

  cfp->ep = cfp->bp = sp;
  cfp->sp = sp + 1;

  if (0 == 2) {
    rb_vmdebug_stack_dump_raw(rb_current_execution_context(),
                              rb_current_execution_context()->cfp);
  }
# 286 "./vm_insnhelper.c"
  return cfp;
}

rb_control_frame_t *rb_vm_push_frame(rb_execution_context_t *ec,
                                     const rb_iseq_t *iseq, VALUE type,
                                     VALUE self, VALUE specval,
                                     VALUE cref_or_me, const VALUE *pc,
                                     VALUE *sp, int local_size, int stack_max) {
  return vm_push_frame(ec, iseq, type, self, specval, cref_or_me, pc, sp,
                       local_size, stack_max);
}

static inline int vm_pop_frame(rb_execution_context_t *ec,
                               rb_control_frame_t *cfp, const VALUE *ep) {
  VALUE flags = ep[(0)];

  if (0 >= 4)
    rb_gc_verify_internal_consistency();
  if (0 == 2)
    rb_vmdebug_stack_dump_raw(rb_current_execution_context(),
                              rb_current_execution_context()->cfp);

  ec->cfp = ((cfp) + 1);

  return flags & VM_FRAME_FLAG_FINISH;
}

void rb_vm_pop_frame(rb_execution_context_t *ec) {
  vm_pop_frame(ec, ec->cfp, ec->cfp->ep);
}

static inline VALUE rb_arity_error_new(int argc, int min, int max) {
  VALUE err_mess = 0;
  if (min == max) {
    err_mess = rb_sprintf("wrong number of arguments (given %d, expected %d)",
                          argc, min);
  } else if (max == (-1)) {
    err_mess = rb_sprintf("wrong number of arguments (given %d, expected %d+)",
                          argc, min);
  } else {
    err_mess =
        rb_sprintf("wrong number of arguments (given %d, expected %d..%d)",
                   argc, min, max);
  }
  return rb_exc_new_str(rb_eArgError, err_mess);
}

void rb_error_arity(int argc, int min, int max) {
  rb_exc_raise(rb_arity_error_new(argc, min, max));
}

__attribute__((__noinline__)) static void
vm_env_write_slowpath(const VALUE *ep, int index, VALUE v);

static void vm_env_write_slowpath(const VALUE *ep, int index, VALUE v) {

  rb_gc_writebarrier_remember(VM_ENV_ENVVAL(ep));
  VM_FORCE_WRITE(&ep[index], v);
  VM_ENV_FLAGS_UNSET(ep, VM_ENV_FLAG_WB_REQUIRED);
  ((void)0);
}

static inline void vm_env_write(const VALUE *ep, int index, VALUE v) {
  VALUE flags = ep[(0)];
  if ((__builtin_expect(!!((flags & VM_ENV_FLAG_WB_REQUIRED) == 0), 1))) {
    VM_STACK_ENV_WRITE(ep, index, v);
  } else {
    vm_env_write_slowpath(ep, index, v);
  }
}

VALUE
rb_vm_bh_to_procval(const rb_execution_context_t *ec, VALUE block_handler) {
  if (block_handler == 0) {
    return ((VALUE)RUBY_Qnil);
  } else {
    switch (vm_block_handler_type(block_handler)) {
    case block_handler_type_iseq:
    case block_handler_type_ifunc:
      return rb_vm_make_proc(ec, VM_BH_TO_CAPT_BLOCK(block_handler), rb_cProc);
    case block_handler_type_symbol:
      return rb_sym_to_proc(VM_BH_TO_SYMBOL(block_handler));
    case block_handler_type_proc:
      return VM_BH_TO_PROC(block_handler);
    default:
      __builtin_unreachable();
    }
  }
}
# 415 "./vm_insnhelper.c"
static inline struct vm_svar *lep_svar(const rb_execution_context_t *ec,
                                       const VALUE *lep) {
  VALUE svar;

  if (lep && (ec == ((void *)0) || ec->root_lep != lep)) {
    svar = lep[(-2)];
  } else {
    svar = ec->root_svar;
  }

  ((void)0);

  return (struct vm_svar *)svar;
}

static inline void lep_svar_write(const rb_execution_context_t *ec,
                                  const VALUE *lep,
                                  const struct vm_svar *svar) {
  ((void)0);

  if (lep && (ec == ((void *)0) || ec->root_lep != lep)) {
    vm_env_write(lep, (-2), (VALUE)svar);
  } else {
    __extension__({
# 441 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 441 "./vm_insnhelper.c"
      ;
# 441 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 441 "./vm_insnhelper.c"
      ;
      typeof(rb_obj_write((VALUE)(rb_ec_thread_ptr(ec)->self),
                          (VALUE *)(&ec->root_svar), (VALUE)(svar),
                          "./vm_insnhelper.c", 441))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(rb_ec_thread_ptr(ec)->self),
                            (VALUE *)(&ec->root_svar), (VALUE)(svar),
                            "./vm_insnhelper.c", 441));
# 441 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 441 "./vm_insnhelper.c"
      ;
      unaligned_member_access_result;
    });
  }
}

static VALUE lep_svar_get(const rb_execution_context_t *ec, const VALUE *lep,
                          rb_num_t key) {
  const struct vm_svar *svar = lep_svar(ec, lep);

  if ((VALUE)svar == ((VALUE)RUBY_Qfalse) ||
      imemo_type((VALUE)svar) != imemo_svar)
    return ((VALUE)RUBY_Qnil);

  switch (key) {
  case VM_SVAR_LASTLINE:
    return svar->lastline;
  case VM_SVAR_BACKREF:
    return svar->backref;
  default: {
    const VALUE ary = svar->others;

    if (!((VALUE)(ary) != ((VALUE)RUBY_Qnil))) {
      return ((VALUE)RUBY_Qnil);
    } else {
      return rb_ary_entry(ary, key - VM_SVAR_EXTRA_START);
    }
  }
  }
}

static struct vm_svar *svar_new(VALUE obj) {
  return (struct vm_svar *)rb_imemo_new(imemo_svar, ((VALUE)RUBY_Qnil),
                                        ((VALUE)RUBY_Qnil), ((VALUE)RUBY_Qnil),
                                        obj);
}

static void lep_svar_set(const rb_execution_context_t *ec, const VALUE *lep,
                         rb_num_t key, VALUE val) {
  struct vm_svar *svar = lep_svar(ec, lep);

  if ((VALUE)svar == ((VALUE)RUBY_Qfalse) ||
      imemo_type((VALUE)svar) != imemo_svar) {
    lep_svar_write(ec, lep, svar = svar_new((VALUE)svar));
  }

  switch (key) {
  case VM_SVAR_LASTLINE:
    __extension__({
# 487 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 487 "./vm_insnhelper.c"
      ;
# 487 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 487 "./vm_insnhelper.c"
      ;
      typeof(rb_obj_write((VALUE)(svar), (VALUE *)(&svar->lastline),
                          (VALUE)(val), "./vm_insnhelper.c", 487))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(svar), (VALUE *)(&svar->lastline),
                            (VALUE)(val), "./vm_insnhelper.c", 487));
# 487 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 487 "./vm_insnhelper.c"
      ;
      unaligned_member_access_result;
    });
    return;
  case VM_SVAR_BACKREF:
    __extension__({
# 490 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 490 "./vm_insnhelper.c"
      ;
# 490 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 490 "./vm_insnhelper.c"
      ;
      typeof(rb_obj_write((VALUE)(svar), (VALUE *)(&svar->backref),
                          (VALUE)(val), "./vm_insnhelper.c", 490))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(svar), (VALUE *)(&svar->backref),
                            (VALUE)(val), "./vm_insnhelper.c", 490));
# 490 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 490 "./vm_insnhelper.c"
      ;
      unaligned_member_access_result;
    });
    return;
  default: {
    VALUE ary = svar->others;

    if (!((VALUE)(ary) != ((VALUE)RUBY_Qnil))) {
      __extension__({
# 496 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 496 "./vm_insnhelper.c"
        ;
# 496 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 496 "./vm_insnhelper.c"
        ;
        typeof(rb_obj_write((VALUE)(svar), (VALUE *)(&svar->others),
                            (VALUE)(ary = rb_ary_new()), "./vm_insnhelper.c",
                            496)) unaligned_member_access_result =
            (rb_obj_write((VALUE)(svar), (VALUE *)(&svar->others),
                          (VALUE)(ary = rb_ary_new()), "./vm_insnhelper.c",
                          496));
# 496 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 496 "./vm_insnhelper.c"
        ;
        unaligned_member_access_result;
      });
    }
    rb_ary_store(ary, key - VM_SVAR_EXTRA_START, val);
  }
  }
}

static inline VALUE vm_getspecial(const rb_execution_context_t *ec,
                                  const VALUE *lep, rb_num_t key,
                                  rb_num_t type) {
  VALUE val;

  if (type == 0) {
    val = lep_svar_get(ec, lep, key);
  } else {
    VALUE backref = lep_svar_get(ec, lep, VM_SVAR_BACKREF);

    if (type & 0x01) {
      switch (type >> 1) {
      case '&':
        val = rb_reg_last_match(backref);
        break;
      case '`':
        val = rb_reg_match_pre(backref);
        break;
      case '\'':
        val = rb_reg_match_post(backref);
        break;
      case '+':
        val = rb_reg_match_last(backref);
        break;
      default:
        rb_bug("unexpected back-ref");
      }
    } else {
      val = rb_reg_nth_match((int)(type >> 1), backref);
    }
  }
  return val;
}

__attribute__((__pure__)) static rb_callable_method_entry_t *
check_method_entry(VALUE obj, int can_be_svar);
static rb_callable_method_entry_t *check_method_entry(VALUE obj,
                                                      int can_be_svar) {
  if (obj == ((VALUE)RUBY_Qfalse))
    return ((void *)0);

  switch (imemo_type(obj)) {
  case imemo_ment:
    return (rb_callable_method_entry_t *)obj;
  case imemo_cref:
    return ((void *)0);
  case imemo_svar:
    if (can_be_svar) {
      return check_method_entry(((struct vm_svar *)obj)->cref_or_me, 0);
    }
  default:

    return ((void *)0);
  }
}

const rb_callable_method_entry_t *
rb_vm_frame_method_entry(const rb_control_frame_t *cfp) {
  const VALUE *ep = cfp->ep;
  rb_callable_method_entry_t *me;

  while (!VM_ENV_LOCAL_P(ep)) {
    if ((me = check_method_entry(ep[(-2)], 0)) != ((void *)0))
      return me;
    ep = VM_ENV_PREV_EP(ep);
  }

  return check_method_entry(ep[(-2)], 1);
}

static rb_cref_t *method_entry_cref(rb_callable_method_entry_t *me) {
  switch (me->def->type) {
  case VM_METHOD_TYPE_ISEQ:
    return me->def->body.iseq.cref;
  default:
    return ((void *)0);
  }
}

__attribute__((__pure__)) static rb_cref_t *check_cref(VALUE, int);

static rb_cref_t *check_cref(VALUE obj, int can_be_svar) {
  if (obj == ((VALUE)RUBY_Qfalse))
    return ((void *)0);

  switch (imemo_type(obj)) {
  case imemo_ment:
    return method_entry_cref((rb_callable_method_entry_t *)obj);
  case imemo_cref:
    return (rb_cref_t *)obj;
  case imemo_svar:
    if (can_be_svar) {
      return check_cref(((struct vm_svar *)obj)->cref_or_me, 0);
    }
  default:

    return ((void *)0);
  }
}

static inline rb_cref_t *vm_env_cref(const VALUE *ep) {
  rb_cref_t *cref;

  while (!VM_ENV_LOCAL_P(ep)) {
    if ((cref = check_cref(ep[(-2)], 0)) != ((void *)0))
      return cref;
    ep = VM_ENV_PREV_EP(ep);
  }

  return check_cref(ep[(-2)], 1);
}

static int is_cref(const VALUE v, int can_be_svar) {
  if ((((RUBY_T_IMEMO) == RUBY_T_FIXNUM)
           ? (((int)(long)(v)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_IMEMO) == RUBY_T_TRUE)
                 ? ((v) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_IMEMO) == RUBY_T_FALSE)
                       ? ((v) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_IMEMO) == RUBY_T_NIL)
                             ? ((v) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_IMEMO) == RUBY_T_UNDEF)
                                   ? ((v) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_IMEMO) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(v) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   v)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(v) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(v))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_IMEMO) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(v)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         v)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(v) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)(v))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        v)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(v) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(v))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_IMEMO)))) {
    switch (imemo_type(v)) {
    case imemo_cref:
      return 1;
    case imemo_svar:
      if (can_be_svar)
        return is_cref(((struct vm_svar *)v)->cref_or_me, 0);
    default:
      break;
    }
  }
  return 0;
}

static int vm_env_cref_by_cref(const VALUE *ep) {
  while (!VM_ENV_LOCAL_P(ep)) {
    if (is_cref(ep[(-2)], 0))
      return 1;
    ep = VM_ENV_PREV_EP(ep);
  }
  return is_cref(ep[(-2)], 1);
}

static rb_cref_t *
cref_replace_with_duplicated_cref_each_frame(const VALUE *vptr, int can_be_svar,
                                             VALUE parent) {
  const VALUE v = *vptr;
  rb_cref_t *cref, *new_cref;

  if ((((RUBY_T_IMEMO) == RUBY_T_FIXNUM)
           ? (((int)(long)(v)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_IMEMO) == RUBY_T_TRUE)
                 ? ((v) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_IMEMO) == RUBY_T_FALSE)
                       ? ((v) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_IMEMO) == RUBY_T_NIL)
                             ? ((v) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_IMEMO) == RUBY_T_UNDEF)
                                   ? ((v) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_IMEMO) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(v) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   v)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(v) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(v))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_IMEMO) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(v)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         v)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(v) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)(v))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        v)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(v) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(v))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_IMEMO)))) {
    switch (imemo_type(v)) {
    case imemo_cref:
      cref = (rb_cref_t *)v;
      new_cref = vm_cref_dup(cref);
      if (parent) {
        __extension__({
# 671 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 671 "./vm_insnhelper.c"
          ;
# 671 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 671 "./vm_insnhelper.c"
          ;
          typeof(rb_obj_write((VALUE)(parent), (VALUE *)(vptr),
                              (VALUE)(new_cref), "./vm_insnhelper.c", 671))
              unaligned_member_access_result =
                  (rb_obj_write((VALUE)(parent), (VALUE *)(vptr),
                                (VALUE)(new_cref), "./vm_insnhelper.c", 671));
# 671 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 671 "./vm_insnhelper.c"
          ;
          unaligned_member_access_result;
        });
      } else {
        VM_FORCE_WRITE(vptr, (VALUE)new_cref);
      }
      return (rb_cref_t *)new_cref;
    case imemo_svar:
      if (can_be_svar) {
        return cref_replace_with_duplicated_cref_each_frame(
            (const VALUE *)&((struct vm_svar *)v)->cref_or_me, 0, v);
      }
    case imemo_ment:
      rb_bug("cref_replace_with_duplicated_cref_each_frame: unreachable");
    default:
      break;
    }
  }
  return 0;
}

static rb_cref_t *vm_cref_replace_with_duplicated_cref(const VALUE *ep) {
  if (vm_env_cref_by_cref(ep)) {
    rb_cref_t *cref;
    VALUE envval;

    while (!VM_ENV_LOCAL_P(ep)) {
      envval = VM_ENV_ESCAPED_P(ep) ? VM_ENV_ENVVAL(ep) : ((VALUE)RUBY_Qfalse);
      if ((cref = cref_replace_with_duplicated_cref_each_frame(
               &ep[(-2)], 0, envval)) != ((void *)0)) {
        return cref;
      }
      ep = VM_ENV_PREV_EP(ep);
    }
    envval = VM_ENV_ESCAPED_P(ep) ? VM_ENV_ENVVAL(ep) : ((VALUE)RUBY_Qfalse);
    return cref_replace_with_duplicated_cref_each_frame(&ep[(-2)], 1, envval);
  } else {
    rb_bug("vm_cref_dup: unreachable");
  }
}

static rb_cref_t *rb_vm_get_cref(const VALUE *ep) {
  rb_cref_t *cref = vm_env_cref(ep);

  if (cref != ((void *)0)) {
    return cref;
  } else {
    rb_bug("rb_vm_get_cref: unreachable");
  }
}

static const rb_cref_t *vm_get_const_key_cref(const VALUE *ep) {
  const rb_cref_t *cref = rb_vm_get_cref(ep);
  const rb_cref_t *key_cref = cref;

  while (cref) {
    if (((!(((VALUE)(CREF_CLASS(cref)) & RUBY_IMMEDIATE_MASK) ||
            !!(((VALUE)(CREF_CLASS(cref)) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
               0)) &&
          (int)(((struct RBasic *)(CREF_CLASS(cref)))->flags & RUBY_T_MASK) !=
              RUBY_T_NODE)
             ? (((struct RBasic *)((CREF_CLASS(cref))))->flags &
                ((((VALUE)RUBY_FL_SINGLETON))))
             : 0)) {
      return key_cref;
    }
    cref = CREF_NEXT(cref);
  }

  return ((void *)0);
}

void rb_vm_rewrite_cref(rb_cref_t *cref, VALUE old_klass, VALUE new_klass,
                        rb_cref_t **new_cref_ptr) {
  rb_cref_t *new_cref;

  while (cref) {
    if (CREF_CLASS(cref) == old_klass) {
      new_cref = vm_cref_new_use_prev(new_klass, METHOD_VISI_UNDEF, 0, cref, 0);
      *new_cref_ptr = new_cref;
      return;
    }
    new_cref =
        vm_cref_new_use_prev(CREF_CLASS(cref), METHOD_VISI_UNDEF, 0, cref, 0);
    cref = CREF_NEXT(cref);
    *new_cref_ptr = new_cref;
    new_cref_ptr = (rb_cref_t **)&new_cref->next;
  }
  *new_cref_ptr = ((void *)0);
}

static rb_cref_t *vm_cref_push(const rb_execution_context_t *ec, VALUE klass,
                               const VALUE *ep, int pushed_by_eval) {
  rb_cref_t *prev_cref = ((void *)0);

  if (ep) {
    prev_cref = vm_env_cref(ep);
  } else {
    rb_control_frame_t *cfp = vm_get_ruby_level_caller_cfp(ec, ec->cfp);

    if (cfp) {
      prev_cref = vm_env_cref(cfp->ep);
    }
  }

  return vm_cref_new(klass, METHOD_VISI_PUBLIC, 0, prev_cref, pushed_by_eval);
}

static inline VALUE vm_get_cbase(const VALUE *ep) {
  const rb_cref_t *cref = rb_vm_get_cref(ep);
  VALUE klass = ((VALUE)RUBY_Qundef);

  while (cref) {
    if ((klass = CREF_CLASS(cref)) != 0) {
      break;
    }
    cref = CREF_NEXT(cref);
  }

  return klass;
}

static inline VALUE vm_get_const_base(const VALUE *ep) {
  const rb_cref_t *cref = rb_vm_get_cref(ep);
  VALUE klass = ((VALUE)RUBY_Qundef);

  while (cref) {
    if (!CREF_PUSHED_BY_EVAL(cref) && (klass = CREF_CLASS(cref)) != 0) {
      break;
    }
    cref = CREF_NEXT(cref);
  }

  return klass;
}

static inline void vm_check_if_namespace(VALUE klass) {
  if (!(((RUBY_T_CLASS) == RUBY_T_FIXNUM)
            ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_CLASS) == RUBY_T_TRUE)
                  ? ((klass) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_CLASS) == RUBY_T_FALSE)
                        ? ((klass) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_CLASS) == RUBY_T_NIL)
                              ? ((klass) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_CLASS) == RUBY_T_UNDEF)
                                    ? ((klass) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_CLASS) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(klass) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    klass)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(klass) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(klass))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_CLASS) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(klass)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          klass)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(klass) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(klass))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_CLASS))) &&
      !(((RUBY_T_MODULE) == RUBY_T_FIXNUM)
            ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                  ? ((klass) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                        ? ((klass) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_MODULE) == RUBY_T_NIL)
                              ? ((klass) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                    ? ((klass) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(klass) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    klass)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(klass) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(klass))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(klass)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          klass)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(klass) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(klass))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_MODULE)))) {
    rb_raise(rb_eTypeError,
             "%+"
             "l"
             "i"
             "\v"
             " is not a class/module",
             klass);
  }
}

static inline void vm_ensure_not_refinement_module(VALUE self) {
  if ((((RUBY_T_MODULE) == RUBY_T_FIXNUM)
           ? (((int)(long)(self)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                 ? ((self) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                       ? ((self) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_MODULE) == RUBY_T_NIL)
                             ? ((self) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                   ? ((self) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(self) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   self)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(self) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(self))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(self)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         self)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(self) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(self))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        self)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(self) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(self))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_MODULE))) &&
      ((!(((VALUE)(self)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(self) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(self))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((self)))->flags & ((RMODULE_IS_REFINEMENT)))
           : 0)) {
    rb_warn("not defined at the refinement, but at the outer class/module");
  }
}

static inline VALUE vm_get_iclass(rb_control_frame_t *cfp, VALUE klass) {
  return klass;
}

static inline VALUE vm_get_ev_const(rb_execution_context_t *ec,
                                    VALUE orig_klass, ID id, int is_defined) {
  void rb_const_warn_if_deprecated(const rb_const_entry_t *ce, VALUE klass,
                                   ID id);
  VALUE val;

  if (orig_klass == ((VALUE)RUBY_Qnil)) {

    const rb_cref_t *root_cref = rb_vm_get_cref(ec->cfp->ep);
    const rb_cref_t *cref;
    VALUE klass = ((VALUE)RUBY_Qnil);

    while (root_cref && CREF_PUSHED_BY_EVAL(root_cref)) {
      root_cref = CREF_NEXT(root_cref);
    }
    cref = root_cref;
    while (cref && CREF_NEXT(cref)) {
      if (CREF_PUSHED_BY_EVAL(cref)) {
        klass = ((VALUE)RUBY_Qnil);
      } else {
        klass = CREF_CLASS(cref);
      }
      cref = CREF_NEXT(cref);

      if (!!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
        VALUE av, am = 0;
        rb_const_entry_t *ce;
      search_continue:
        if ((ce = rb_const_lookup(klass, id))) {
          rb_const_warn_if_deprecated(ce, klass, id);
          val = ce->value;
          if (val == ((VALUE)RUBY_Qundef)) {
            if (am == klass)
              break;
            am = klass;
            if (is_defined)
              return 1;
            if (rb_autoloading_value(klass, id, &av, ((void *)0)))
              return av;
            rb_autoload_load(klass, id);
            goto search_continue;
          } else {
            if (is_defined) {
              return 1;
            } else {
              return val;
            }
          }
        }
      }
    }

    if (root_cref && !!((VALUE)(CREF_CLASS(root_cref)) != ((VALUE)RUBY_Qnil))) {
      klass = vm_get_iclass(ec->cfp, CREF_CLASS(root_cref));
    } else {
      klass = rb_class_of((VALUE)(ec->cfp->self));
    }

    if (is_defined) {
      return rb_const_defined(klass, id);
    } else {
      return rb_const_get(klass, id);
    }
  } else {
    vm_check_if_namespace(orig_klass);
    if (is_defined) {
      return rb_public_const_defined_from(orig_klass, id);
    } else {
      return rb_public_const_get_from(orig_klass, id);
    }
  }
}

static inline VALUE vm_get_cvar_base(const rb_cref_t *cref,
                                     rb_control_frame_t *cfp) {
  VALUE klass;

  if (!cref) {
    rb_bug("vm_get_cvar_base: no cref");
  }

  while (CREF_NEXT(cref) &&
         (!((VALUE)(CREF_CLASS(cref)) != ((VALUE)RUBY_Qnil)) ||
          ((!(((VALUE)(CREF_CLASS(cref)) & RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(CREF_CLASS(cref)) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                 0)) &&
            (int)(((struct RBasic *)(CREF_CLASS(cref)))->flags & RUBY_T_MASK) !=
                RUBY_T_NODE)
               ? (((struct RBasic *)((CREF_CLASS(cref))))->flags &
                  ((((VALUE)RUBY_FL_SINGLETON))))
               : 0) ||
          CREF_PUSHED_BY_EVAL(cref))) {
    cref = CREF_NEXT(cref);
  }
  if (!CREF_NEXT(cref)) {
    rb_warn("class variable access from toplevel");
  }

  klass = vm_get_iclass(cfp, CREF_CLASS(cref));

  if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eTypeError, "no class variables available");
  }
  return klass;
}

static VALUE vm_search_const_defined_class(const VALUE cbase, ID id) {
  if (rb_const_defined_at(cbase, id))
    return cbase;
  if (cbase == rb_cObject) {
    VALUE tmp = RCLASS_SUPER(cbase);
    while (tmp) {
      if (rb_const_defined_at(tmp, id))
        return tmp;
      tmp = RCLASS_SUPER(tmp);
    }
  }
  return 0;
}

__attribute__((__always_inline__)) static VALUE
vm_getivar(VALUE, ID, IC, struct rb_call_cache *, int);
static inline VALUE vm_getivar(VALUE obj, ID id, IC ic,
                               struct rb_call_cache *cc, int is_attr) {

  if ((__builtin_expect(
          !!((((RUBY_T_OBJECT) == RUBY_T_FIXNUM)
                  ? (((int)(long)(obj)) & RUBY_FIXNUM_FLAG)
                  : ((RUBY_T_OBJECT) == RUBY_T_TRUE)
                        ? ((obj) == ((VALUE)RUBY_Qtrue))
                        : ((RUBY_T_OBJECT) == RUBY_T_FALSE)
                              ? ((obj) == ((VALUE)RUBY_Qfalse))
                              : ((RUBY_T_OBJECT) == RUBY_T_NIL)
                                    ? ((obj) == ((VALUE)RUBY_Qnil))
                                    : ((RUBY_T_OBJECT) == RUBY_T_UNDEF)
                                          ? ((obj) == ((VALUE)RUBY_Qundef))
                                          : ((RUBY_T_OBJECT) == RUBY_T_SYMBOL)
                                                ? ((((VALUE)(obj) &
                                                     ~((~(VALUE)0)
                                                       << RUBY_SPECIAL_SHIFT)) ==
                                                    RUBY_SYMBOL_FLAG) ||
                                                   (!(((VALUE)(
                                                          obj)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(obj) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(obj))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        (RUBY_T_SYMBOL)))
                                                : ((RUBY_T_OBJECT) ==
                                                   RUBY_T_FLOAT)
                                                      ? (((((int)(long)(obj)) &
                                                           RUBY_FLONUM_MASK) ==
                                                          RUBY_FLONUM_FLAG) ||
                                                         (!(((VALUE)(
                                                                obj)&RUBY_IMMEDIATE_MASK) ||
                                                            !!(((VALUE)(obj) &
                                                                (VALUE) ~(
                                                                    (VALUE)
                                                                        RUBY_Qnil)) ==
                                                               0)) &&
                                                          (int)(((struct RBasic
                                                                      *)(obj))
                                                                    ->flags &
                                                                RUBY_T_MASK) ==
                                                              RUBY_T_FLOAT))
                                                      : (!(((VALUE)(
                                                               obj)&RUBY_IMMEDIATE_MASK) ||
                                                           !!(((VALUE)(obj) &
                                                               (VALUE) ~(
                                                                   (VALUE)
                                                                       RUBY_Qnil)) ==
                                                              0)) &&
                                                         (int)(((struct RBasic
                                                                     *)(obj))
                                                                   ->flags &
                                                               RUBY_T_MASK) ==
                                                             (RUBY_T_OBJECT)))),
          1))) {
    VALUE val = ((VALUE)RUBY_Qundef);
    if ((__builtin_expect(
            !!(is_attr ? (cc->aux.index > 0)
                       : (ic->ic_serial ==
                          ((((struct RClass *)(((struct RBasic *)(obj))->klass))
                                ->ptr)
                               ->class_serial))),
            1))) {

      st_index_t index = !is_attr ? ic->ic_value.index : (cc->aux.index - 1);
      if ((__builtin_expect(
              !!(index < ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                              ? ROBJECT_EMBED_LEN_MAX
                              : ((struct RObject *)(obj))->as.heap.numiv)),
              1))) {
        val = ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                   ? ((struct RObject *)(obj))->as.ary
                   : ((struct RObject *)(obj))->as.heap.ivptr)[index];
      }
    } else {
      st_data_t index;
      struct st_table *iv_index_tbl =
          ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
               ? ((((struct RClass *)(rb_obj_class(obj)))->ptr)->iv_index_tbl)
               : ((struct RObject *)(obj))->as.heap.iv_index_tbl);

      if (iv_index_tbl) {
        if (st_lookup(iv_index_tbl, id, &index)) {
          if (index < ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                           ? ROBJECT_EMBED_LEN_MAX
                           : ((struct RObject *)(obj))->as.heap.numiv)) {
            val = ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                       ? ((struct RObject *)(obj))->as.ary
                       : ((struct RObject *)(obj))->as.heap.ivptr)[index];
          }
          if (!is_attr) {
            ic->ic_value.index = index;
            ic->ic_serial =
                ((((struct RClass *)(((struct RBasic *)(obj))->klass))->ptr)
                     ->class_serial);
          } else {
            cc->aux.index = (int)index + 1;
          }
        }
      }
    }
    if ((__builtin_expect(!!(val == ((VALUE)RUBY_Qundef)), 0))) {
      if (!is_attr && !(((VALUE)((*rb_ruby_verbose_ptr())) &
                         (VALUE) ~((VALUE)RUBY_Qnil)) == 0))
        rb_warning("instance variable %"
                   "l"
                   "i"
                   "\v"
                   " not initialized",
                   rb_id_quote_unprintable(id));
      val = ((VALUE)RUBY_Qnil);
    }
    ((void)0);
    return val;
  } else {
    ((void)0);
  }

  ((void)0);

  if (is_attr)
    return rb_attr_get(obj, id);
  return rb_ivar_get(obj, id);
}

static inline VALUE vm_setivar(VALUE obj, ID id, VALUE val, IC ic,
                               struct rb_call_cache *cc, int is_attr) {

  do {
    VALUE frozen_obj = (obj);
    if ((__builtin_expect(
            !!((!(!(((VALUE)(frozen_obj)&RUBY_IMMEDIATE_MASK) ||
                    !!(((VALUE)(frozen_obj) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                       0)) &&
                  (int)(((struct RBasic *)(frozen_obj))->flags & RUBY_T_MASK) !=
                      RUBY_T_NODE) ||
                (((struct RBasic *)(frozen_obj))->flags & RUBY_FL_FREEZE))),
            0))) {
      rb_error_frozen_object(frozen_obj);
    }
  } while (0);

  if ((__builtin_expect(
          !!((((RUBY_T_OBJECT) == RUBY_T_FIXNUM)
                  ? (((int)(long)(obj)) & RUBY_FIXNUM_FLAG)
                  : ((RUBY_T_OBJECT) == RUBY_T_TRUE)
                        ? ((obj) == ((VALUE)RUBY_Qtrue))
                        : ((RUBY_T_OBJECT) == RUBY_T_FALSE)
                              ? ((obj) == ((VALUE)RUBY_Qfalse))
                              : ((RUBY_T_OBJECT) == RUBY_T_NIL)
                                    ? ((obj) == ((VALUE)RUBY_Qnil))
                                    : ((RUBY_T_OBJECT) == RUBY_T_UNDEF)
                                          ? ((obj) == ((VALUE)RUBY_Qundef))
                                          : ((RUBY_T_OBJECT) == RUBY_T_SYMBOL)
                                                ? ((((VALUE)(obj) &
                                                     ~((~(VALUE)0)
                                                       << RUBY_SPECIAL_SHIFT)) ==
                                                    RUBY_SYMBOL_FLAG) ||
                                                   (!(((VALUE)(
                                                          obj)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(obj) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(obj))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        (RUBY_T_SYMBOL)))
                                                : ((RUBY_T_OBJECT) ==
                                                   RUBY_T_FLOAT)
                                                      ? (((((int)(long)(obj)) &
                                                           RUBY_FLONUM_MASK) ==
                                                          RUBY_FLONUM_FLAG) ||
                                                         (!(((VALUE)(
                                                                obj)&RUBY_IMMEDIATE_MASK) ||
                                                            !!(((VALUE)(obj) &
                                                                (VALUE) ~(
                                                                    (VALUE)
                                                                        RUBY_Qnil)) ==
                                                               0)) &&
                                                          (int)(((struct RBasic
                                                                      *)(obj))
                                                                    ->flags &
                                                                RUBY_T_MASK) ==
                                                              RUBY_T_FLOAT))
                                                      : (!(((VALUE)(
                                                               obj)&RUBY_IMMEDIATE_MASK) ||
                                                           !!(((VALUE)(obj) &
                                                               (VALUE) ~(
                                                                   (VALUE)
                                                                       RUBY_Qnil)) ==
                                                              0)) &&
                                                         (int)(((struct RBasic
                                                                     *)(obj))
                                                                   ->flags &
                                                               RUBY_T_MASK) ==
                                                             (RUBY_T_OBJECT)))),
          1))) {
    VALUE klass = ((struct RBasic *)(obj))->klass;
    st_data_t index;

    if ((__builtin_expect(
            !!((!is_attr &&
                (ic->ic_serial ==
                 ((((struct RClass *)(klass))->ptr)->class_serial))) ||
               (is_attr && (cc->aux.index > 0))),
            1))) {

      VALUE *ptr = ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                        ? ((struct RObject *)(obj))->as.ary
                        : ((struct RObject *)(obj))->as.heap.ivptr);
      index = !is_attr ? ic->ic_value.index : cc->aux.index - 1;

      if ((index < ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
                        ? ROBJECT_EMBED_LEN_MAX
                        : ((struct RObject *)(obj))->as.heap.numiv))) {
        __extension__({
# 1025 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 1025 "./vm_insnhelper.c"
          ;
# 1025 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 1025 "./vm_insnhelper.c"
          ;
          typeof(rb_obj_write((VALUE)(obj), (VALUE *)(&ptr[index]),
                              (VALUE)(val), "./vm_insnhelper.c", 1025))
              unaligned_member_access_result =
                  (rb_obj_write((VALUE)(obj), (VALUE *)(&ptr[index]),
                                (VALUE)(val), "./vm_insnhelper.c", 1025));
# 1025 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 1025 "./vm_insnhelper.c"
          ;
          unaligned_member_access_result;
        });
        ((void)0);
        return val;
      }
    } else {
      struct st_table *iv_index_tbl =
          ((((struct RBasic *)(obj))->flags & ROBJECT_EMBED)
               ? ((((struct RClass *)(rb_obj_class(obj)))->ptr)->iv_index_tbl)
               : ((struct RObject *)(obj))->as.heap.iv_index_tbl);

      if (iv_index_tbl && st_lookup(iv_index_tbl, (st_data_t)id, &index)) {
        if (!is_attr) {
          ic->ic_value.index = index;
          ic->ic_serial = ((((struct RClass *)(klass))->ptr)->class_serial);
        } else if (index >= 2147483647) {
          rb_raise(rb_eArgError, "too many instance variables");
        } else {
          cc->aux.index = (int)(index + 1);
        }
      }
    }
  } else {
    ((void)0);
  }

  ((void)0);
  return rb_ivar_set(obj, id, val);
}

static inline VALUE vm_getinstancevariable(VALUE obj, ID id, IC ic) {
  return vm_getivar(obj, id, ic, ((void *)0), 0);
}

static inline void vm_setinstancevariable(VALUE obj, ID id, VALUE val, IC ic) {
  vm_setivar(obj, id, val, ic, 0, 0);
}

static VALUE vm_throw_continue(const rb_execution_context_t *ec, VALUE err) {

  if ((((int)(long)(err)) & RUBY_FIXNUM_FLAG)) {
    ec->tag->state = ((int)rb_fix2int((VALUE)(err)));
  } else if (((((VALUE)(err) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
               RUBY_SYMBOL_FLAG) ||
              (!(((VALUE)(err)&RUBY_IMMEDIATE_MASK) ||
                 !!(((VALUE)(err) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
               (int)(((struct RBasic *)(err))->flags & RUBY_T_MASK) ==
                   (RUBY_T_SYMBOL)))) {
    ec->tag->state = RUBY_TAG_THROW;
  } else if (
      (((RUBY_T_IMEMO) == RUBY_T_FIXNUM)
           ? (((int)(long)((VALUE)(err))) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_IMEMO) == RUBY_T_TRUE)
                 ? (((VALUE)(err)) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_IMEMO) == RUBY_T_FALSE)
                       ? (((VALUE)(err)) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_IMEMO) == RUBY_T_NIL)
                             ? (((VALUE)(err)) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_IMEMO) == RUBY_T_UNDEF)
                                   ? (((VALUE)(err)) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_IMEMO) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)((VALUE)(err)) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)((VALUE)(err)) &
                                                RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)((VALUE)(err)) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)((VALUE)(
                                                        err)))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_IMEMO) == RUBY_T_FLOAT)
                                               ? (((((int)(long)((VALUE)(
                                                        err))) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)((VALUE)(err)) &
                                                      RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)((VALUE)(err)) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)((
                                                              VALUE)(err)))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)((VALUE)(err)) &
                                                     RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)((VALUE)(err)) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)((
                                                             VALUE)(err)))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_IMEMO)))) {
    ec->tag->state = THROW_DATA_STATE((struct vm_throw_data *)err);
  } else {
    ec->tag->state = RUBY_TAG_RAISE;
  }
  return err;
}

static VALUE vm_throw_start(const rb_execution_context_t *ec,
                            rb_control_frame_t *const reg_cfp,
                            enum ruby_tag_type state, const int flag,
                            const VALUE throwobj) {
  const rb_control_frame_t *escape_cfp = ((void *)0);
  const rb_control_frame_t *const eocfp = RUBY_VM_END_CONTROL_FRAME(ec);

  if (flag != 0) {

  } else if (state == RUBY_TAG_BREAK) {
    int is_orphan = 1;
    const VALUE *ep = ((((reg_cfp)->ep)));
    const rb_iseq_t *base_iseq = ((((reg_cfp)))->iseq);
    escape_cfp = reg_cfp;

    while (base_iseq->body->type != ISEQ_TYPE_BLOCK) {
      if (escape_cfp->iseq->body->type == ISEQ_TYPE_CLASS) {
        escape_cfp = ((escape_cfp) + 1);
        ep = escape_cfp->ep;
        base_iseq = escape_cfp->iseq;
      } else {
        ep = VM_ENV_PREV_EP(ep);
        base_iseq = base_iseq->body->parent_iseq;
        escape_cfp = rb_vm_search_cf_from_ep(ec, escape_cfp, ep);
        ((void)0);
      }
    }

    if (VM_FRAME_LAMBDA_P(escape_cfp)) {

      is_orphan = 0;
      state = RUBY_TAG_RETURN;
    } else {
      ep = VM_ENV_PREV_EP(ep);

      while (escape_cfp < eocfp) {
        if (escape_cfp->ep == ep) {
          const rb_iseq_t *const iseq = escape_cfp->iseq;
          const VALUE epc = escape_cfp->pc - iseq->body->iseq_encoded;
          const struct iseq_catch_table *const ct = iseq->body->catch_table;
          unsigned int i;

          if (!ct)
            break;
          for (i = 0; i < ct->size; i++) {
            const struct iseq_catch_table_entry *const entry = &ct->entries[i];

            if (entry->type == CATCH_TYPE_BREAK && entry->iseq == base_iseq &&
                entry->start < epc && entry->end >= epc) {
              if (entry->cont == epc) {
                is_orphan = 0;
              }
              break;
            }
          }
          break;
        }

        escape_cfp = ((escape_cfp) + 1);
      }
    }

    if (is_orphan) {
      rb_vm_localjump_error("break from proc-closure", throwobj,
                            RUBY_TAG_BREAK);
    }
  } else if (state == RUBY_TAG_RETRY) {
    const VALUE *ep = VM_ENV_PREV_EP(((((reg_cfp)->ep))));

    escape_cfp = rb_vm_search_cf_from_ep(ec, reg_cfp, ep);
  } else if (state == RUBY_TAG_RETURN) {
    const VALUE *current_ep = ((((reg_cfp)->ep)));
    const VALUE *target_lep = VM_EP_LEP(current_ep);
    int in_class_frame = 0;
    int toplevel = 1;
    escape_cfp = reg_cfp;

    while (escape_cfp < eocfp) {
      const VALUE *lep = VM_CF_LEP(escape_cfp);

      if (!target_lep) {
        target_lep = lep;
      }

      if (lep == target_lep && VM_FRAME_RUBYFRAME_P(escape_cfp) &&
          escape_cfp->iseq->body->type == ISEQ_TYPE_CLASS) {
        in_class_frame = 1;
        target_lep = 0;
      }

      if (lep == target_lep) {
        if (VM_FRAME_LAMBDA_P(escape_cfp)) {
          toplevel = 0;
          if (in_class_frame) {

            goto valid_return;
          } else {
            const VALUE *tep = current_ep;

            while (target_lep != tep) {
              if (escape_cfp->ep == tep) {

                goto valid_return;
              }
              tep = VM_ENV_PREV_EP(tep);
            }
          }
        } else if (VM_FRAME_RUBYFRAME_P(escape_cfp)) {
          switch (escape_cfp->iseq->body->type) {
          case ISEQ_TYPE_TOP:
          case ISEQ_TYPE_MAIN:
            if (toplevel)
              goto valid_return;
            break;
          case ISEQ_TYPE_EVAL:
          case ISEQ_TYPE_CLASS:
            toplevel = 0;
            break;
          default:
            break;
          }
        }
      }

      if (escape_cfp->ep == target_lep &&
          escape_cfp->iseq->body->type == ISEQ_TYPE_METHOD) {
        goto valid_return;
      }

      escape_cfp = ((escape_cfp) + 1);
    }
    rb_vm_localjump_error("unexpected return", throwobj, RUBY_TAG_RETURN);

  valid_return:;

  } else {
    rb_bug("isns(throw): unsupport throw type");
  }

  ec->tag->state = state;
  return (VALUE)THROW_DATA_NEW(throwobj, escape_cfp, state);
}

static VALUE vm_throw(const rb_execution_context_t *ec,
                      rb_control_frame_t *reg_cfp, rb_num_t throw_state,
                      VALUE throwobj) {
  const int state = (int)(throw_state & VM_THROW_STATE_MASK);
  const int flag = (int)(throw_state & VM_THROW_NO_ESCAPE_FLAG);

  if (state != 0) {
    return vm_throw_start(ec, reg_cfp, state, flag, throwobj);
  } else {
    return vm_throw_continue(ec, throwobj);
  }
}

static inline void vm_expandarray(VALUE *sp, VALUE ary, rb_num_t num,
                                  int flag) {
  int is_splat = flag & 0x01;
  rb_num_t space_size = num + is_splat;
  VALUE *base = sp - 1;
  const VALUE *ptr;
  rb_num_t len;
  const VALUE obj = ary;

  if (!(((RUBY_T_ARRAY) == RUBY_T_FIXNUM)
            ? (((int)(long)(ary)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_ARRAY) == RUBY_T_TRUE)
                  ? ((ary) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_ARRAY) == RUBY_T_FALSE)
                        ? ((ary) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_ARRAY) == RUBY_T_NIL)
                              ? ((ary) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_ARRAY) == RUBY_T_UNDEF)
                                    ? ((ary) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_ARRAY) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(ary) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    ary)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(ary) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(ary))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_ARRAY) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(ary)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          ary)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(ary) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(ary))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         ary)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(ary) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(ary))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_ARRAY))) &&
      !((VALUE)(ary = rb_check_array_type(ary)) != ((VALUE)RUBY_Qnil))) {
    ary = obj;
    ptr = &ary;
    len = 1;
  } else {
    ptr = rb_array_const_ptr_transient(ary);
    len = (rb_num_t)rb_array_len(ary);
  }

  if (space_size == 0) {

  } else if (flag & 0x02) {

    rb_num_t i = 0, j;

    if (len < num) {
      for (i = 0; i < num - len; i++) {
        *base++ = ((VALUE)RUBY_Qnil);
      }
    }
    for (j = 0; i < num; i++, j++) {
      VALUE v = ptr[len - j - 1];
      *base++ = v;
    }
    if (is_splat) {
      *base = rb_ary_new_from_values(len - j, ptr);
    }
  } else {

    rb_num_t i;
    VALUE *bptr = &base[space_size - 1];

    for (i = 0; i < num; i++) {
      if (len <= i) {
        for (; i < num; i++) {
          *bptr-- = ((VALUE)RUBY_Qnil);
        }
        break;
      }
      *bptr-- = ptr[i];
    }
    if (is_splat) {
      if (num > len) {
        *bptr = rb_ary_new();
      } else {
        *bptr = rb_ary_new_from_values(len - num, ptr + num);
      }
    }
  }
  (*__extension__({
    volatile VALUE *rb_gc_guarded_ptr = &(ary);
    __asm__("" : : "m"(rb_gc_guarded_ptr));
    rb_gc_guarded_ptr;
  }));
}

static VALUE vm_call_general(rb_execution_context_t *ec,
                             rb_control_frame_t *reg_cfp,
                             struct rb_calling_info *calling,
                             const struct rb_call_info *ci,
                             struct rb_call_cache *cc);

__attribute__((__visibility__("default"))) extern void
rb_vm_search_method_slowpath(const struct rb_call_info *ci,
                             struct rb_call_cache *cc, VALUE klass) {
  cc->me = rb_callable_method_entry(klass, ci->mid);
  ((void)0);
  cc->call = vm_call_general;

  cc->method_state = (ruby_vm_global_method_state);
  cc->class_serial = ((((struct RClass *)(klass))->ptr)->class_serial);
}

static void vm_search_method(const struct rb_call_info *ci,
                             struct rb_call_cache *cc, VALUE recv) {
  VALUE klass = rb_class_of((VALUE)(recv));

  ((void)0);
  ((void)0);

  if ((__builtin_expect(
          !!(((ruby_vm_global_method_state) == cc->method_state) &&
             (((((struct RClass *)(klass))->ptr)->class_serial) ==
              cc->class_serial)),
          1))) {

    ((void)0);
    ((void)0);
    return;
  }
  ((void)0);

  rb_vm_search_method_slowpath(ci, cc, klass);
}

static inline int check_cfunc(const rb_callable_method_entry_t *me,
                              VALUE (*func)()) {
  if (me && me->def->type == VM_METHOD_TYPE_CFUNC &&
      me->def->body.cfunc.func == func) {
    return 1;
  } else {
    return 0;
  }
}

static inline int vm_method_cfunc_is(CALL_INFO ci, CALL_CACHE cc, VALUE recv,
                                     VALUE (*func)()) {
  vm_search_method(ci, cc, recv);
  return check_cfunc(cc->me, func);
}

static VALUE opt_equal_fallback(VALUE recv, VALUE obj, CALL_INFO ci,
                                CALL_CACHE cc) {
  if (vm_method_cfunc_is(ci, cc, recv, rb_obj_equal)) {
    return recv == obj ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  }

  return ((VALUE)RUBY_Qundef);
}

static inline int comparable_by_identity(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1)) {
    return (((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_EQ)] &
                                   ((1 << 0))) == 0),
                               1))) != 0) *
               2 -
           1;
  }
  if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0)) {
    return (((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_EQ)] &
                                   ((1 << 1))) == 0),
                               1))) != 0) *
               2 -
           1;
  }
  if (((((VALUE)(recv) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
        RUBY_SYMBOL_FLAG) ||
       (!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(recv))->flags & RUBY_T_MASK) ==
            (RUBY_T_SYMBOL))) &&
      ((((VALUE)(obj) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
        RUBY_SYMBOL_FLAG) ||
       (!(((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(obj))->flags & RUBY_T_MASK) ==
            (RUBY_T_SYMBOL)))) {
    return (((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_EQ)] &
                                   ((1 << 6))) == 0),
                               1))) != 0) *
               2 -
           1;
  }
  return 0;
}

static

    inline

    VALUE
    opt_eq_func(VALUE recv, VALUE obj, CALL_INFO ci, CALL_CACHE cc) {
  switch (comparable_by_identity(recv, obj)) {
  case 1:
    return (recv == obj) ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  case -1:
    goto fallback;
  }
  if (0) {
  } else if ((!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
                !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
              (((struct RBasic *)(recv))->klass) == rb_cFloat)) {
    if (((__builtin_expect(
            !!((rb_current_vm()->redefined_flag[(BOP_EQ)] & ((1 << 1))) == 0),
            1)))) {
      return rb_float_equal(recv, obj);
    }
  } else if ((!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
                !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
              (((struct RBasic *)(recv))->klass) == rb_cString)) {
    if (((__builtin_expect(
            !!((rb_current_vm()->redefined_flag[(BOP_EQ)] & ((1 << 2))) == 0),
            1)))) {
      return rb_str_equal(recv, obj);
    }
  }

fallback:
  return opt_equal_fallback(recv, obj, ci, cc);
}

static

    inline

    VALUE
    opt_eql_func(VALUE recv, VALUE obj, CALL_INFO ci, CALL_CACHE cc) {
  switch (comparable_by_identity(recv, obj)) {
  case 1:
    return (recv == obj) ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  case -1:
    goto fallback;
  }
  if (0) {
  } else if ((!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
                !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
              (((struct RBasic *)(recv))->klass) == rb_cFloat)) {
    if (((__builtin_expect(
            !!((rb_current_vm()->redefined_flag[(BOP_EQ)] & ((1 << 1))) == 0),
            1)))) {
      return rb_float_eql(recv, obj);
    }
  } else if ((!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
                !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
              (((struct RBasic *)(recv))->klass) == rb_cString)) {
    if (((__builtin_expect(
            !!((rb_current_vm()->redefined_flag[(BOP_EQ)] & ((1 << 2))) == 0),
            1)))) {
      return rb_str_eql(recv, obj);
    }
  }

fallback:
  return opt_equal_fallback(recv, obj, ci, cc);
}

VALUE
rb_equal_opt(VALUE obj1, VALUE obj2) {
  struct rb_call_info ci;
  struct rb_call_cache cc;

  ci.mid = idEq;
  cc.method_state = 0;
  cc.class_serial = 0;
  cc.me = ((void *)0);
  return opt_eq_func(obj1, obj2, &ci, &cc);
}

VALUE
rb_eql_opt(VALUE obj1, VALUE obj2) {
  struct rb_call_info ci;
  struct rb_call_cache cc;

  ci.mid = idEqlP;
  cc.method_state = 0;
  cc.class_serial = 0;
  cc.me = ((void *)0);
  return opt_eql_func(obj1, obj2, &ci, &cc);
}

extern VALUE rb_vm_call0(rb_execution_context_t *ec, VALUE, ID, int,
                         const VALUE *, const rb_callable_method_entry_t *);

static VALUE check_match(rb_execution_context_t *ec, VALUE pattern,
                         VALUE target, enum vm_check_match_type type) {
  switch (type) {
  case VM_CHECKMATCH_TYPE_WHEN:
    return pattern;
  case VM_CHECKMATCH_TYPE_RESCUE:
    if (!rb_obj_is_kind_of(pattern, rb_cModule)) {
      rb_raise(rb_eTypeError, "class or module required for rescue clause");
    }

  case VM_CHECKMATCH_TYPE_CASE: {
    const rb_callable_method_entry_t *me =
        rb_callable_method_entry_with_refinements(rb_class_of((VALUE)(pattern)),
                                                  idEqq, ((void *)0));
    if (me) {
      return rb_vm_call0(ec, pattern, idEqq, 1, &target, me);
    } else {

      return rb_funcallv(pattern, idEqq, 1, &target);
    }
  }
  default:
    rb_bug("check_match: unreachable");
  }
}
# 1528 "./vm_insnhelper.c"
static inline VALUE double_cmp_lt(double a, double b) {
  ;
  return a < b ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
}

static inline VALUE double_cmp_le(double a, double b) {
  ;
  return a <= b ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
}

static inline VALUE double_cmp_gt(double a, double b) {
  ;
  return a > b ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
}

static inline VALUE double_cmp_ge(double a, double b) {
  ;
  return a >= b ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
}

static VALUE *vm_base_ptr(const rb_control_frame_t *cfp) {
  const rb_control_frame_t *prev_cfp = ((cfp) + 1);

  if (cfp->iseq && VM_FRAME_RUBYFRAME_P(cfp)) {
    VALUE *bp = prev_cfp->sp + cfp->iseq->body->local_table_size + (3);
    if (cfp->iseq->body->type == ISEQ_TYPE_METHOD) {

      bp += 1;
    }
# 1575 "./vm_insnhelper.c"
    return bp;
  } else {
    return ((void *)0);
  }
}

# 1 "./vm_args.c" 1
# 11 "./vm_args.c"
__attribute__((__noreturn__)) static void
raise_argument_error(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                     const VALUE exc);
__attribute__((__noreturn__)) static void
argument_arity_error(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                     const int miss_argc, const int min_argc,
                     const int max_argc);
__attribute__((__noreturn__)) static void
argument_kw_error(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                  const char *error, const VALUE keys);
VALUE rb_keyword_error_new(const char *error, VALUE keys);
static VALUE method_missing(VALUE obj, ID id, int argc, const VALUE *argv,
                            enum method_missing_reason call_status);

struct args_info {

  VALUE *argv;
  int argc;

  int rest_index;
  int rest_dupped;
  const struct rb_call_info_kw_arg *kw_arg;
  VALUE *kw_argv;
  VALUE rest;
};

enum arg_setup_type { arg_setup_method, arg_setup_block };

static inline void arg_rest_dup(struct args_info *args) {
  if (!args->rest_dupped) {
    args->rest = rb_ary_dup(args->rest);
    args->rest_dupped = 1;
  }
}

static inline int args_argc(struct args_info *args) {
  if (args->rest == ((VALUE)RUBY_Qfalse)) {
    return args->argc;
  } else {
    return args->argc + rb_long2int_inline(rb_array_len(args->rest)) -
           args->rest_index;
  }
}

static inline void args_extend(struct args_info *args, const int min_argc) {
  int i;

  if (args->rest) {
    arg_rest_dup(args);
    ((void)0);
    for (i = args->argc + rb_long2int_inline(rb_array_len(args->rest));
         i < min_argc; i++) {
      rb_ary_push(args->rest, ((VALUE)RUBY_Qnil));
    }
  } else {
    for (i = args->argc; i < min_argc; i++) {
      args->argv[args->argc++] = ((VALUE)RUBY_Qnil);
    }
  }
}

static inline void args_reduce(struct args_info *args, int over_argc) {
  if (args->rest) {
    const long len = rb_array_len(args->rest);

    if (len > over_argc) {
      arg_rest_dup(args);
      rb_ary_resize(args->rest, len - over_argc);
      return;
    } else {
      args->rest = ((VALUE)RUBY_Qfalse);
      over_argc -= len;
    }
  }

  ((void)0);
  args->argc -= over_argc;
}

static inline int args_check_block_arg0(struct args_info *args) {
  VALUE ary = ((VALUE)RUBY_Qnil);

  if (args->rest && rb_array_len(args->rest) == 1) {
    VALUE arg0 = (rb_array_const_ptr_transient(args->rest)[0]);
    ary = rb_check_array_type(arg0);
  } else if (args->argc == 1) {
    VALUE arg0 = args->argv[0];
    ary = rb_check_array_type(arg0);
    args->argv[0] = arg0;
  }

  if (!!((VALUE)(ary) != ((VALUE)RUBY_Qnil))) {
    args->rest = ary;
    args->rest_index = 0;
    args->argc = 0;
    return 1;
  }

  return 0;
}

static inline void args_copy(struct args_info *args) {
  if (args->rest != ((VALUE)RUBY_Qfalse)) {
    int argc = args->argc;
    args->argc = 0;
    arg_rest_dup(args);
# 149 "./vm_args.c"
    while (args->rest_index > 0 && argc > 0) {
      do {
        const VALUE _ary = (args->rest);
        const VALUE _v = (args->argv[--argc]);
        VALUE *ptr = (VALUE *)rb_ary_ptr_use_start(_ary);
        __extension__({
# 150 "./vm_args.c"
#pragma clang diagnostic push
# 150 "./vm_args.c"
          ;
# 150 "./vm_args.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 150 "./vm_args.c"
          ;
          typeof(rb_obj_write(
              (VALUE)(_ary), (VALUE *)(&ptr[--args->rest_index]), (VALUE)(_v),
              "./vm_args.c", 150)) unaligned_member_access_result =
              (rb_obj_write((VALUE)(_ary), (VALUE *)(&ptr[--args->rest_index]),
                            (VALUE)(_v), "./vm_args.c", 150));
# 150 "./vm_args.c"
#pragma clang diagnostic pop
# 150 "./vm_args.c"
          ;
          unaligned_member_access_result;
        });
        rb_ary_ptr_use_end(_ary);
      } while (0);
    }
    while (argc > 0) {
      rb_ary_unshift(args->rest, args->argv[--argc]);
    }
  } else if (args->argc > 0) {
    args->rest = rb_ary_new_from_values(args->argc, args->argv);
    args->rest_index = 0;
    args->rest_dupped = 1;
    args->argc = 0;
  }
}

static inline const VALUE *args_rest_argv(struct args_info *args) {
  return rb_array_const_ptr_transient(args->rest) + args->rest_index;
}

static inline VALUE args_rest_array(struct args_info *args) {
  VALUE ary;

  if (args->rest) {
    ary = rb_ary_behead(args->rest, args->rest_index);
    args->rest_index = 0;
    args->rest = 0;
  } else {
    ary = rb_ary_new();
  }
  return ary;
}

static int keyword_hash_p(VALUE *kw_hash_ptr, VALUE *rest_hash_ptr) {
  *rest_hash_ptr = rb_check_hash_type(*kw_hash_ptr);

  if (!!((VALUE)(*rest_hash_ptr) != ((VALUE)RUBY_Qnil))) {
    VALUE hash = rb_extract_keywords(rest_hash_ptr);
    if (!hash)
      hash = ((VALUE)RUBY_Qnil);
    *kw_hash_ptr = hash;
    return 1;
  } else {
    *kw_hash_ptr = ((VALUE)RUBY_Qnil);
    return 0;
  }
}

static VALUE args_pop_keyword_hash(struct args_info *args, VALUE *kw_hash_ptr) {
  VALUE rest_hash;

  if (args->rest == ((VALUE)RUBY_Qfalse)) {
  from_argv:
    ((void)0);
    *kw_hash_ptr = args->argv[args->argc - 1];

    if (keyword_hash_p(kw_hash_ptr, &rest_hash)) {
      if (rest_hash) {
        args->argv[args->argc - 1] = rest_hash;
      } else {
        args->argc--;
        return 1;
      }
    }
  } else {
    long len = rb_array_len(args->rest);

    if (len > 0) {
      *kw_hash_ptr = (rb_array_const_ptr_transient(args->rest)[len - 1]);

      if (keyword_hash_p(kw_hash_ptr, &rest_hash)) {
        if (rest_hash) {
          do {
            const VALUE _ary = (args->rest);
            const VALUE _v = (rest_hash);
            VALUE *ptr = (VALUE *)rb_ary_ptr_use_start(_ary);
            __extension__({
# 231 "./vm_args.c"
#pragma clang diagnostic push
# 231 "./vm_args.c"
              ;
# 231 "./vm_args.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 231 "./vm_args.c"
              ;
              typeof(rb_obj_write((VALUE)(_ary), (VALUE *)(&ptr[len - 1]),
                                  (VALUE)(_v), "./vm_args.c", 231))
                  unaligned_member_access_result =
                      (rb_obj_write((VALUE)(_ary), (VALUE *)(&ptr[len - 1]),
                                    (VALUE)(_v), "./vm_args.c", 231));
# 231 "./vm_args.c"
#pragma clang diagnostic pop
# 231 "./vm_args.c"
              ;
              unaligned_member_access_result;
            });
            rb_ary_ptr_use_end(_ary);
          } while (0);
        } else {
          arg_rest_dup(args);
          rb_ary_pop(args->rest);
          return 1;
        }
      }
    } else {
      goto from_argv;
    }
  }

  return 0;
}

static int args_kw_argv_to_hash(struct args_info *args) {
  const struct rb_call_info_kw_arg *kw_arg = args->kw_arg;
  const VALUE *const passed_keywords = kw_arg->keywords;
  const int kw_len = kw_arg->keyword_len;
  VALUE h = rb_hash_new_with_size(kw_len);
  const int kw_start = args->argc - kw_len;
  const VALUE *const kw_argv = args->argv + kw_start;
  int i;

  args->argc = kw_start + 1;
  for (i = 0; i < kw_len; i++) {
    rb_hash_aset(h, passed_keywords[i], kw_argv[i]);
  }

  args->argv[args->argc - 1] = h;

  return args->argc;
}

static void args_stored_kw_argv_to_hash(struct args_info *args) {
  int i;
  const struct rb_call_info_kw_arg *kw_arg = args->kw_arg;
  const VALUE *const passed_keywords = kw_arg->keywords;
  const int passed_keyword_len = kw_arg->keyword_len;
  VALUE h = rb_hash_new_with_size(passed_keyword_len);

  for (i = 0; i < passed_keyword_len; i++) {
    rb_hash_aset(h, passed_keywords[i], args->kw_argv[i]);
  }
  args->kw_argv = ((void *)0);

  if (args->rest) {
    arg_rest_dup(args);
    rb_ary_push(args->rest, h);
  } else {
    args->argv[args->argc++] = h;
  }
}

static inline void args_setup_lead_parameters(struct args_info *args, int argc,
                                              VALUE *locals) {
  if (args->argc >= argc) {

    args->argc -= argc;
    args->argv += argc;
  } else {
    int i, j;
    const VALUE *argv = args_rest_argv(args);

    for (i = args->argc, j = 0; i < argc; i++, j++) {
      locals[i] = argv[j];
    }
    args->rest_index += argc - args->argc;
    args->argc = 0;
  }
}

static inline void args_setup_post_parameters(struct args_info *args, int argc,
                                              VALUE *locals) {
  long len;
  len = rb_array_len(args->rest);
  __builtin___memcpy_chk(
      (locals), (rb_array_const_ptr_transient(args->rest) + len - argc),
      sizeof(VALUE) * (size_t)(argc), __builtin_object_size((locals), 0));
  rb_ary_resize(args->rest, len - argc);
}

static inline int args_setup_opt_parameters(struct args_info *args, int opt_max,
                                            VALUE *locals) {
  int i;

  if (args->argc >= opt_max) {
    args->argc -= opt_max;
    args->argv += opt_max;
    i = opt_max;
  } else {
    int j;
    i = args->argc;
    args->argc = 0;

    if (args->rest) {
      int len = rb_long2int_inline(rb_array_len(args->rest));
      const VALUE *argv = rb_array_const_ptr_transient(args->rest);

      for (; i < opt_max && args->rest_index < len; i++, args->rest_index++) {
        locals[i] = argv[args->rest_index];
      }
    }

    for (j = i; j < opt_max; j++) {
      locals[j] = ((VALUE)RUBY_Qnil);
    }
  }

  return i;
}

static inline void args_setup_rest_parameter(struct args_info *args,
                                             VALUE *locals) {
  *locals = args_rest_array(args);
}

static VALUE make_unknown_kw_hash(const VALUE *passed_keywords,
                                  int passed_keyword_len,
                                  const VALUE *kw_argv) {
  int i;
  VALUE obj = rb_ary_tmp_new(1);

  for (i = 0; i < passed_keyword_len; i++) {
    if (kw_argv[i] != ((VALUE)RUBY_Qundef)) {
      rb_ary_push(obj, passed_keywords[i]);
    }
  }
  return obj;
}

static VALUE make_rest_kw_hash(const VALUE *passed_keywords,
                               int passed_keyword_len, const VALUE *kw_argv) {
  int i;
  VALUE obj = rb_hash_new_with_size(passed_keyword_len);

  for (i = 0; i < passed_keyword_len; i++) {
    if (kw_argv[i] != ((VALUE)RUBY_Qundef)) {
      rb_hash_aset(obj, passed_keywords[i], kw_argv[i]);
    }
  }
  return obj;
}

static inline int args_setup_kw_parameters_lookup(
    const ID key, VALUE *ptr, const VALUE *const passed_keywords,
    VALUE *passed_values, const int passed_keyword_len) {
  int i;
  const VALUE keyname = (rb_id2sym(key));

  for (i = 0; i < passed_keyword_len; i++) {
    if (keyname == passed_keywords[i]) {
      *ptr = passed_values[i];
      passed_values[i] = ((VALUE)RUBY_Qundef);
      return 1;
    }
  }

  return 0;
}

static void args_setup_kw_parameters(rb_execution_context_t *const ec,
                                     const rb_iseq_t *const iseq,
                                     VALUE *const passed_values,
                                     const int passed_keyword_len,
                                     const VALUE *const passed_keywords,
                                     VALUE *const locals) {
  const ID *acceptable_keywords = iseq->body->param.keyword->table;
  const int req_key_num = iseq->body->param.keyword->required_num;
  const int key_num = iseq->body->param.keyword->num;
  const VALUE *const default_values = iseq->body->param.keyword->default_values;
  VALUE missing = 0;
  int i, di, found = 0;
  int unspecified_bits = 0;
  VALUE unspecified_bits_value = ((VALUE)RUBY_Qnil);

  for (i = 0; i < req_key_num; i++) {
    ID key = acceptable_keywords[i];
    if (args_setup_kw_parameters_lookup(key, &locals[i], passed_keywords,
                                        passed_values, passed_keyword_len)) {
      found++;
    } else {
      if (!missing)
        missing = rb_ary_tmp_new(1);
      rb_ary_push(missing, (rb_id2sym(key)));
    }
  }

  if (missing)
    argument_kw_error(ec, iseq, "missing", missing);

  for (di = 0; i < key_num; i++, di++) {
    if (args_setup_kw_parameters_lookup(acceptable_keywords[i], &locals[i],
                                        passed_keywords, passed_values,
                                        passed_keyword_len)) {
      found++;
    } else {
      if (default_values[di] == ((VALUE)RUBY_Qundef)) {
        locals[i] = ((VALUE)RUBY_Qnil);

        if ((__builtin_expect(!!(i < (32 - 1)), 1))) {
          unspecified_bits |= 0x01 << di;
        } else {
          if (!((VALUE)(unspecified_bits_value) != ((VALUE)RUBY_Qnil))) {

            int j;
            unspecified_bits_value = rb_hash_new();

            for (j = 0; j < (32 - 1); j++) {
              if (unspecified_bits & (0x01 << j)) {
                rb_hash_aset(unspecified_bits_value,
                             (((VALUE)(j)) << 1 | RUBY_FIXNUM_FLAG),
                             ((VALUE)RUBY_Qtrue));
              }
            }
          }
          rb_hash_aset(unspecified_bits_value,
                       (((VALUE)(di)) << 1 | RUBY_FIXNUM_FLAG),
                       ((VALUE)RUBY_Qtrue));
        }
      } else {
        locals[i] = default_values[di];
      }
    }
  }

  if (iseq->body->param.flags.has_kwrest) {
    const int rest_hash_index = key_num + 1;
    locals[rest_hash_index] =
        make_rest_kw_hash(passed_keywords, passed_keyword_len, passed_values);
  } else {
    if (found != passed_keyword_len) {
      VALUE keys = make_unknown_kw_hash(passed_keywords, passed_keyword_len,
                                        passed_values);
      argument_kw_error(ec, iseq, "unknown", keys);
    }
  }

  if (!((VALUE)(unspecified_bits_value) != ((VALUE)RUBY_Qnil))) {
    unspecified_bits_value =
        (((VALUE)(unspecified_bits)) << 1 | RUBY_FIXNUM_FLAG);
  }
  locals[key_num] = unspecified_bits_value;
}

static inline void args_setup_kw_rest_parameter(VALUE keyword_hash,
                                                VALUE *locals) {
  locals[0] = !((VALUE)(keyword_hash) != ((VALUE)RUBY_Qnil))
                  ? rb_hash_new()
                  : rb_hash_dup(keyword_hash);
}

static inline void args_setup_block_parameter(const rb_execution_context_t *ec,
                                              struct rb_calling_info *calling,
                                              VALUE *locals) {
  VALUE block_handler = calling->block_handler;
  *locals = rb_vm_bh_to_procval(ec, block_handler);
}

struct fill_values_arg {
  VALUE *keys;
  VALUE *vals;
  int argc;
};

static int fill_keys_values(st_data_t key, st_data_t val, st_data_t ptr) {
  struct fill_values_arg *arg = (struct fill_values_arg *)ptr;
  int i = arg->argc++;
  arg->keys[i] = (VALUE)key;
  arg->vals[i] = (VALUE)val;
  return ST_CONTINUE;
}

static int setup_parameters_complex(rb_execution_context_t *const ec,
                                    const rb_iseq_t *const iseq,
                                    struct rb_calling_info *const calling,
                                    const struct rb_call_info *ci,
                                    VALUE *const locals,
                                    const enum arg_setup_type arg_setup_type) {
  const int min_argc = iseq->body->param.lead_num + iseq->body->param.post_num;
  const int max_argc = (iseq->body->param.flags.has_rest == 0)
                           ? min_argc + iseq->body->param.opt_num
                           : (-1);
  int opt_pc = 0;
  int given_argc;
  int kw_splat = 0;
  struct args_info args_body, *args;
  VALUE keyword_hash = ((VALUE)RUBY_Qnil);
  VALUE *const orig_sp = ec->cfp->sp;
  unsigned int i;
# 542 "./vm_args.c"
  for (i = calling->argc; i < iseq->body->param.size; i++) {
    locals[i] = ((VALUE)RUBY_Qnil);
  }
  ec->cfp->sp = &locals[i];

  args = &args_body;
  given_argc = args->argc = calling->argc;
  args->argv = locals;
  args->rest_dupped = 0;

  if (ci->flag & (0x01 << VM_CALL_KWARG_bit)) {
    args->kw_arg = ((struct rb_call_info_with_kwarg *)ci)->kw_arg;

    if (iseq->body->param.flags.has_kw) {
      int kw_len = args->kw_arg->keyword_len;

      args->kw_argv = (VALUE *)__builtin_alloca_with_align(
          (sizeof(VALUE) * (kw_len)), _Alignof(VALUE) * 8);
      args->argc -= kw_len;
      given_argc -= kw_len;
      __builtin___memcpy_chk((args->kw_argv), (locals + args->argc),
                             sizeof(VALUE) * (size_t)(kw_len),
                             __builtin_object_size((args->kw_argv), 0));
    } else {
      args->kw_argv = ((void *)0);
      given_argc = args_kw_argv_to_hash(args);
    }
  } else {
    args->kw_arg = ((void *)0);
    args->kw_argv = ((void *)0);
  }

  if (ci->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit)) {
    args->rest = locals[--args->argc];
    args->rest_index = 0;
    given_argc += rb_long2int_inline(rb_array_len(args->rest)) - 1;
  } else {
    args->rest = ((VALUE)RUBY_Qfalse);
  }

  switch (arg_setup_type) {
  case arg_setup_method:
    break;
  case arg_setup_block:
    if (given_argc == 1 &&
        (min_argc > 0 || iseq->body->param.opt_num > 1 ||
         iseq->body->param.flags.has_kw ||
         iseq->body->param.flags.has_kwrest) &&
        !iseq->body->param.flags.ambiguous_param0 &&
        args_check_block_arg0(args)) {
      given_argc = rb_long2int_inline(rb_array_len(args->rest));
    }
    break;
  }

  if (given_argc < min_argc) {
    if (given_argc == min_argc - 1 && args->kw_argv) {
      args_stored_kw_argv_to_hash(args);
      given_argc = args_argc(args);
    } else {
      if (arg_setup_type == arg_setup_block) {
        if ((__builtin_expect(
                !!(!(!(1 / !!(sizeof(*((ec->cfp)->sp)) == sizeof(VALUE))) ||
                     !(1 /
                       !!(sizeof(*(ec->cfp)) == sizeof(rb_control_frame_t))) ||
                     ((rb_control_frame_t *)(((ec->cfp)->sp) + (min_argc)) +
                      1) >= (ec->cfp))),
                1))) {
          (void)0;
        } else
          vm_stackoverflow();
        given_argc = min_argc;
        args_extend(args, min_argc);
      } else {
        argument_arity_error(ec, iseq, given_argc, min_argc, max_argc);
      }
    }
  }

  if (ci->flag & (0x01 << VM_CALL_KW_SPLAT_bit)) {
    kw_splat = !iseq->body->param.flags.has_rest;
  }
  if (given_argc > min_argc &&
      (iseq->body->param.flags.has_kw || iseq->body->param.flags.has_kwrest ||
       (kw_splat && given_argc > max_argc)) &&
      args->kw_argv == ((void *)0)) {
    if (args_pop_keyword_hash(args, &keyword_hash)) {
      given_argc--;
    }
  }

  if (given_argc > max_argc && max_argc != (-1)) {
    if (arg_setup_type == arg_setup_block) {

      args_reduce(args, given_argc - max_argc);
      given_argc = max_argc;
    } else {
      argument_arity_error(ec, iseq, given_argc, min_argc, max_argc);
    }
  }

  if (iseq->body->param.flags.has_lead) {
    args_setup_lead_parameters(args, iseq->body->param.lead_num, locals + 0);
  }

  if (iseq->body->param.flags.has_rest || iseq->body->param.flags.has_post) {
    args_copy(args);
  }

  if (iseq->body->param.flags.has_post) {
    args_setup_post_parameters(args, iseq->body->param.post_num,
                               locals + iseq->body->param.post_start);
  }

  if (iseq->body->param.flags.has_opt) {
    int opt = args_setup_opt_parameters(args, iseq->body->param.opt_num,
                                        locals + iseq->body->param.lead_num);
    opt_pc = (int)iseq->body->param.opt_table[opt];
  }

  if (iseq->body->param.flags.has_rest) {
    args_setup_rest_parameter(args, locals + iseq->body->param.rest_start);
  }

  if (iseq->body->param.flags.has_kw) {
    VALUE *const klocals = locals + iseq->body->param.keyword->bits_start -
                           iseq->body->param.keyword->num;

    if (args->kw_argv != ((void *)0)) {
      const struct rb_call_info_kw_arg *kw_arg = args->kw_arg;
      args_setup_kw_parameters(ec, iseq, args->kw_argv, kw_arg->keyword_len,
                               kw_arg->keywords, klocals);
    } else if (!!((VALUE)(keyword_hash) != ((VALUE)RUBY_Qnil))) {
      int kw_len = rb_long2int_inline(
          ((!(((struct RBasic *)((keyword_hash)))->flags &
              (RHASH_ST_TABLE_FLAG)))
               ? ((unsigned int)((((struct RBasic *)(keyword_hash))->flags &
                                  (VALUE)RHASH_ARRAY_SIZE_MASK) >>
                                 RHASH_ARRAY_SIZE_SHIFT))
               : ((((struct RHash *)(keyword_hash))->as.st)->num_entries)));
      struct fill_values_arg arg;

      arg.keys = args->kw_argv = (VALUE *)__builtin_alloca_with_align(
          (sizeof(VALUE) * (kw_len * 2)), _Alignof(VALUE) * 8);
      arg.vals = arg.keys + kw_len;
      arg.argc = 0;
      rb_hash_foreach(keyword_hash, fill_keys_values, (VALUE)&arg);
      ((void)0);
      args_setup_kw_parameters(ec, iseq, arg.vals, kw_len, arg.keys, klocals);
    } else {
      ((void)0);
      args_setup_kw_parameters(ec, iseq, ((void *)0), 0, ((void *)0), klocals);
    }
  } else if (iseq->body->param.flags.has_kwrest) {
    args_setup_kw_rest_parameter(
        keyword_hash, locals + iseq->body->param.keyword->rest_start);
  } else if (!!((VALUE)(keyword_hash) != ((VALUE)RUBY_Qnil)) &&
             ((!(((struct RBasic *)((keyword_hash)))->flags &
                 (RHASH_ST_TABLE_FLAG)))
                  ? ((unsigned int)((((struct RBasic *)(keyword_hash))->flags &
                                     (VALUE)RHASH_ARRAY_SIZE_MASK) >>
                                    RHASH_ARRAY_SIZE_SHIFT))
                  : ((((struct RHash *)(keyword_hash))->as.st)->num_entries)) >
                 0) {
    argument_kw_error(ec, iseq, "unknown", rb_hash_keys(keyword_hash));
  } else if (kw_splat && !((VALUE)(keyword_hash) != ((VALUE)RUBY_Qnil))) {
    if (!(((VALUE)((*rb_ruby_verbose_ptr())) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
          0)) {
      VALUE path = rb_iseq_path(iseq);
      VALUE line = rb_iseq_first_lineno(iseq);
      VALUE label = rb_iseq_label(iseq);
      rb_compile_warning(
          !((VALUE)(path) != ((VALUE)RUBY_Qnil))
              ? ((void *)0)
              : (!(((struct RBasic *)(path))->flags & RSTRING_NOEMBED)
                     ? ((struct RString *)(path))->as.ary
                     : ((struct RString *)(path))->as.heap.ptr),
          ((int)rb_fix2int((VALUE)(line))),
          "in `%s': the last argument was passed as a single Hash",
          !((VALUE)(label) != ((VALUE)RUBY_Qnil))
              ? ((void *)0)
              : (!(((struct RBasic *)(label))->flags & RSTRING_NOEMBED)
                     ? ((struct RString *)(label))->as.ary
                     : ((struct RString *)(label))->as.heap.ptr));
      rb_warning("although a splat keyword arguments here");
    }
  }

  if (iseq->body->param.flags.has_block) {
    if (iseq->body->local_iseq == iseq) {

    } else {
      args_setup_block_parameter(ec, calling,
                                 locals + iseq->body->param.block_start);
    }
  }
# 718 "./vm_args.c"
  ec->cfp->sp = orig_sp;
  return opt_pc;
}

void rb_backtrace_use_iseq_first_lineno_for_last_location(VALUE self);

static void raise_argument_error(rb_execution_context_t *ec,
                                 const rb_iseq_t *iseq, const VALUE exc) {
  VALUE at;

  if (iseq) {
    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL,
                  ((VALUE)RUBY_Qnil), 0, ((VALUE)RUBY_Qfalse),
                  iseq->body->iseq_encoded, ec->cfp->sp, 0, 0);
    at = rb_ec_backtrace_object(ec);
    rb_backtrace_use_iseq_first_lineno_for_last_location(at);
    rb_vm_pop_frame(ec);
  } else {
    at = rb_ec_backtrace_object(ec);
  }

  rb_ivar_set(exc, idBt_locations, at);
  rb_exc_set_backtrace(exc, at);
  rb_exc_raise(exc);
}

static void argument_arity_error(rb_execution_context_t *ec,
                                 const rb_iseq_t *iseq, const int miss_argc,
                                 const int min_argc, const int max_argc) {
  VALUE exc = rb_arity_error_new(miss_argc, min_argc, max_argc);
  if (iseq->body->param.flags.has_kw) {
    const struct rb_iseq_param_keyword *const kw = iseq->body->param.keyword;
    const ID *keywords = kw->table;
    int req_key_num = kw->required_num;
    if (req_key_num > 0) {
      static const char required[] = "; required keywords";
      VALUE mesg = rb_attr_get(exc, idMesg);
      rb_str_resize(mesg, (!(((struct RBasic *)(mesg))->flags & RSTRING_NOEMBED)
                               ? (long)((((struct RBasic *)(mesg))->flags >>
                                         RSTRING_EMBED_LEN_SHIFT) &
                                        (RSTRING_EMBED_LEN_MASK >>
                                         RSTRING_EMBED_LEN_SHIFT))
                               : ((struct RString *)(mesg))->as.heap.len) -
                              1);
      rb_str_cat(mesg, required, sizeof(required) - 1 - (req_key_num == 1));
      __extension__({
        (__builtin_constant_p(":"))
            ? rb_str_cat((mesg), (":"), (long)strlen(":"))
            : rb_str_cat_cstr((mesg), (":"));
      });
      do {
        __extension__({
          (__builtin_constant_p(" "))
              ? rb_str_cat((mesg), (" "), (long)strlen(" "))
              : rb_str_cat_cstr((mesg), (" "));
        });
        rb_str_append(mesg, rb_id2str(*keywords++));
        __extension__({
          (__builtin_constant_p(","))
              ? rb_str_cat((mesg), (","), (long)strlen(","))
              : rb_str_cat_cstr((mesg), (","));
        });
      } while (--req_key_num);
      (!(((struct RBasic *)(mesg))->flags & RSTRING_NOEMBED)
           ? ((struct RString *)(mesg))->as.ary
           : ((struct RString *)(mesg))->as.heap.ptr)
          [(!(((struct RBasic *)(mesg))->flags & RSTRING_NOEMBED)
                ? (long)((((struct RBasic *)(mesg))->flags >>
                          RSTRING_EMBED_LEN_SHIFT) &
                         (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT))
                : ((struct RString *)(mesg))->as.heap.len) -
           1] = ')';
    }
  }
  raise_argument_error(ec, iseq, exc);
}

static void argument_kw_error(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                              const char *error, const VALUE keys) {
  raise_argument_error(ec, iseq, rb_keyword_error_new(error, keys));
}

static inline void vm_caller_setup_arg_splat(rb_control_frame_t *cfp,
                                             struct rb_calling_info *calling) {
  int argc = calling->argc;
  VALUE *argv = cfp->sp - argc;
  VALUE ary = argv[argc - 1];

  cfp->sp--;

  if (!!((VALUE)(ary) != ((VALUE)RUBY_Qnil))) {
    const VALUE *ptr = rb_array_const_ptr_transient(ary);
    long len = rb_array_len(ary), i;

    if ((__builtin_expect(
            !!(!(!(1 / !!(sizeof(*((cfp)->sp)) == sizeof(VALUE))) ||
                 !(1 / !!(sizeof(*(cfp)) == sizeof(rb_control_frame_t))) ||
                 ((rb_control_frame_t *)(((cfp)->sp) + (len)) + 1) >= (cfp))),
            1))) {
      (void)0;
    } else
      vm_stackoverflow();

    for (i = 0; i < len; i++) {
      *cfp->sp++ = ptr[i];
    }
    calling->argc += i - 1;
  }
}

static inline void vm_caller_setup_arg_kw(rb_control_frame_t *cfp,
                                          struct rb_calling_info *calling,
                                          const struct rb_call_info *ci) {
  struct rb_call_info_with_kwarg *ci_kw = (struct rb_call_info_with_kwarg *)ci;
  const VALUE *const passed_keywords = ci_kw->kw_arg->keywords;
  const int kw_len = ci_kw->kw_arg->keyword_len;
  const VALUE h = rb_hash_new_with_size(kw_len);
  VALUE *sp = cfp->sp;
  int i;

  for (i = 0; i < kw_len; i++) {
    rb_hash_aset(h, passed_keywords[i], (sp - kw_len)[i]);
  }
  (sp - kw_len)[0] = h;

  cfp->sp -= kw_len - 1;
  calling->argc -= kw_len - 1;
}

static VALUE vm_to_proc(VALUE proc) {
  if ((__builtin_expect(!!(!rb_obj_is_proc(proc)), 0))) {
    VALUE b;
    const rb_callable_method_entry_t *me =
        rb_callable_method_entry_with_refinements(rb_class_of((VALUE)(proc)),
                                                  idTo_proc, ((void *)0));

    if (me) {
      b = rb_vm_call0(rb_current_execution_context(), proc, idTo_proc, 0,
                      ((void *)0), me);
    } else {

      b = rb_check_convert_type_with_id(proc, RUBY_T_DATA, "Proc", idTo_proc);
    }

    if (!((VALUE)(b) != ((VALUE)RUBY_Qnil)) || !rb_obj_is_proc(b)) {
      rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
               rb_obj_classname(proc));
    }
    return b;
  } else {
    return proc;
  }
}

static VALUE refine_sym_proc_call(VALUE yielded_arg, VALUE callback_arg,
                                  int argc, const VALUE *argv, VALUE blockarg) {
  VALUE obj;
  ID mid;
  const rb_callable_method_entry_t *me;
  rb_execution_context_t *ec;

  if (argc-- < 1) {
    rb_raise(rb_eArgError, "no receiver given");
  }
  obj = *argv++;
  mid = (rb_sym2id(callback_arg));
  me = rb_callable_method_entry_with_refinements(rb_class_of((VALUE)(obj)), mid,
                                                 ((void *)0));
  ec = rb_current_execution_context();
  if (!!((VALUE)(blockarg) != ((VALUE)RUBY_Qnil))) {
    vm_passed_block_handler_set(ec, blockarg);
  }
  if (!me) {
    return method_missing(obj, mid, argc, argv, MISSING_NOENTRY);
  }
  return rb_vm_call0(ec, obj, mid, argc, argv, me);
}

static VALUE vm_caller_setup_arg_block(const rb_execution_context_t *ec,
                                       rb_control_frame_t *reg_cfp,
                                       const struct rb_call_info *ci,
                                       rb_iseq_t *blockiseq,
                                       const int is_super) {
  if (ci->flag & (0x01 << VM_CALL_ARGS_BLOCKARG_bit)) {
    VALUE block_code = *(--reg_cfp->sp);

    if (!((VALUE)(block_code) != ((VALUE)RUBY_Qnil))) {
      return 0;
    } else if (block_code == rb_block_param_proxy) {
      return VM_CF_BLOCK_HANDLER(reg_cfp);
    } else if (((((VALUE)(block_code) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
                 RUBY_SYMBOL_FLAG) ||
                (!(((VALUE)(block_code)&RUBY_IMMEDIATE_MASK) ||
                   !!(((VALUE)(block_code) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                      0)) &&
                 (int)(((struct RBasic *)(block_code))->flags & RUBY_T_MASK) ==
                     (RUBY_T_SYMBOL))) &&
               rb_method_basic_definition_p(rb_cSymbol, idTo_proc)) {
      const rb_cref_t *cref = vm_env_cref(reg_cfp->ep);
      if (cref && !!((VALUE)(cref->refinements) != ((VALUE)RUBY_Qnil))) {
        VALUE ref = cref->refinements;
        VALUE func = rb_hash_lookup(ref, block_code);
        if (!((VALUE)(func) != ((VALUE)RUBY_Qnil))) {

          func = rb_func_proc_new(refine_sym_proc_call, block_code);
          rb_hash_aset(ref, block_code, func);
        }
        block_code = func;
      }
      return block_code;
    } else {
      return vm_to_proc(block_code);
    }
  } else if (blockiseq != ((void *)0)) {
    struct rb_captured_block *captured = VM_CFP_TO_CAPTURED_BLOCK(reg_cfp);
    captured->code.iseq = blockiseq;
    return VM_BH_FROM_ISEQ_BLOCK(captured);
  } else {
    if (is_super) {
      return ((VM_EP_LEP(((((reg_cfp)->ep)))))[(-1)]);
    } else {
      return 0;
    }
  }
}
# 1585 "./vm_insnhelper.c" 2

static inline VALUE vm_call_iseq_setup_2(rb_execution_context_t *ec,
                                         rb_control_frame_t *cfp,
                                         struct rb_calling_info *calling,
                                         const struct rb_call_info *ci,
                                         struct rb_call_cache *cc, int opt_pc,
                                         int param_size, int local_size);
__attribute__((__always_inline__)) static VALUE
vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                          struct rb_calling_info *calling,
                          const rb_callable_method_entry_t *me, int opt_pc,
                          int param_size, int local_size);
static inline VALUE vm_call_iseq_setup_tailcall(rb_execution_context_t *ec,
                                                rb_control_frame_t *cfp,
                                                struct rb_calling_info *calling,
                                                const struct rb_call_info *ci,
                                                struct rb_call_cache *cc,
                                                int opt_pc);
static VALUE vm_call_super_method(rb_execution_context_t *ec,
                                  rb_control_frame_t *reg_cfp,
                                  struct rb_calling_info *calling,
                                  const struct rb_call_info *ci,
                                  struct rb_call_cache *cc);
static VALUE vm_call_method_nome(rb_execution_context_t *ec,
                                 rb_control_frame_t *cfp,
                                 struct rb_calling_info *calling,
                                 const struct rb_call_info *ci,
                                 struct rb_call_cache *cc);
static VALUE vm_call_method_each_type(rb_execution_context_t *ec,
                                      rb_control_frame_t *cfp,
                                      struct rb_calling_info *calling,
                                      const struct rb_call_info *ci,
                                      struct rb_call_cache *cc);
static inline VALUE vm_call_method(rb_execution_context_t *ec,
                                   rb_control_frame_t *cfp,
                                   struct rb_calling_info *calling,
                                   const struct rb_call_info *ci,
                                   struct rb_call_cache *cc);

static vm_call_handler vm_call_iseq_setup_func(const struct rb_call_info *ci,
                                               const int param_size,
                                               const int local_size);

static VALUE vm_call_iseq_setup_tailcall_0start(rb_execution_context_t *ec,
                                                rb_control_frame_t *cfp,
                                                struct rb_calling_info *calling,
                                                const struct rb_call_info *ci,
                                                struct rb_call_cache *cc) {
  return vm_call_iseq_setup_tailcall(ec, cfp, calling, ci, cc, 0);
}

static VALUE vm_call_iseq_setup_normal_0start(rb_execution_context_t *ec,
                                              rb_control_frame_t *cfp,
                                              struct rb_calling_info *calling,
                                              const struct rb_call_info *ci,
                                              struct rb_call_cache *cc) {
  const rb_iseq_t *iseq = def_iseq_ptr(cc->me->def);
  int param = iseq->body->param.size;
  int local = iseq->body->local_table_size;
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, param, local);
}

int rb_simple_iseq_p(const rb_iseq_t *iseq) {
  return iseq->body->param.flags.has_opt == 0 &&
         iseq->body->param.flags.has_rest == 0 &&
         iseq->body->param.flags.has_post == 0 &&
         iseq->body->param.flags.has_kw == 0 &&
         iseq->body->param.flags.has_kwrest == 0 &&
         iseq->body->param.flags.has_block == 0;
}

static inline int vm_callee_setup_arg(rb_execution_context_t *ec,
                                      struct rb_calling_info *calling,
                                      const struct rb_call_info *ci,
                                      struct rb_call_cache *cc,
                                      const rb_iseq_t *iseq, VALUE *argv,
                                      int param_size, int local_size) {
  if ((__builtin_expect(!!(rb_simple_iseq_p(iseq) &&
                           !(ci->flag & (0x01 << VM_CALL_KW_SPLAT_bit))),
                        1))) {
    rb_control_frame_t *cfp = ec->cfp;

    do {
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                            0)))
        vm_caller_setup_arg_splat((cfp), (calling));
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
        vm_caller_setup_arg_kw((cfp), (calling), (ci));
    } while (0);

    if (calling->argc != iseq->body->param.lead_num) {
      argument_arity_error(ec, iseq, calling->argc, iseq->body->param.lead_num,
                           iseq->body->param.lead_num);
    }

    do {
      if ((__builtin_expect(
              !!((!((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit)) &&
                  !((ci)->flag & (0x01 << VM_CALL_KWARG_bit)) &&
                  !((rb_method_visibility_t)(
                        ((cc->me)->flags &
                         (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
                        ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)) ==
                    METHOD_VISI_PROTECTED))),
              1)))
        ((cc)->call = (vm_call_iseq_setup_func(ci, param_size, local_size)));
    } while (0);

    return 0;
  } else {
    return setup_parameters_complex(ec, iseq, calling, ci, argv,
                                    arg_setup_method);
  }
}

static VALUE vm_call_iseq_setup(rb_execution_context_t *ec,
                                rb_control_frame_t *cfp,
                                struct rb_calling_info *calling,
                                const struct rb_call_info *ci,
                                struct rb_call_cache *cc) {
  const rb_iseq_t *iseq = def_iseq_ptr(cc->me->def);
  const int param_size = iseq->body->param.size;
  const int local_size = iseq->body->local_table_size;
  const int opt_pc =
      vm_callee_setup_arg(ec, calling, ci, cc, def_iseq_ptr(cc->me->def),
                          cfp->sp - calling->argc, param_size, local_size);
  return vm_call_iseq_setup_2(ec, cfp, calling, ci, cc, opt_pc, param_size,
                              local_size);
}

static inline VALUE vm_call_iseq_setup_2(rb_execution_context_t *ec,
                                         rb_control_frame_t *cfp,
                                         struct rb_calling_info *calling,
                                         const struct rb_call_info *ci,
                                         struct rb_call_cache *cc, int opt_pc,
                                         int param_size, int local_size) {
  if ((__builtin_expect(!!(!(ci->flag & (0x01 << VM_CALL_TAILCALL_bit))), 1))) {
    return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, opt_pc,
                                     param_size, local_size);
  } else {
    return vm_call_iseq_setup_tailcall(ec, cfp, calling, ci, cc, opt_pc);
  }
}

static inline VALUE
vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                          struct rb_calling_info *calling,
                          const rb_callable_method_entry_t *me, int opt_pc,
                          int param_size, int local_size) {
  const rb_iseq_t *iseq = def_iseq_ptr(me->def);
  VALUE *argv = cfp->sp - calling->argc;
  VALUE *sp = argv + param_size;
  cfp->sp = argv - 1;

  vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL,
                calling->recv, calling->block_handler, (VALUE)me,
                iseq->body->iseq_encoded + opt_pc, sp, local_size - param_size,
                iseq->body->stack_max);
  return ((VALUE)RUBY_Qundef);
}

static inline VALUE vm_call_iseq_setup_tailcall(rb_execution_context_t *ec,
                                                rb_control_frame_t *cfp,
                                                struct rb_calling_info *calling,
                                                const struct rb_call_info *ci,
                                                struct rb_call_cache *cc,
                                                int opt_pc) {
  unsigned int i;
  VALUE *argv = cfp->sp - calling->argc;
  const rb_callable_method_entry_t *me = cc->me;
  const rb_iseq_t *iseq = def_iseq_ptr(me->def);
  VALUE *src_argv = argv;
  VALUE *sp_orig, *sp;
  VALUE finish_flag = VM_FRAME_FINISHED_P(cfp) ? VM_FRAME_FLAG_FINISH : 0;

  if (VM_BH_FROM_CFP_P(calling->block_handler, cfp)) {
    struct rb_captured_block *dst_captured =
        VM_CFP_TO_CAPTURED_BLOCK(((cfp) + 1));
    const struct rb_captured_block *src_captured =
        VM_BH_TO_CAPT_BLOCK(calling->block_handler);
    dst_captured->code.val = src_captured->code.val;
    if (VM_BH_ISEQ_BLOCK_P(calling->block_handler)) {
      calling->block_handler = VM_BH_FROM_ISEQ_BLOCK(dst_captured);
    } else {
      calling->block_handler = VM_BH_FROM_IFUNC_BLOCK(dst_captured);
    }
  }

  vm_pop_frame(ec, cfp, cfp->ep);
  cfp = ec->cfp;

  sp_orig = sp = cfp->sp;

  sp[0] = calling->recv;
  sp++;

  for (i = 0; i < iseq->body->param.size; i++) {
    *sp++ = src_argv[i];
  }

  vm_push_frame(ec, iseq,
                VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag,
                calling->recv, calling->block_handler, (VALUE)me,
                iseq->body->iseq_encoded + opt_pc, sp,
                iseq->body->local_table_size - iseq->body->param.size,
                iseq->body->stack_max);

  cfp->sp = sp_orig;
  rb_vm_check_ints(ec);

  return ((VALUE)RUBY_Qundef);
}

static VALUE call_cfunc_m2(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, rb_ary_new_from_values(argc, argv));
}

static VALUE call_cfunc_m1(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(argc, argv, recv);
}

static VALUE call_cfunc_0(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv);
}

static VALUE call_cfunc_1(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0]);
}

static VALUE call_cfunc_2(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1]);
}

static VALUE call_cfunc_3(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2]);
}

static VALUE call_cfunc_4(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3]);
}

static VALUE call_cfunc_5(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4]);
}

static VALUE call_cfunc_6(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
}

static VALUE call_cfunc_7(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6]);
}

static VALUE call_cfunc_8(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7]);
}

static VALUE call_cfunc_9(VALUE (*func)(), VALUE recv, int argc,
                          const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8]);
}

static VALUE call_cfunc_10(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9]);
}

static VALUE call_cfunc_11(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9], argv[10]);
}

static VALUE call_cfunc_12(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9], argv[10], argv[11]);
}

static VALUE call_cfunc_13(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9], argv[10], argv[11],
                 argv[12]);
}

static VALUE call_cfunc_14(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9], argv[10], argv[11],
                 argv[12], argv[13]);
}

static VALUE call_cfunc_15(VALUE (*func)(), VALUE recv, int argc,
                           const VALUE *argv) {
  return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
                 argv[6], argv[7], argv[8], argv[9], argv[10], argv[11],
                 argv[12], argv[13], argv[14]);
}

static inline int vm_cfp_consistent_p(rb_execution_context_t *ec,
                                      const rb_control_frame_t *reg_cfp) {
  const int ov_flags = RAISED_STACKOVERFLOW;
  if ((__builtin_expect(!!(reg_cfp == ec->cfp + 1), 1)))
    return 1;
  if ((((ec)->raised_flag & (ov_flags)) != 0)) {
    ((ec)->raised_flag &= ~(ov_flags));
    return 1;
  }
  return 0;
}

static inline const rb_method_cfunc_t *
vm_method_cfunc_entry(const rb_callable_method_entry_t *me) {
# 1883 "./vm_insnhelper.c"
  return &me->def->body.cfunc;
}

static VALUE vm_call_cfunc_with_frame(rb_execution_context_t *ec,
                                      rb_control_frame_t *reg_cfp,
                                      struct rb_calling_info *calling,
                                      const struct rb_call_info *ci,
                                      struct rb_call_cache *cc) {
  VALUE val;
  const rb_callable_method_entry_t *me = cc->me;
  const rb_method_cfunc_t *cfunc = vm_method_cfunc_entry(me);
  int len = cfunc->argc;

  VALUE recv = calling->recv;
  VALUE block_handler = calling->block_handler;
  int argc = calling->argc;

  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$cmethod__entry$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$cmethod__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);
  do {
    const rb_event_flag_t flag_arg_ = (0x0020);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, recv, me->def->original_id,
                              ci->mid, me->owner, ((VALUE)RUBY_Qundef), 0);
    }
  } while (0);

  vm_push_frame(ec, ((void *)0),
                VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL,
                recv, block_handler, (VALUE)me, 0, ec->cfp->sp, 0, 0);

  if (len >= 0)
    rb_check_arity(argc, len, len);

  reg_cfp->sp -= argc + 1;
  val = (*cfunc->invoker)(cfunc->func, recv, argc, reg_cfp->sp + 1);

  ((__builtin_expect(!!(vm_cfp_consistent_p(ec, reg_cfp)), 1))
       ? (void)0
       : rb_bug("vm_call_cfunc"
                ": cfp consistency error (%p, %p)",
                (void *)reg_cfp, (void *)(ec->cfp + 1)));

  rb_vm_pop_frame(ec);

  do {
    const rb_event_flag_t flag_arg_ = (0x0040);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, recv, me->def->original_id,
                              ci->mid, me->owner, val, 0);
    }
  } while (0);
  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);

  return val;
}

static VALUE vm_call_cfunc(rb_execution_context_t *ec,
                           rb_control_frame_t *reg_cfp,
                           struct rb_calling_info *calling,
                           const struct rb_call_info *ci,
                           struct rb_call_cache *cc) {
  do {
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                          0)))
      vm_caller_setup_arg_splat((reg_cfp), (calling));
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
      vm_caller_setup_arg_kw((reg_cfp), (calling), (ci));
  } while (0);
  return vm_call_cfunc_with_frame(ec, reg_cfp, calling, ci, cc);
}

static VALUE vm_call_ivar(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                          struct rb_calling_info *calling,
                          const struct rb_call_info *ci,
                          struct rb_call_cache *cc) {
  cfp->sp -= 1;
  return vm_getivar(calling->recv, cc->me->def->body.attr.id, ((void *)0), cc,
                    1);
}

static VALUE vm_call_attrset(rb_execution_context_t *ec,
                             rb_control_frame_t *cfp,
                             struct rb_calling_info *calling,
                             const struct rb_call_info *ci,
                             struct rb_call_cache *cc) {
  VALUE val = *(cfp->sp - 1);
  cfp->sp -= 2;
  return vm_setivar(calling->recv, cc->me->def->body.attr.id, val, ((void *)0),
                    cc, 1);
}

static inline VALUE vm_call_bmethod_body(rb_execution_context_t *ec,
                                         struct rb_calling_info *calling,
                                         const struct rb_call_info *ci,
                                         struct rb_call_cache *cc,
                                         const VALUE *argv) {
  rb_proc_t *proc;
  VALUE val;

  (((proc)) =
       (rb_proc_t *)(((struct RData *)(((cc->me->def->body.proc))))->data));
  val = rb_vm_invoke_bmethod(ec, proc, calling->recv, calling->argc, argv,
                             calling->block_handler, cc->me);

  return val;
}

static VALUE vm_call_bmethod(rb_execution_context_t *ec,
                             rb_control_frame_t *cfp,
                             struct rb_calling_info *calling,
                             const struct rb_call_info *ci,
                             struct rb_call_cache *cc) {
  VALUE *argv;
  int argc;

  do {
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                          0)))
      vm_caller_setup_arg_splat((cfp), (calling));
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
      vm_caller_setup_arg_kw((cfp), (calling), (ci));
  } while (0);
  argc = calling->argc;
  argv = (VALUE *)__builtin_alloca_with_align((sizeof(VALUE) * (argc)),
                                              _Alignof(VALUE) * 8);
  __builtin___memcpy_chk((argv), (cfp->sp - argc),
                         sizeof(VALUE) * (size_t)(argc),
                         __builtin_object_size((argv), 0));
  cfp->sp += -argc - 1;

  return vm_call_bmethod_body(ec, calling, ci, cc, argv);
}

static enum method_missing_reason
ci_missing_reason(const struct rb_call_info *ci) {
  enum method_missing_reason stat = MISSING_NOENTRY;
  if (ci->flag & (0x01 << VM_CALL_VCALL_bit))
    stat |= MISSING_VCALL;
  if (ci->flag & (0x01 << VM_CALL_FCALL_bit))
    stat |= MISSING_FCALL;
  if (ci->flag & (0x01 << VM_CALL_SUPER_bit))
    stat |= MISSING_SUPER;
  return stat;
}

static VALUE vm_call_opt_send(rb_execution_context_t *ec,
                              rb_control_frame_t *reg_cfp,
                              struct rb_calling_info *calling,
                              const struct rb_call_info *orig_ci,
                              struct rb_call_cache *orig_cc) {
  int i;
  VALUE sym;
  struct rb_call_info *ci;
  struct rb_call_info_with_kwarg ci_entry;
  struct rb_call_cache cc_entry, *cc;

  do {
    if ((__builtin_expect(
            !!(((orig_ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))), 0)))
      vm_caller_setup_arg_splat((reg_cfp), (calling));
    if ((__builtin_expect(!!(((orig_ci)->flag & (0x01 << VM_CALL_KWARG_bit))),
                          0)))
      vm_caller_setup_arg_kw((reg_cfp), (calling), (orig_ci));
  } while (0);

  i = calling->argc - 1;

  if (calling->argc == 0) {
    rb_raise(rb_eArgError, "no method name given");
  }

  if (orig_ci->flag & (0x01 << VM_CALL_KWARG_bit)) {
    ci = (struct rb_call_info *)&ci_entry;
    ci_entry = *(struct rb_call_info_with_kwarg *)orig_ci;
  } else {
    ci = &ci_entry.ci;
    ci_entry.ci = *orig_ci;
  }
  ci->flag = ci->flag & ~(0x01 << VM_CALL_KWARG_bit);

  cc_entry = *orig_cc;
  cc = &cc_entry;

  sym = (*(((((reg_cfp)->sp))) - (i)-1));

  if (!(ci->mid = rb_check_id(&sym))) {
    if (rb_method_basic_definition_p(rb_class_of((VALUE)(calling->recv)),
                                     idMethodMissing)) {
      VALUE exc = rb_make_no_method_exception(
          rb_eNoMethodError, 0, calling->recv,
          rb_long2int_inline(calling->argc), &(*(((((reg_cfp)->sp))) - (i)-1)),
          ci->flag &
              ((0x01 << VM_CALL_FCALL_bit) | (0x01 << VM_CALL_VCALL_bit)));
      rb_exc_raise(exc);
    }
    (*(((((reg_cfp)->sp))) - (i)-1)) = rb_str_intern(sym);
    ci->mid = idMethodMissing;
    ec->method_missing_reason = cc->aux.method_missing_reason =
        ci_missing_reason(ci);
  } else {

    if (i > 0) {
      __builtin___memmove_chk(
          (&(*(((((reg_cfp)->sp))) - (i)-1))),
          (&(*(((((reg_cfp)->sp))) - (i - 1) - 1))),
          sizeof(VALUE) * (size_t)(i),
          __builtin_object_size((&(*(((((reg_cfp)->sp))) - (i)-1))), 0));
    }
    calling->argc -= 1;
    (((reg_cfp)->sp) -= (((1))));
  }

  cc->me = rb_callable_method_entry_with_refinements(
      rb_class_of((VALUE)(calling->recv)), ci->mid, ((void *)0));
  ci->flag = (0x01 << VM_CALL_FCALL_bit) | (0x01 << VM_CALL_OPT_SEND_bit);
  return vm_call_method(ec, reg_cfp, calling, ci, cc);
}

static inline VALUE vm_invoke_block(rb_execution_context_t *ec,
                                    rb_control_frame_t *reg_cfp,
                                    struct rb_calling_info *calling,
                                    const struct rb_call_info *ci,
                                    VALUE block_handler);

__attribute__((__noinline__)) static VALUE
vm_invoke_block_opt_call(rb_execution_context_t *ec,
                         rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling,
                         const struct rb_call_info *ci, VALUE block_handler);

static VALUE vm_invoke_block_opt_call(rb_execution_context_t *ec,
                                      rb_control_frame_t *reg_cfp,
                                      struct rb_calling_info *calling,
                                      const struct rb_call_info *ci,
                                      VALUE block_handler) {
  int argc = calling->argc;

  if (argc > 0)
    __builtin___memmove_chk(
        (&(*(((((reg_cfp)->sp))) - (argc)-1))),
        (&(*(((((reg_cfp)->sp))) - (argc - 1) - 1))),
        sizeof(VALUE) * (size_t)(argc),
        __builtin_object_size((&(*(((((reg_cfp)->sp))) - (argc)-1))), 0));
  (((reg_cfp)->sp) -= (((1))));

  return vm_invoke_block(ec, reg_cfp, calling, ci, block_handler);
}

static VALUE vm_call_opt_call(rb_execution_context_t *ec,
                              rb_control_frame_t *reg_cfp,
                              struct rb_calling_info *calling,
                              const struct rb_call_info *ci,
                              struct rb_call_cache *cc) {
  VALUE procval = calling->recv;
  return vm_invoke_block_opt_call(ec, reg_cfp, calling, ci,
                                  VM_BH_FROM_PROC(procval));
}

static VALUE vm_call_opt_block_call(rb_execution_context_t *ec,
                                    rb_control_frame_t *reg_cfp,
                                    struct rb_calling_info *calling,
                                    const struct rb_call_info *ci,
                                    struct rb_call_cache *cc) {
  VALUE block_handler = VM_ENV_BLOCK_HANDLER(VM_CF_LEP(reg_cfp));

  if (((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_CALL)] & ((1 << 12))) == 0),
          1)))) {
    return vm_invoke_block_opt_call(ec, reg_cfp, calling, ci, block_handler);
  } else {
    calling->recv = rb_vm_bh_to_procval(ec, block_handler);
    vm_search_method(ci, cc, calling->recv);
    return vm_call_general(ec, reg_cfp, calling, ci, cc);
  }
}

static VALUE vm_call_method_missing(rb_execution_context_t *ec,
                                    rb_control_frame_t *reg_cfp,
                                    struct rb_calling_info *calling,
                                    const struct rb_call_info *orig_ci,
                                    struct rb_call_cache *orig_cc) {
  VALUE *argv = (((((reg_cfp)->sp))) - (calling->argc));
  struct rb_call_info ci_entry;
  const struct rb_call_info *ci;
  struct rb_call_cache cc_entry, *cc;
  unsigned int argc;

  do {
    if ((__builtin_expect(
            !!(((orig_ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))), 0)))
      vm_caller_setup_arg_splat((reg_cfp), (calling));
    if ((__builtin_expect(!!(((orig_ci)->flag & (0x01 << VM_CALL_KWARG_bit))),
                          0)))
      vm_caller_setup_arg_kw((reg_cfp), (calling), (orig_ci));
  } while (0);
  argc = calling->argc + 1;

  ci_entry.flag = (0x01 << VM_CALL_FCALL_bit) | (0x01 << VM_CALL_OPT_SEND_bit);
  ci_entry.mid = idMethodMissing;
  ci_entry.orig_argc = argc;
  ci = &ci_entry;

  cc_entry = *orig_cc;
  cc_entry.me = rb_callable_method_entry_without_refinements(
      rb_class_of((VALUE)(calling->recv)), idMethodMissing, ((void *)0));
  cc = &cc_entry;

  calling->argc = argc;

  if ((__builtin_expect(
          !!(!(!(1 / !!(sizeof(*((reg_cfp)->sp)) == sizeof(VALUE))) ||
               !(1 / !!(sizeof(*(reg_cfp)) == sizeof(rb_control_frame_t))) ||
               ((rb_control_frame_t *)(((reg_cfp)->sp) + (1)) + 1) >=
                   (reg_cfp))),
          1))) {
    (void)0;
  } else
    vm_stackoverflow();
  if (argc > 1) {
    __builtin___memmove_chk((argv + 1), (argv),
                            sizeof(VALUE) * (size_t)(argc - 1),
                            __builtin_object_size((argv + 1), 0));
  }
  argv[0] = (rb_id2sym(orig_ci->mid));
  (((reg_cfp)->sp) += (((1))));

  ec->method_missing_reason = orig_cc->aux.method_missing_reason;
  return vm_call_method(ec, reg_cfp, calling, ci, cc);
}

static const rb_callable_method_entry_t *
refined_method_callable_without_refinement(
    const rb_callable_method_entry_t *me);
static VALUE vm_call_zsuper(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling,
                            const struct rb_call_info *ci,
                            struct rb_call_cache *cc, VALUE klass) {
  klass = RCLASS_SUPER(klass);
  cc->me = klass ? rb_callable_method_entry(klass, ci->mid) : ((void *)0);

  if (!cc->me) {
    return vm_call_method_nome(ec, cfp, calling, ci, cc);
  }
  if (cc->me->def->type == VM_METHOD_TYPE_REFINED &&
      cc->me->def->body.refined.orig_me) {
    cc->me = refined_method_callable_without_refinement(cc->me);
  }
  return vm_call_method_each_type(ec, cfp, calling, ci, cc);
}

static inline VALUE find_refinement(VALUE refinements, VALUE klass) {
  if (!((VALUE)(refinements) != ((VALUE)RUBY_Qnil))) {
    return ((VALUE)RUBY_Qnil);
  }
  return rb_hash_lookup(refinements, klass);
}

__attribute__((__pure__)) static rb_control_frame_t *
current_method_entry(const rb_execution_context_t *ec, rb_control_frame_t *cfp);
static rb_control_frame_t *
current_method_entry(const rb_execution_context_t *ec,
                     rb_control_frame_t *cfp) {
  rb_control_frame_t *top_cfp = cfp;

  if (cfp->iseq && cfp->iseq->body->type == ISEQ_TYPE_BLOCK) {
    const rb_iseq_t *local_iseq = cfp->iseq->body->local_iseq;

    do {
      cfp = ((cfp) + 1);
      if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp)) {

        return top_cfp;
      }
    } while (cfp->iseq != local_iseq);
  }
  return cfp;
}

static VALUE find_defined_class_by_owner(VALUE current_class,
                                         VALUE target_owner) {
  VALUE klass = current_class;

  if ((((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_ICLASS))) &&
      ((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((klass)))->flags & ((((VALUE)RUBY_FL_USER5))))
           : 0))
    klass = (((struct RBasic *)(klass))->klass);

  while (!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
    VALUE owner =
        (((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
             ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
             : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                   ? ((klass) == ((VALUE)RUBY_Qtrue))
                   : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                         ? ((klass) == ((VALUE)RUBY_Qfalse))
                         : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                               ? ((klass) == ((VALUE)RUBY_Qnil))
                               : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                     ? ((klass) == ((VALUE)RUBY_Qundef))
                                     : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                           ? ((((VALUE)(klass) &
                                                ~((~(VALUE)0)
                                                  << RUBY_SPECIAL_SHIFT)) ==
                                               RUBY_SYMBOL_FLAG) ||
                                              (!(((VALUE)(
                                                     klass)&RUBY_IMMEDIATE_MASK) ||
                                                 !!(((VALUE)(klass) &
                                                     (VALUE) ~(
                                                         (VALUE)RUBY_Qnil)) ==
                                                    0)) &&
                                               (int)(((struct RBasic *)(klass))
                                                         ->flags &
                                                     RUBY_T_MASK) ==
                                                   (RUBY_T_SYMBOL)))
                                           : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                                 ? (((((int)(long)(klass)) &
                                                      RUBY_FLONUM_MASK) ==
                                                     RUBY_FLONUM_FLAG) ||
                                                    (!(((VALUE)(
                                                           klass)&RUBY_IMMEDIATE_MASK) ||
                                                       !!(((VALUE)(klass) &
                                                           (VALUE) ~(
                                                               (VALUE)
                                                                   RUBY_Qnil)) ==
                                                          0)) &&
                                                     (int)(((struct RBasic
                                                                 *)(klass))
                                                               ->flags &
                                                           RUBY_T_MASK) ==
                                                         RUBY_T_FLOAT))
                                                 : (!(((VALUE)(
                                                          klass)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(klass) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(klass))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        (RUBY_T_ICLASS)))
            ? (((struct RBasic *)(klass))->klass)
            : klass;
    if (owner == target_owner) {
      return klass;
    }
    klass = RCLASS_SUPER(klass);
  }

  return current_class;
}

static const rb_callable_method_entry_t *
aliased_callable_method_entry(const rb_callable_method_entry_t *me) {
  const rb_method_entry_t *orig_me = me->def->body.alias.original_me;
  const rb_callable_method_entry_t *cme;

  if (orig_me->defined_class == 0) {
    VALUE defined_class =
        find_defined_class_by_owner(me->defined_class, orig_me->owner);
    ((void)0);
    cme = rb_method_entry_complement_defined_class(orig_me, me->called_id,
                                                   defined_class);

    if (me->def->alias_count + me->def->complemented_count == 0) {
      __extension__({
# 2195 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 2195 "./vm_insnhelper.c"
        ;
# 2195 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 2195 "./vm_insnhelper.c"
        ;
        typeof(rb_obj_write((VALUE)(me),
                            (VALUE *)(&me->def->body.alias.original_me),
                            (VALUE)(cme), "./vm_insnhelper.c", 2195))
            unaligned_member_access_result =
                (rb_obj_write((VALUE)(me),
                              (VALUE *)(&me->def->body.alias.original_me),
                              (VALUE)(cme), "./vm_insnhelper.c", 2195));
# 2195 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 2195 "./vm_insnhelper.c"
        ;
        unaligned_member_access_result;
      });
    } else {
      rb_method_definition_t *def = rb_method_definition_create(
          VM_METHOD_TYPE_ALIAS, me->def->original_id);
      rb_method_definition_set((rb_method_entry_t *)me, def, (void *)cme);
    }
  } else {
    cme = (const rb_callable_method_entry_t *)orig_me;
  }

  ((void)0);
  return cme;
}

static const rb_callable_method_entry_t *
refined_method_callable_without_refinement(
    const rb_callable_method_entry_t *me) {
  const rb_method_entry_t *orig_me = me->def->body.refined.orig_me;
  const rb_callable_method_entry_t *cme;

  if (orig_me->defined_class == 0) {
    cme = ((void *)0);
    rb_notimplement();
  } else {
    cme = (const rb_callable_method_entry_t *)orig_me;
  }

  ((void)0);

  if ((!(cme) || !(cme)->def || (cme)->def->type == VM_METHOD_TYPE_UNDEF)) {
    cme = ((void *)0);
  }

  return cme;
}

static VALUE vm_call_method_each_type(rb_execution_context_t *ec,
                                      rb_control_frame_t *cfp,
                                      struct rb_calling_info *calling,
                                      const struct rb_call_info *ci,
                                      struct rb_call_cache *cc) {
  switch (cc->me->def->type) {
  case VM_METHOD_TYPE_ISEQ:
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_iseq_setup));
    } while (0);
    return vm_call_iseq_setup(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_NOTIMPLEMENTED:
  case VM_METHOD_TYPE_CFUNC:
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_cfunc));
    } while (0);
    return vm_call_cfunc(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_ATTRSET:
    do {
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                            0)))
        vm_caller_setup_arg_splat((cfp), (calling));
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
        vm_caller_setup_arg_kw((cfp), (calling), (ci));
    } while (0);
    rb_check_arity(calling->argc, 1, 1);
    cc->aux.index = 0;
    do {
      if ((__builtin_expect(
              !!(!((ci->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit)) ||
                   (ci->flag & (0x01 << VM_CALL_KWARG_bit)))),
              1)))
        ((cc)->call = (vm_call_attrset));
    } while (0);
    return vm_call_attrset(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_IVAR:
    do {
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                            0)))
        vm_caller_setup_arg_splat((cfp), (calling));
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
        vm_caller_setup_arg_kw((cfp), (calling), (ci));
    } while (0);
    rb_check_arity(calling->argc, 0, 0);
    cc->aux.index = 0;
    do {
      if ((__builtin_expect(!!(!(ci->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                            1)))
        ((cc)->call = (vm_call_ivar));
    } while (0);
    return vm_call_ivar(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_MISSING:
    cc->aux.method_missing_reason = 0;
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_method_missing));
    } while (0);
    return vm_call_method_missing(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_BMETHOD:
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_bmethod));
    } while (0);
    return vm_call_bmethod(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_ALIAS:
    cc->me = aliased_callable_method_entry(cc->me);
    ((void)0);
    return vm_call_method_each_type(ec, cfp, calling, ci, cc);

  case VM_METHOD_TYPE_OPTIMIZED:
    switch (cc->me->def->body.optimize_type) {
    case OPTIMIZED_METHOD_TYPE_SEND:
      do {
        if ((__builtin_expect(!!(1), 1)))
          ((cc)->call = (vm_call_opt_send));
      } while (0);
      return vm_call_opt_send(ec, cfp, calling, ci, cc);
    case OPTIMIZED_METHOD_TYPE_CALL:
      do {
        if ((__builtin_expect(!!(1), 1)))
          ((cc)->call = (vm_call_opt_call));
      } while (0);
      return vm_call_opt_call(ec, cfp, calling, ci, cc);
    case OPTIMIZED_METHOD_TYPE_BLOCK_CALL:
      do {
        if ((__builtin_expect(!!(1), 1)))
          ((cc)->call = (vm_call_opt_block_call));
      } while (0);
      return vm_call_opt_block_call(ec, cfp, calling, ci, cc);
    default:
      rb_bug("vm_call_method: unsupported optimized method type (%d)",
             cc->me->def->body.optimize_type);
    }

  case VM_METHOD_TYPE_UNDEF:
    break;

  case VM_METHOD_TYPE_ZSUPER:
    return vm_call_zsuper(ec, cfp, calling, ci, cc,
                          ((((struct RClass *)(cc->me->owner))->ptr)->origin_));

  case VM_METHOD_TYPE_REFINED: {
    const rb_cref_t *cref = rb_vm_get_cref(cfp->ep);
    VALUE refinements = cref ? CREF_REFINEMENTS(cref) : ((VALUE)RUBY_Qnil);
    VALUE refinement;
    const rb_callable_method_entry_t *ref_me;

    refinement = find_refinement(refinements, cc->me->owner);

    if (!((VALUE)(refinement) != ((VALUE)RUBY_Qnil))) {
      goto no_refinement_dispatch;
    }
    ref_me = rb_callable_method_entry(refinement, ci->mid);

    if (ref_me) {
      if (cc->call == vm_call_super_method) {
        const rb_control_frame_t *top_cfp = current_method_entry(ec, cfp);
        const rb_callable_method_entry_t *top_me =
            rb_vm_frame_method_entry(top_cfp);
        if (top_me && rb_method_definition_eq(ref_me->def, top_me->def)) {
          goto no_refinement_dispatch;
        }
      }
      cc->me = ref_me;
      if (ref_me->def->type != VM_METHOD_TYPE_REFINED) {
        return vm_call_method(ec, cfp, calling, ci, cc);
      }
    } else {
      cc->me = ((void *)0);
      return vm_call_method_nome(ec, cfp, calling, ci, cc);
    }

  no_refinement_dispatch:
    if (cc->me->def->body.refined.orig_me) {
      cc->me = refined_method_callable_without_refinement(cc->me);
    } else {
      VALUE klass = RCLASS_SUPER(cc->me->defined_class);
      cc->me = klass ? rb_callable_method_entry(klass, ci->mid) : ((void *)0);
    }
    return vm_call_method(ec, cfp, calling, ci, cc);
  }
  }

  rb_bug("vm_call_method: unsupported method type (%d)", cc->me->def->type);
}

__attribute__((__noreturn__)) static void
vm_raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv,
                        VALUE obj, int call_status);

static VALUE vm_call_method_nome(rb_execution_context_t *ec,
                                 rb_control_frame_t *cfp,
                                 struct rb_calling_info *calling,
                                 const struct rb_call_info *ci,
                                 struct rb_call_cache *cc) {

  const int stat = ci_missing_reason(ci);

  if (ci->mid == idMethodMissing) {
    rb_control_frame_t *reg_cfp = cfp;
    VALUE *argv = (((((reg_cfp)->sp))) - (calling->argc));
    vm_raise_method_missing(ec, calling->argc, argv, calling->recv, stat);
  } else {
    cc->aux.method_missing_reason = stat;
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_method_missing));
    } while (0);
    return vm_call_method_missing(ec, cfp, calling, ci, cc);
  }
}

static inline VALUE vm_call_method(rb_execution_context_t *ec,
                                   rb_control_frame_t *cfp,
                                   struct rb_calling_info *calling,
                                   const struct rb_call_info *ci,
                                   struct rb_call_cache *cc) {
  ((void)0);

  if (cc->me != ((void *)0)) {
    switch ((rb_method_visibility_t)(
        ((cc->me)->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
        ((((VALUE)RUBY_FL_USHIFT) + 4) + 0))) {
    case METHOD_VISI_PUBLIC:
      return vm_call_method_each_type(ec, cfp, calling, ci, cc);

    case METHOD_VISI_PRIVATE:
      if (!(ci->flag & (0x01 << VM_CALL_FCALL_bit))) {
        enum method_missing_reason stat = MISSING_PRIVATE;
        if (ci->flag & (0x01 << VM_CALL_VCALL_bit))
          stat |= MISSING_VCALL;

        cc->aux.method_missing_reason = stat;
        do {
          if ((__builtin_expect(!!(1), 1)))
            ((cc)->call = (vm_call_method_missing));
        } while (0);
        return vm_call_method_missing(ec, cfp, calling, ci, cc);
      }
      return vm_call_method_each_type(ec, cfp, calling, ci, cc);

    case METHOD_VISI_PROTECTED:
      if (!(ci->flag & (0x01 << VM_CALL_OPT_SEND_bit))) {
        if (!rb_obj_is_kind_of(cfp->self, cc->me->defined_class)) {
          cc->aux.method_missing_reason = MISSING_PROTECTED;
          return vm_call_method_missing(ec, cfp, calling, ci, cc);
        } else {

          struct rb_call_cache cc_entry;
          cc_entry = *cc;
          cc = &cc_entry;

          ((void)0);
          return vm_call_method_each_type(ec, cfp, calling, ci, cc);
        }
      }
      return vm_call_method_each_type(ec, cfp, calling, ci, cc);

    default:
      rb_bug("unreachable");
    }
  } else {
    return vm_call_method_nome(ec, cfp, calling, ci, cc);
  }
}

static VALUE vm_call_general(rb_execution_context_t *ec,
                             rb_control_frame_t *reg_cfp,
                             struct rb_calling_info *calling,
                             const struct rb_call_info *ci,
                             struct rb_call_cache *cc) {
  return vm_call_method(ec, reg_cfp, calling, ci, cc);
}

static VALUE vm_call_super_method(rb_execution_context_t *ec,
                                  rb_control_frame_t *reg_cfp,
                                  struct rb_calling_info *calling,
                                  const struct rb_call_info *ci,
                                  struct rb_call_cache *cc) {

  if (cc->call != vm_call_super_method)
    rb_bug("bug");
  return vm_call_method(ec, reg_cfp, calling, ci, cc);
}

static inline VALUE vm_search_normal_superclass(VALUE klass) {
  if ((int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) == RUBY_T_ICLASS &&
      ((!(((VALUE)(((struct RBasic *)(klass))->klass) & RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(((struct RBasic *)(klass))->klass) &
              (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(((struct RBasic *)(klass))->klass))->flags &
              RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((((struct RBasic *)(klass))->klass)))->flags &
              ((RMODULE_IS_REFINEMENT)))
           : 0)) {
    klass = ((struct RBasic *)(klass))->klass;
  }
  klass = ((((struct RClass *)(klass))->ptr)->origin_);
  return RCLASS_SUPER(klass);
}

__attribute__((__noreturn__)) static void vm_super_outside(void);

static void vm_super_outside(void) {
  rb_raise(rb_eNoMethodError, "super called outside of method");
}

static void vm_search_super_method(const rb_execution_context_t *ec,
                                   rb_control_frame_t *reg_cfp,
                                   struct rb_calling_info *calling,
                                   struct rb_call_info *ci,
                                   struct rb_call_cache *cc) {
  VALUE current_defined_class, klass;
  const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(reg_cfp);

  if (!me) {
    vm_super_outside();
  }

  current_defined_class = me->defined_class;

  if (!!((VALUE)(((((struct RClass *)(current_defined_class))->ptr)
                      ->refined_class)) != ((VALUE)RUBY_Qnil))) {
    current_defined_class =
        ((((struct RClass *)(current_defined_class))->ptr)->refined_class);
  }

  if ((int)(((struct RBasic *)(current_defined_class))->flags & RUBY_T_MASK) !=
          RUBY_T_MODULE &&
      (int)(((struct RBasic *)(current_defined_class))->flags & RUBY_T_MASK) !=
          RUBY_T_ICLASS &&
      !((!(((VALUE)(current_defined_class)&RUBY_IMMEDIATE_MASK) ||
           !!(((VALUE)(current_defined_class) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
              0)) &&
         (int)(((struct RBasic *)(current_defined_class))->flags &
               RUBY_T_MASK) != RUBY_T_NODE)
            ? (((struct RBasic *)((current_defined_class)))->flags &
               ((RMODULE_INCLUDED_INTO_REFINEMENT)))
            : 0) &&
      !rb_obj_is_kind_of(calling->recv, current_defined_class)) {
    VALUE m =
        (((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
             ? (((int)(long)(current_defined_class)) & RUBY_FIXNUM_FLAG)
             : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                   ? ((current_defined_class) == ((VALUE)RUBY_Qtrue))
                   : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                         ? ((current_defined_class) == ((VALUE)RUBY_Qfalse))
                         : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                               ? ((current_defined_class) == ((VALUE)RUBY_Qnil))
                               : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                     ? ((current_defined_class) ==
                                        ((VALUE)RUBY_Qundef))
                                     : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                           ? ((((VALUE)(current_defined_class) &
                                                ~((~(VALUE)0)
                                                  << RUBY_SPECIAL_SHIFT)) ==
                                               RUBY_SYMBOL_FLAG) ||
                                              (!(((VALUE)(
                                                     current_defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                 !!(((VALUE)(
                                                         current_defined_class) &
                                                     (VALUE) ~(
                                                         (VALUE)RUBY_Qnil)) ==
                                                    0)) &&
                                               (int)(((struct RBasic
                                                           *)(current_defined_class))
                                                         ->flags &
                                                     RUBY_T_MASK) ==
                                                   (RUBY_T_SYMBOL)))
                                           : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                                 ? (((((int)(long)(current_defined_class)) &
                                                      RUBY_FLONUM_MASK) ==
                                                     RUBY_FLONUM_FLAG) ||
                                                    (!(((VALUE)(
                                                           current_defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                       !!(((VALUE)(
                                                               current_defined_class) &
                                                           (VALUE) ~(
                                                               (VALUE)
                                                                   RUBY_Qnil)) ==
                                                          0)) &&
                                                     (int)(((struct RBasic
                                                                 *)(current_defined_class))
                                                               ->flags &
                                                           RUBY_T_MASK) ==
                                                         RUBY_T_FLOAT))
                                                 : (!(((VALUE)(
                                                          current_defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(
                                                              current_defined_class) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(current_defined_class))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        (RUBY_T_ICLASS)))
            ? ((struct RBasic *)(current_defined_class))->klass
            : current_defined_class;

    rb_raise(rb_eTypeError,
             "self has wrong type to call super in this context: "
             "%"
             "l"
             "i"
             "\v"
             " (expected %"
             "l"
             "i"
             "\v"
             ")",
             rb_obj_class(calling->recv), m);
  }

  if (me->def->type == VM_METHOD_TYPE_BMETHOD &&
      (ci->flag & (0x01 << VM_CALL_ZSUPER_bit))) {
    rb_raise(rb_eRuntimeError,
             "implicit argument passing of super from method defined"
             " by define_method() is not supported."
             " Specify all arguments explicitly.");
  }

  ci->mid = me->def->original_id;
  klass = vm_search_normal_superclass(me->defined_class);

  if (!klass) {

    cc->aux.method_missing_reason = MISSING_SUPER;
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_method_missing));
    } while (0);
  } else {

    cc->me = rb_callable_method_entry(klass, ci->mid);
    do {
      if ((__builtin_expect(!!(1), 1)))
        ((cc)->call = (vm_call_super_method));
    } while (0);
  }
}

static inline int block_proc_is_lambda(const VALUE procval) {
  rb_proc_t *proc;

  if (procval) {
    (((proc)) = (rb_proc_t *)(((struct RData *)(((procval))))->data));
    return proc->is_lambda;
  } else {
    return 0;
  }
}

static VALUE vm_yield_with_cfunc(rb_execution_context_t *ec,
                                 const struct rb_captured_block *captured,
                                 VALUE self, int argc, const VALUE *argv,
                                 VALUE block_handler,
                                 const rb_callable_method_entry_t *me) {
  int is_lambda = 0;
  VALUE val, arg, blockarg;
  const struct vm_ifunc *ifunc = captured->code.ifunc;

  if (is_lambda) {
    arg = rb_ary_new_from_values(argc, argv);
  } else if (argc == 0) {
    arg = ((VALUE)RUBY_Qnil);
  } else {
    arg = argv[0];
  }

  blockarg = rb_vm_bh_to_procval(ec, block_handler);

  vm_push_frame(ec, (const rb_iseq_t *)captured->code.ifunc,
                VM_FRAME_MAGIC_IFUNC | VM_FRAME_FLAG_CFRAME |
                    (me ? VM_FRAME_FLAG_BMETHOD : 0),
                self, ((VALUE)((captured->ep)) | (0x01)), (VALUE)me, 0,
                ec->cfp->sp, 0, 0);
  val = (*ifunc->func)(arg, ifunc->data, argc, argv, blockarg);
  rb_vm_pop_frame(ec);

  return val;
}

static VALUE vm_yield_with_symbol(rb_execution_context_t *ec, VALUE symbol,
                                  int argc, const VALUE *argv,
                                  VALUE block_handler) {
  return rb_sym_proc_call((rb_sym2id(symbol)), argc, argv,
                          rb_vm_bh_to_procval(ec, block_handler));
}

static inline int vm_callee_setup_block_arg_arg0_splat(rb_control_frame_t *cfp,
                                                       const rb_iseq_t *iseq,
                                                       VALUE *argv, VALUE ary) {
  int i;
  long len = rb_array_len(ary);

  if ((__builtin_expect(
          !!(!(!(1 / !!(sizeof(*((cfp)->sp)) == sizeof(VALUE))) ||
               !(1 / !!(sizeof(*(cfp)) == sizeof(rb_control_frame_t))) ||
               ((rb_control_frame_t *)(((cfp)->sp) +
                                       (iseq->body->param.lead_num)) +
                1) >= (cfp))),
          1))) {
    (void)0;
  } else
    vm_stackoverflow();

  for (i = 0; i < len && i < iseq->body->param.lead_num; i++) {
    argv[i] = (rb_array_const_ptr_transient(ary)[i]);
  }

  return i;
}

static inline VALUE vm_callee_setup_block_arg_arg0_check(VALUE *argv) {
  VALUE ary, arg0 = argv[0];
  ary = rb_check_array_type(arg0);

  ((void)0);

  return ary;
}

static int vm_callee_setup_block_arg(rb_execution_context_t *ec,
                                     struct rb_calling_info *calling,
                                     const struct rb_call_info *ci,
                                     const rb_iseq_t *iseq, VALUE *argv,
                                     const enum arg_setup_type arg_setup_type) {
  if (rb_simple_iseq_p(iseq)) {
    rb_control_frame_t *cfp = ec->cfp;
    VALUE arg0;

    do {
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                            0)))
        vm_caller_setup_arg_splat((cfp), (calling));
      if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
        vm_caller_setup_arg_kw((cfp), (calling), (ci));
    } while (0);

    if (arg_setup_type == arg_setup_block && calling->argc == 1 &&
        iseq->body->param.flags.has_lead &&
        !iseq->body->param.flags.ambiguous_param0 &&
        !!((VALUE)(arg0 = vm_callee_setup_block_arg_arg0_check(argv)) !=
           ((VALUE)RUBY_Qnil))) {
      calling->argc =
          vm_callee_setup_block_arg_arg0_splat(cfp, iseq, argv, arg0);
    }

    if (calling->argc != iseq->body->param.lead_num) {
      if (arg_setup_type == arg_setup_block) {
        if (calling->argc < iseq->body->param.lead_num) {
          int i;
          if ((__builtin_expect(
                  !!(!(
                      !(1 / !!(sizeof(*((cfp)->sp)) == sizeof(VALUE))) ||
                      !(1 / !!(sizeof(*(cfp)) == sizeof(rb_control_frame_t))) ||
                      ((rb_control_frame_t *)(((cfp)->sp) +
                                              (iseq->body->param.lead_num)) +
                       1) >= (cfp))),
                  1))) {
            (void)0;
          } else
            vm_stackoverflow();
          for (i = calling->argc; i < iseq->body->param.lead_num; i++)
            argv[i] = ((VALUE)RUBY_Qnil);
          calling->argc = iseq->body->param.lead_num;
        } else if (calling->argc > iseq->body->param.lead_num) {
          calling->argc = iseq->body->param.lead_num;
        }
      } else {
        argument_arity_error(ec, iseq, calling->argc,
                             iseq->body->param.lead_num,
                             iseq->body->param.lead_num);
      }
    }

    return 0;
  } else {
    return setup_parameters_complex(ec, iseq, calling, ci, argv,
                                    arg_setup_type);
  }
}

static int vm_yield_setup_args(rb_execution_context_t *ec,
                               const rb_iseq_t *iseq, const int argc,
                               VALUE *argv, VALUE block_handler,
                               enum arg_setup_type arg_setup_type) {
  struct rb_calling_info calling_entry, *calling;
  struct rb_call_info ci_entry, *ci;

  calling = &calling_entry;
  calling->argc = argc;
  calling->block_handler = block_handler;

  ci_entry.flag = 0;
  ci = &ci_entry;

  return vm_callee_setup_block_arg(ec, calling, ci, iseq, argv, arg_setup_type);
}

static VALUE vm_invoke_iseq_block(rb_execution_context_t *ec,
                                  rb_control_frame_t *reg_cfp,
                                  struct rb_calling_info *calling,
                                  const struct rb_call_info *ci, int is_lambda,
                                  const struct rb_captured_block *captured) {
  const rb_iseq_t *iseq = rb_iseq_check(captured->code.iseq);
  const int arg_size = iseq->body->param.size;
  VALUE *const rsp = ((((reg_cfp)->sp))) - calling->argc;
  int opt_pc =
      vm_callee_setup_block_arg(ec, calling, ci, iseq, rsp,
                                is_lambda ? arg_setup_method : arg_setup_block);

  (((reg_cfp)->sp) = (((rsp))));

  vm_push_frame(ec, iseq,
                VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0),
                captured->self, ((VALUE)((captured->ep)) | (0x01)), 0,
                iseq->body->iseq_encoded + opt_pc, rsp + arg_size,
                iseq->body->local_table_size - arg_size, iseq->body->stack_max);

  return ((VALUE)RUBY_Qundef);
}

static VALUE vm_invoke_symbol_block(rb_execution_context_t *ec,
                                    rb_control_frame_t *reg_cfp,
                                    struct rb_calling_info *calling,
                                    const struct rb_call_info *ci,
                                    VALUE symbol) {
  VALUE val;
  int argc;
  do {
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                          0)))
      vm_caller_setup_arg_splat((ec->cfp), (calling));
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
      vm_caller_setup_arg_kw((ec->cfp), (calling), (ci));
  } while (0);
  argc = calling->argc;
  val = vm_yield_with_symbol(ec, symbol, argc, (((((reg_cfp)->sp))) - (argc)),
                             calling->block_handler);
  ((((reg_cfp)->sp) -= (((argc)))));
  return val;
}

static VALUE vm_invoke_ifunc_block(rb_execution_context_t *ec,
                                   rb_control_frame_t *reg_cfp,
                                   struct rb_calling_info *calling,
                                   const struct rb_call_info *ci,
                                   const struct rb_captured_block *captured) {
  VALUE val;
  int argc;
  do {
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_ARGS_SPLAT_bit))),
                          0)))
      vm_caller_setup_arg_splat((ec->cfp), (calling));
    if ((__builtin_expect(!!(((ci)->flag & (0x01 << VM_CALL_KWARG_bit))), 0)))
      vm_caller_setup_arg_kw((ec->cfp), (calling), (ci));
  } while (0);
  argc = calling->argc;
  val = vm_yield_with_cfunc(ec, captured, captured->self, argc,
                            (((((reg_cfp)->sp))) - (argc)),
                            calling->block_handler, ((void *)0));
  ((((reg_cfp)->sp) -= (((argc)))));
  return val;
}

static VALUE vm_proc_to_block_handler(VALUE procval) {
  const struct rb_block *block = vm_proc_block(procval);

  switch (vm_block_type(block)) {
  case block_type_iseq:
    return VM_BH_FROM_ISEQ_BLOCK(&block->as.captured);
  case block_type_ifunc:
    return VM_BH_FROM_IFUNC_BLOCK(&block->as.captured);
  case block_type_symbol:
    return VM_BH_FROM_SYMBOL(block->as.symbol);
  case block_type_proc:
    return VM_BH_FROM_PROC(block->as.proc);
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qundef);
}

static inline VALUE vm_invoke_block(rb_execution_context_t *ec,
                                    rb_control_frame_t *reg_cfp,
                                    struct rb_calling_info *calling,
                                    const struct rb_call_info *ci,
                                    VALUE block_handler) {
  int is_lambda = 0;

again:
  switch (vm_block_handler_type(block_handler)) {
  case block_handler_type_iseq: {
    const struct rb_captured_block *captured =
        VM_BH_TO_ISEQ_BLOCK(block_handler);
    return vm_invoke_iseq_block(ec, reg_cfp, calling, ci, is_lambda, captured);
  }
  case block_handler_type_ifunc: {
    const struct rb_captured_block *captured =
        VM_BH_TO_IFUNC_BLOCK(block_handler);
    return vm_invoke_ifunc_block(ec, reg_cfp, calling, ci, captured);
  }
  case block_handler_type_proc:
    is_lambda = block_proc_is_lambda(VM_BH_TO_PROC(block_handler));
    block_handler = vm_proc_to_block_handler(VM_BH_TO_PROC(block_handler));
    goto again;
  case block_handler_type_symbol:
    return vm_invoke_symbol_block(ec, reg_cfp, calling, ci,
                                  VM_BH_TO_SYMBOL(block_handler));
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qnil);
}

static VALUE vm_make_proc_with_iseq(const rb_iseq_t *blockiseq) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);
  struct rb_captured_block *captured;

  if (cfp == 0) {
    rb_bug("vm_make_proc_with_iseq: unreachable");
  }

  captured = VM_CFP_TO_CAPTURED_BLOCK(cfp);
  captured->code.iseq = blockiseq;

  return rb_vm_make_proc(ec, captured, rb_cProc);
}

static VALUE vm_once_exec(VALUE iseq) {
  VALUE proc = vm_make_proc_with_iseq((rb_iseq_t *)iseq);
  return rb_proc_call_with_block(proc, 0, 0, ((VALUE)RUBY_Qnil));
}

static VALUE vm_once_clear(VALUE data) {
  union iseq_inline_storage_entry *is = (union iseq_inline_storage_entry *)data;
  is->once.running_thread = ((void *)0);
  return ((VALUE)RUBY_Qnil);
}

rb_control_frame_t *rb_vm_opt_struct_aref(rb_execution_context_t *ec,
                                          rb_control_frame_t *reg_cfp) {
  (*(((((reg_cfp)->sp))) - (0) - 1)) = rb_struct_aref(
      (((((reg_cfp)))->self)), (*(((((reg_cfp)->sp))) - (0) - 1)));
  return reg_cfp;
}

rb_control_frame_t *rb_vm_opt_struct_aset(rb_execution_context_t *ec,
                                          rb_control_frame_t *reg_cfp) {
  rb_struct_aset((((((reg_cfp)))->self)), (*(((((reg_cfp)->sp))) - (0) - 1)),
                 (*(((((reg_cfp)->sp))) - (1) - 1)));
  return reg_cfp;
}

static enum defined_type check_respond_to_missing(VALUE obj, VALUE v) {
  VALUE args[2];
  VALUE r;

  args[0] = obj;
  args[1] = ((VALUE)RUBY_Qfalse);
  r = rb_check_funcall(v, idRespond_to_missing, 2, args);
  if (r != ((VALUE)RUBY_Qundef) &&
      !(((VALUE)(r) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
    return DEFINED_METHOD;
  } else {
    return DEFINED_NOT_DEFINED;
  }
}

static VALUE vm_defined(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                        rb_num_t op_type, VALUE obj, VALUE needstr, VALUE v) {
  VALUE klass;
  enum defined_type expr_type = DEFINED_NOT_DEFINED;
  enum defined_type type = (enum defined_type)op_type;

  switch (type) {
  case DEFINED_IVAR:
    if (rb_ivar_defined((((((reg_cfp)))->self)), (rb_sym2id(obj)))) {
      expr_type = DEFINED_IVAR;
    }
    break;
  case DEFINED_IVAR2:
    klass = vm_get_cbase(((((reg_cfp)->ep))));
    break;
  case DEFINED_GVAR:
    if (rb_gvar_defined(rb_global_entry((rb_sym2id(obj))))) {
      expr_type = DEFINED_GVAR;
    }
    break;
  case DEFINED_CVAR: {
    const rb_cref_t *cref = rb_vm_get_cref(((((reg_cfp)->ep))));
    klass = vm_get_cvar_base(cref, (((reg_cfp))));
    if (rb_cvar_defined(klass, (rb_sym2id(obj)))) {
      expr_type = DEFINED_CVAR;
    }
    break;
  }
  case DEFINED_CONST:
    klass = v;
    if (vm_get_ev_const(ec, klass, (rb_sym2id(obj)), 1)) {
      expr_type = DEFINED_CONST;
    }
    break;
  case DEFINED_FUNC:
    klass = rb_class_of((VALUE)(v));
    if (rb_method_boundp(klass, (rb_sym2id(obj)), 0)) {
      expr_type = DEFINED_METHOD;
    } else {
      expr_type = check_respond_to_missing(obj, v);
    }
    break;
  case DEFINED_METHOD: {
    VALUE klass = rb_class_of((VALUE)(v));
    const rb_method_entry_t *me = rb_method_entry(klass, (rb_sym2id(obj)));

    if (me) {
      switch ((rb_method_visibility_t)(
          ((me)->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
          ((((VALUE)RUBY_FL_USHIFT) + 4) + 0))) {
      case METHOD_VISI_PRIVATE:
        break;
      case METHOD_VISI_PROTECTED:
        if (!rb_obj_is_kind_of((((((reg_cfp)))->self)), rb_class_real(klass))) {
          break;
        }
      case METHOD_VISI_PUBLIC:
        expr_type = DEFINED_METHOD;
        break;
      default:
        rb_bug("vm_defined: unreachable: %u",
               (unsigned int)(rb_method_visibility_t)(
                   ((me)->flags &
                    (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)));
      }
    } else {
      expr_type = check_respond_to_missing(obj, v);
    }
    break;
  }
  case DEFINED_YIELD:
    if (((VM_EP_LEP(((((reg_cfp)->ep)))))[(-1)]) != 0) {
      expr_type = DEFINED_YIELD;
    }
    break;
  case DEFINED_ZSUPER: {
    const rb_callable_method_entry_t *me =
        rb_vm_frame_method_entry((((reg_cfp))));

    if (me) {
      VALUE klass = vm_search_normal_superclass(me->defined_class);
      ID id = me->def->original_id;

      if (rb_method_boundp(klass, id, 0)) {
        expr_type = DEFINED_ZSUPER;
      }
    }
  } break;
  case DEFINED_REF: {
    if (vm_getspecial(ec, (VM_EP_LEP(((((reg_cfp)->ep))))),
                      ((VALUE)RUBY_Qfalse),
                      ((int)rb_fix2int((VALUE)(obj)))) != ((VALUE)RUBY_Qnil)) {
      expr_type = DEFINED_GVAR;
    }
    break;
  }
  default:
    rb_bug("unimplemented defined? type (VM)");
    break;
  }

  if (expr_type != 0) {
    if (needstr != ((VALUE)RUBY_Qfalse)) {
      return rb_iseq_defined_string(expr_type);
    } else {
      return ((VALUE)RUBY_Qtrue);
    }
  } else {
    return ((VALUE)RUBY_Qnil);
  }
}

static const VALUE *vm_get_ep(const VALUE *const reg_ep, rb_num_t lv) {
  rb_num_t i;
  const VALUE *ep = reg_ep;
  for (i = 0; i < lv; i++) {
    ep = ((VALUE *)((ep)[(-1)] & ~0x03));
  }
  return ep;
}

static VALUE vm_get_special_object(const VALUE *const reg_ep,
                                   enum vm_special_object_type type) {
  switch (type) {
  case VM_SPECIAL_OBJECT_VMCORE:
    return rb_mRubyVMFrozenCore;
  case VM_SPECIAL_OBJECT_CBASE:
    return vm_get_cbase(reg_ep);
  case VM_SPECIAL_OBJECT_CONST_BASE:
    return vm_get_const_base(reg_ep);
  default:
    rb_bug("putspecialobject insn: unknown value_type %d", type);
  }
}

static void vm_freezestring(VALUE str, VALUE debug) {
  if (!!((VALUE)(debug) != ((VALUE)RUBY_Qnil))) {
    rb_ivar_set(str, id_debug_created_info, debug);
  }
  rb_str_freeze(str);
}

static VALUE vm_concat_array(VALUE ary1, VALUE ary2st) {
  const VALUE ary2 = ary2st;
  VALUE tmp1 = rb_check_to_array(ary1);
  VALUE tmp2 = rb_check_to_array(ary2);

  if (!((VALUE)(tmp1) != ((VALUE)RUBY_Qnil))) {
    tmp1 = __extension__({
      const VALUE args_to_new_ary[] = {ary1};
      if (__builtin_constant_p(1)) {
        _Static_assert(((int)(sizeof(args_to_new_ary) /
                              sizeof((args_to_new_ary)[0]))) == (1),
                       "rb_ary_new_from_args"
                       ": "
                       "numberof(args_to_new_ary) == (1)");
      }
      rb_ary_new_from_values(
          ((int)(sizeof(args_to_new_ary) / sizeof((args_to_new_ary)[0]))),
          args_to_new_ary);
    });
  }

  if (!((VALUE)(tmp2) != ((VALUE)RUBY_Qnil))) {
    tmp2 = __extension__({
      const VALUE args_to_new_ary[] = {ary2};
      if (__builtin_constant_p(1)) {
        _Static_assert(((int)(sizeof(args_to_new_ary) /
                              sizeof((args_to_new_ary)[0]))) == (1),
                       "rb_ary_new_from_args"
                       ": "
                       "numberof(args_to_new_ary) == (1)");
      }
      rb_ary_new_from_values(
          ((int)(sizeof(args_to_new_ary) / sizeof((args_to_new_ary)[0]))),
          args_to_new_ary);
    });
  }

  if (tmp1 == ary1) {
    tmp1 = rb_ary_dup(ary1);
  }
  return rb_ary_concat(tmp1, tmp2);
}

static VALUE vm_splat_array(VALUE flag, VALUE ary) {
  VALUE tmp = rb_check_to_array(ary);
  if (!((VALUE)(tmp) != ((VALUE)RUBY_Qnil))) {
    return __extension__({
      const VALUE args_to_new_ary[] = {ary};
      if (__builtin_constant_p(1)) {
        _Static_assert(((int)(sizeof(args_to_new_ary) /
                              sizeof((args_to_new_ary)[0]))) == (1),
                       "rb_ary_new_from_args"
                       ": "
                       "numberof(args_to_new_ary) == (1)");
      }
      rb_ary_new_from_values(
          ((int)(sizeof(args_to_new_ary) / sizeof((args_to_new_ary)[0]))),
          args_to_new_ary);
    });
  } else if (!(((VALUE)(flag) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
    return rb_ary_dup(tmp);
  } else {
    return tmp;
  }
}

static VALUE vm_check_match(rb_execution_context_t *ec, VALUE target,
                            VALUE pattern, rb_num_t flag) {
  enum vm_check_match_type type = ((int)flag) & 0x03;

  if (flag & 0x04) {
    long i;
    const long n = rb_array_len(pattern);

    for (i = 0; i < n; i++) {
      VALUE v = (rb_array_const_ptr_transient(pattern)[i]);
      VALUE c = check_match(ec, v, target, type);

      if (!(((VALUE)(c) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
        return c;
      }
    }
    return ((VALUE)RUBY_Qfalse);
  } else {
    return check_match(ec, pattern, target, type);
  }
}

static VALUE vm_check_keyword(lindex_t bits, lindex_t idx, const VALUE *ep) {
  const VALUE kw_bits = *(ep - bits);

  if ((((int)(long)(kw_bits)) & RUBY_FIXNUM_FLAG)) {
    unsigned int b =
        (unsigned int)((unsigned long)((long)(((long)(kw_bits)) >> (int)(1))));
    if ((idx < (32 - 1)) && (b & (0x01 << idx)))
      return ((VALUE)RUBY_Qfalse);
  } else {
    ((void)0);
    if (rb_hash_has_key(kw_bits, (((VALUE)(idx)) << 1 | RUBY_FIXNUM_FLAG)))
      return ((VALUE)RUBY_Qfalse);
  }
  return ((VALUE)RUBY_Qtrue);
}

static void vm_dtrace(rb_event_flag_t flag, rb_execution_context_t *ec) {
  if (({
        int _r = __dtrace_isenabled$ruby$method__entry$v1();
        __asm__ volatile("");
        _r;
      }) ||
      ({
        int _r = __dtrace_isenabled$ruby$method__return$v1();
        __asm__ volatile("");
        _r;
      }) ||
      ({
        int _r = __dtrace_isenabled$ruby$cmethod__entry$v1();
        __asm__ volatile("");
        _r;
      }) ||
      ({
        int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
        __asm__ volatile("");
        _r;
      })) {

    switch (flag) {
    case 0x0008:
      do {
        if ((__builtin_expect(!!(({
              int _r = __dtrace_isenabled$ruby$method__entry$v1();
              __asm__ volatile("");
              _r;
            })),
                              0))) {
          struct ruby_dtrace_method_hook_args args;
          if (rb_dtrace_setup(ec, 0, 0, &args)) {
            do {
              __asm__ volatile(".reference "
                               "___dtrace_typedefs$ruby$v2");
              __dtrace_probe$ruby$method__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
                  args.classname, args.methodname, args.filename, args.line_no);
              __asm__ volatile(
                  ".reference "
                  "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
            } while (0);
          }
        }
      } while (0);
      return;
    case 0x0020:
      do {
        if ((__builtin_expect(!!(({
              int _r = __dtrace_isenabled$ruby$cmethod__entry$v1();
              __asm__ volatile("");
              _r;
            })),
                              0))) {
          struct ruby_dtrace_method_hook_args args;
          if (rb_dtrace_setup(ec, 0, 0, &args)) {
            do {
              __asm__ volatile(".reference "
                               "___dtrace_typedefs$ruby$v2");
              __dtrace_probe$ruby$cmethod__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
                  args.classname, args.methodname, args.filename, args.line_no);
              __asm__ volatile(
                  ".reference "
                  "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
            } while (0);
          }
        }
      } while (0);
      return;
    case 0x0010:
      do {
        if ((__builtin_expect(!!(({
              int _r = __dtrace_isenabled$ruby$method__return$v1();
              __asm__ volatile("");
              _r;
            })),
                              0))) {
          struct ruby_dtrace_method_hook_args args;
          if (rb_dtrace_setup(ec, 0, 0, &args)) {
            do {
              __asm__ volatile(".reference "
                               "___dtrace_typedefs$ruby$v2");
              __dtrace_probe$ruby$method__return$v1$63686172202a$63686172202a$63686172202a$696e74(
                  args.classname, args.methodname, args.filename, args.line_no);
              __asm__ volatile(
                  ".reference "
                  "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
            } while (0);
          }
        }
      } while (0);
      return;
    case 0x0040:
      do {
        if ((__builtin_expect(!!(({
              int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
              __asm__ volatile("");
              _r;
            })),
                              0))) {
          struct ruby_dtrace_method_hook_args args;
          if (rb_dtrace_setup(ec, 0, 0, &args)) {
            do {
              __asm__ volatile(".reference "
                               "___dtrace_typedefs$ruby$v2");
              __dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
                  args.classname, args.methodname, args.filename, args.line_no);
              __asm__ volatile(
                  ".reference "
                  "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
            } while (0);
          }
        }
      } while (0);
      return;
    }
  }
}

static VALUE vm_const_get_under(ID id, rb_num_t flags, VALUE cbase) {
  VALUE ns;

  if ((ns = vm_search_const_defined_class(cbase, id)) == 0) {
    return ns;
  } else if (((flags)&0x08)) {
    return rb_public_const_get_at(ns, id);
  } else {
    return rb_const_get_at(ns, id);
  }
}

static VALUE vm_check_if_class(ID id, rb_num_t flags, VALUE super,
                               VALUE klass) {
  if (!(((RUBY_T_CLASS) == RUBY_T_FIXNUM)
            ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_CLASS) == RUBY_T_TRUE)
                  ? ((klass) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_CLASS) == RUBY_T_FALSE)
                        ? ((klass) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_CLASS) == RUBY_T_NIL)
                              ? ((klass) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_CLASS) == RUBY_T_UNDEF)
                                    ? ((klass) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_CLASS) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(klass) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    klass)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(klass) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(klass))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_CLASS) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(klass)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          klass)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(klass) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(klass))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_CLASS)))) {
    rb_raise(rb_eTypeError,
             "%"
             "l"
             "i"
             "\v"
             " is not a class",
             rb_id2str(id));
  } else if (((flags)&0x10)) {
    VALUE tmp = rb_class_real(RCLASS_SUPER(klass));

    if (tmp != super) {
      rb_raise(rb_eTypeError,
               "superclass mismatch for class %"
               "l"
               "i"
               "\v"
               "",
               rb_id2str(id));
    } else {
      return klass;
    }
  } else {
    return klass;
  }
}

static VALUE vm_check_if_module(ID id, VALUE mod) {
  if (!(((RUBY_T_MODULE) == RUBY_T_FIXNUM)
            ? (((int)(long)(mod)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                  ? ((mod) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                        ? ((mod) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_MODULE) == RUBY_T_NIL)
                              ? ((mod) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                    ? ((mod) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(mod) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    mod)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(mod) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(mod))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(mod)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          mod)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(mod) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(mod))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         mod)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(mod) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(mod))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_MODULE)))) {
    rb_raise(rb_eTypeError,
             "%"
             "l"
             "i"
             "\v"
             " is not a module",
             rb_id2str(id));
  } else {
    return mod;
  }
}

static VALUE vm_declare_class(ID id, rb_num_t flags, VALUE cbase, VALUE super) {

  VALUE s = ((flags)&0x10) ? super : rb_cObject;
  VALUE c = rb_define_class_id(id, s);

  rb_set_class_path_string(c, cbase, rb_id2str(id));
  rb_const_set(cbase, id, c);
  rb_class_inherited(s, c);
  return c;
}

static VALUE vm_declare_module(ID id, VALUE cbase) {

  VALUE mod = rb_define_module_id(id);
  rb_set_class_path_string(mod, cbase, rb_id2str(id));
  rb_const_set(cbase, id, mod);
  return mod;
}

static VALUE vm_define_class(ID id, rb_num_t flags, VALUE cbase, VALUE super) {
  VALUE klass;

  if (((flags)&0x10) &&
      !(((RUBY_T_CLASS) == RUBY_T_FIXNUM)
            ? (((int)(long)(super)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_CLASS) == RUBY_T_TRUE)
                  ? ((super) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_CLASS) == RUBY_T_FALSE)
                        ? ((super) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_CLASS) == RUBY_T_NIL)
                              ? ((super) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_CLASS) == RUBY_T_UNDEF)
                                    ? ((super) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_CLASS) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(super) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    super)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(super) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(super))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_CLASS) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(super)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          super)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(super) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(super))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         super)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(super) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(super))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_CLASS)))) {
    rb_raise(rb_eTypeError,
             "superclass must be a Class (%"
             "l"
             "i"
             "\v"
             " given)",
             rb_obj_class(super));
  }

  vm_check_if_namespace(cbase);

  rb_autoload_load(cbase, id);
  if ((klass = vm_const_get_under(id, flags, cbase)) != 0) {
    return vm_check_if_class(id, flags, super, klass);
  } else {
    return vm_declare_class(id, flags, cbase, super);
  }
}

static VALUE vm_define_module(ID id, rb_num_t flags, VALUE cbase) {
  VALUE mod;

  vm_check_if_namespace(cbase);
  if ((mod = vm_const_get_under(id, flags, cbase)) != 0) {
    return vm_check_if_module(id, mod);
  } else {
    return vm_declare_module(id, cbase);
  }
}

static VALUE vm_find_or_create_class_by_id(ID id, rb_num_t flags, VALUE cbase,
                                           VALUE super) {
  rb_vm_defineclass_type_t type =
      ((rb_vm_defineclass_type_t)(flags)&VM_DEFINECLASS_TYPE_MASK);

  switch (type) {
  case VM_DEFINECLASS_TYPE_CLASS:

    return vm_define_class(id, flags, cbase, super);

  case VM_DEFINECLASS_TYPE_SINGLETON_CLASS:

    return rb_singleton_class(cbase);

  case VM_DEFINECLASS_TYPE_MODULE:

    return vm_define_module(id, flags, cbase);

  default:
    rb_bug("unknown defineclass type: %d", (int)type);
  }
}

static VALUE vm_opt_str_freeze(VALUE str, int bop, ID id) {
  if (((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(bop)] & ((1 << 2))) == 0),
          1)))) {
    return str;
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_newarray_max(rb_num_t num, const VALUE *ptr) {
  if (((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MAX)] & ((1 << 3))) == 0),
          1)))) {
    if (num == 0) {
      return ((VALUE)RUBY_Qnil);
    } else {
      struct cmp_opt_data cmp_opt = {0, 0};
      VALUE result = *ptr;
      rb_snum_t i = num - 1;
      while (i-- > 0) {
        const VALUE v = *++ptr;
        if ((((((int)(long)(v)) & RUBY_FIXNUM_FLAG) &&
              (((int)(long)(result)) & RUBY_FIXNUM_FLAG) &&
              (((cmp_opt).opt_inited & (1U << cmp_opt_Fixnum))
                   ? ((cmp_opt).opt_methods & (1U << cmp_opt_Fixnum))
                   : (((cmp_opt).opt_inited |= (1U << cmp_opt_Fixnum)),
                      rb_method_basic_definition_p(rb_cInteger, idCmp) &&
                          ((cmp_opt).opt_methods |= (1U << cmp_opt_Fixnum)))))
                 ? (((long)v > (long)result)
                        ? 1
                        : ((long)v < (long)result) ? -1 : 0)
                 : (((((RUBY_T_STRING) == RUBY_T_FIXNUM)
                          ? (((int)(long)((v))) & RUBY_FIXNUM_FLAG)
                          : ((RUBY_T_STRING) == RUBY_T_TRUE)
                                ? (((v)) == ((VALUE)RUBY_Qtrue))
                                : ((RUBY_T_STRING) == RUBY_T_FALSE)
                                      ? (((v)) == ((VALUE)RUBY_Qfalse))
                                      : ((RUBY_T_STRING) == RUBY_T_NIL)
                                            ? (((v)) == ((VALUE)RUBY_Qnil))
                                            : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                                  ? (((v)) ==
                                                     ((VALUE)RUBY_Qundef))
                                                  : ((RUBY_T_STRING) ==
                                                     RUBY_T_SYMBOL)
                                                        ? ((((VALUE)((v)) &
                                                             ~((~(VALUE)0)
                                                               << RUBY_SPECIAL_SHIFT)) ==
                                                            RUBY_SYMBOL_FLAG) ||
                                                           (!(((VALUE)((v)) &
                                                               RUBY_IMMEDIATE_MASK) ||
                                                              !!(((VALUE)((v)) &
                                                                  (VALUE) ~(
                                                                      (VALUE)
                                                                          RUBY_Qnil)) ==
                                                                 0)) &&
                                                            (int)(((struct
                                                                    RBasic *)((
                                                                       v)))
                                                                      ->flags &
                                                                  RUBY_T_MASK) ==
                                                                (RUBY_T_SYMBOL)))
                                                        : ((RUBY_T_STRING) ==
                                                           RUBY_T_FLOAT)
                                                              ? (((((int)(long)((
                                                                       v))) &
                                                                   RUBY_FLONUM_MASK) ==
                                                                  RUBY_FLONUM_FLAG) ||
                                                                 (!(((VALUE)(
                                                                         (v)) &
                                                                     RUBY_IMMEDIATE_MASK) ||
                                                                    !!(((VALUE)(
                                                                            (v)) &
                                                                        (VALUE) ~(
                                                                            (VALUE)
                                                                                RUBY_Qnil)) ==
                                                                       0)) &&
                                                                  (int)(((struct
                                                                          RBasic
                                                                              *)((
                                                                             v)))
                                                                            ->flags &
                                                                        RUBY_T_MASK) ==
                                                                      RUBY_T_FLOAT))
                                                              : (!(((VALUE)(
                                                                        (v)) &
                                                                    RUBY_IMMEDIATE_MASK) ||
                                                                   !!(((VALUE)((
                                                                           v)) &
                                                                       (VALUE) ~(
                                                                           (VALUE)
                                                                               RUBY_Qnil)) ==
                                                                      0)) &&
                                                                 (int)(((struct
                                                                         RBasic
                                                                             *)((
                                                                            v)))
                                                                           ->flags &
                                                                       RUBY_T_MASK) ==
                                                                     (RUBY_T_STRING))) &&
                     rb_class_of((VALUE)(v)) == rb_cString) &&
                    ((((RUBY_T_STRING) == RUBY_T_FIXNUM)
                          ? (((int)(long)((result))) & RUBY_FIXNUM_FLAG)
                          : ((RUBY_T_STRING) == RUBY_T_TRUE)
                                ? (((result)) == ((VALUE)RUBY_Qtrue))
                                : ((RUBY_T_STRING) == RUBY_T_FALSE)
                                      ? (((result)) == ((VALUE)RUBY_Qfalse))
                                      : ((RUBY_T_STRING) == RUBY_T_NIL)
                                            ? (((result)) == ((VALUE)RUBY_Qnil))
                                            : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                                  ? (((result)) ==
                                                     ((VALUE)RUBY_Qundef))
                                                  : ((RUBY_T_STRING) ==
                                                     RUBY_T_SYMBOL)
                                                        ? ((((VALUE)((result)) &
                                                             ~((~(VALUE)0)
                                                               << RUBY_SPECIAL_SHIFT)) ==
                                                            RUBY_SYMBOL_FLAG) ||
                                                           (!(((VALUE)(
                                                                   (result)) &
                                                               RUBY_IMMEDIATE_MASK) ||
                                                              !!(((VALUE)((
                                                                      result)) &
                                                                  (VALUE) ~(
                                                                      (VALUE)
                                                                          RUBY_Qnil)) ==
                                                                 0)) &&
                                                            (int)(((struct
                                                                    RBasic *)((
                                                                       result)))
                                                                      ->flags &
                                                                  RUBY_T_MASK) ==
                                                                (RUBY_T_SYMBOL)))
                                                        : ((RUBY_T_STRING) ==
                                                           RUBY_T_FLOAT)
                                                              ? (((((int)(long)((
                                                                       result))) &
                                                                   RUBY_FLONUM_MASK) ==
                                                                  RUBY_FLONUM_FLAG) ||
                                                                 (!(((VALUE)((
                                                                         result)) &
                                                                     RUBY_IMMEDIATE_MASK) ||
                                                                    !!(((VALUE)((
                                                                            result)) &
                                                                        (VALUE) ~(
                                                                            (VALUE)
                                                                                RUBY_Qnil)) ==
                                                                       0)) &&
                                                                  (int)(((struct
                                                                          RBasic
                                                                              *)((
                                                                             result)))
                                                                            ->flags &
                                                                        RUBY_T_MASK) ==
                                                                      RUBY_T_FLOAT))
                                                              : (!(((VALUE)((
                                                                        result)) &
                                                                    RUBY_IMMEDIATE_MASK) ||
                                                                   !!(((VALUE)((
                                                                           result)) &
                                                                       (VALUE) ~(
                                                                           (VALUE)
                                                                               RUBY_Qnil)) ==
                                                                      0)) &&
                                                                 (int)(((struct
                                                                         RBasic
                                                                             *)((
                                                                            result)))
                                                                           ->flags &
                                                                       RUBY_T_MASK) ==
                                                                     (RUBY_T_STRING))) &&
                     rb_class_of((VALUE)(result)) == rb_cString) &&
                    (((cmp_opt).opt_inited & (1U << cmp_opt_String))
                         ? ((cmp_opt).opt_methods & (1U << cmp_opt_String))
                         : (((cmp_opt).opt_inited |= (1U << cmp_opt_String)),
                            rb_method_basic_definition_p(rb_cString, idCmp) &&
                                ((cmp_opt).opt_methods |=
                                 (1U << cmp_opt_String)))))
                       ? rb_str_cmp(v, result)
                       : ((((((int)(long)(v)) & RUBY_FLONUM_MASK) ==
                            RUBY_FLONUM_FLAG) ||
                           (!(((VALUE)(v)&RUBY_IMMEDIATE_MASK) ||
                              !!(((VALUE)(v) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                                 0)) &&
                            (int)(((struct RBasic *)(v))->flags &
                                  RUBY_T_MASK) == RUBY_T_FLOAT)) &&
                          (((((int)(long)(result)) & RUBY_FLONUM_MASK) ==
                            RUBY_FLONUM_FLAG) ||
                           (!(((VALUE)(result)&RUBY_IMMEDIATE_MASK) ||
                              !!(((VALUE)(result) &
                                  (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
                            (int)(((struct RBasic *)(result))->flags &
                                  RUBY_T_MASK) == RUBY_T_FLOAT)) &&
                          (((cmp_opt).opt_inited & (1U << cmp_opt_Float))
                               ? ((cmp_opt).opt_methods & (1U << cmp_opt_Float))
                               : (((cmp_opt).opt_inited |=
                                   (1U << cmp_opt_Float)),
                                  rb_method_basic_definition_p(rb_cFloat,
                                                               idCmp) &&
                                      ((cmp_opt).opt_methods |=
                                       (1U << cmp_opt_Float)))))
                             ? rb_float_cmp(v, result)
                             : rb_cmpint(rb_funcallv(v, idCmp, 1, &result), v,
                                         result)) > 0) {
          result = v;
        }
      }
      return result;
    }
  } else {
    VALUE ary = rb_ary_new_from_values(num, ptr);
    return __extension__({
      const int rb_funcall_argc = (0);
      const VALUE rb_funcall_args[] = {};
      const int rb_funcall_nargs =
          (int)(sizeof(rb_funcall_args) / sizeof(VALUE));
      rb_funcallv(ary, idMax,
                  __builtin_choose_expr(
                      __builtin_constant_p(rb_funcall_argc),
                      (((rb_funcall_argc) == 0
                            ? (rb_funcall_nargs) <= 1
                            : (rb_funcall_argc) == (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : ((rb_funcall_argc) /
                              ((rb_funcall_argc) == 0
                                   ? (rb_funcall_nargs) <= 1
                                   : (rb_funcall_argc) == (rb_funcall_nargs)))),
                      (((rb_funcall_argc) <= (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : (rb_fatal("argc(%d) exceeds actual arguments(%d)",
                                       rb_funcall_argc, rb_funcall_nargs),
                              0))),
                  rb_funcall_nargs ? rb_funcall_args : ((void *)0));
    });
  }
}

static VALUE vm_opt_newarray_min(rb_num_t num, const VALUE *ptr) {
  if (((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MIN)] & ((1 << 3))) == 0),
          1)))) {
    if (num == 0) {
      return ((VALUE)RUBY_Qnil);
    } else {
      struct cmp_opt_data cmp_opt = {0, 0};
      VALUE result = *ptr;
      rb_snum_t i = num - 1;
      while (i-- > 0) {
        const VALUE v = *++ptr;
        if ((((((int)(long)(v)) & RUBY_FIXNUM_FLAG) &&
              (((int)(long)(result)) & RUBY_FIXNUM_FLAG) &&
              (((cmp_opt).opt_inited & (1U << cmp_opt_Fixnum))
                   ? ((cmp_opt).opt_methods & (1U << cmp_opt_Fixnum))
                   : (((cmp_opt).opt_inited |= (1U << cmp_opt_Fixnum)),
                      rb_method_basic_definition_p(rb_cInteger, idCmp) &&
                          ((cmp_opt).opt_methods |= (1U << cmp_opt_Fixnum)))))
                 ? (((long)v > (long)result)
                        ? 1
                        : ((long)v < (long)result) ? -1 : 0)
                 : (((((RUBY_T_STRING) == RUBY_T_FIXNUM)
                          ? (((int)(long)((v))) & RUBY_FIXNUM_FLAG)
                          : ((RUBY_T_STRING) == RUBY_T_TRUE)
                                ? (((v)) == ((VALUE)RUBY_Qtrue))
                                : ((RUBY_T_STRING) == RUBY_T_FALSE)
                                      ? (((v)) == ((VALUE)RUBY_Qfalse))
                                      : ((RUBY_T_STRING) == RUBY_T_NIL)
                                            ? (((v)) == ((VALUE)RUBY_Qnil))
                                            : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                                  ? (((v)) ==
                                                     ((VALUE)RUBY_Qundef))
                                                  : ((RUBY_T_STRING) ==
                                                     RUBY_T_SYMBOL)
                                                        ? ((((VALUE)((v)) &
                                                             ~((~(VALUE)0)
                                                               << RUBY_SPECIAL_SHIFT)) ==
                                                            RUBY_SYMBOL_FLAG) ||
                                                           (!(((VALUE)((v)) &
                                                               RUBY_IMMEDIATE_MASK) ||
                                                              !!(((VALUE)((v)) &
                                                                  (VALUE) ~(
                                                                      (VALUE)
                                                                          RUBY_Qnil)) ==
                                                                 0)) &&
                                                            (int)(((struct
                                                                    RBasic *)((
                                                                       v)))
                                                                      ->flags &
                                                                  RUBY_T_MASK) ==
                                                                (RUBY_T_SYMBOL)))
                                                        : ((RUBY_T_STRING) ==
                                                           RUBY_T_FLOAT)
                                                              ? (((((int)(long)((
                                                                       v))) &
                                                                   RUBY_FLONUM_MASK) ==
                                                                  RUBY_FLONUM_FLAG) ||
                                                                 (!(((VALUE)(
                                                                         (v)) &
                                                                     RUBY_IMMEDIATE_MASK) ||
                                                                    !!(((VALUE)(
                                                                            (v)) &
                                                                        (VALUE) ~(
                                                                            (VALUE)
                                                                                RUBY_Qnil)) ==
                                                                       0)) &&
                                                                  (int)(((struct
                                                                          RBasic
                                                                              *)((
                                                                             v)))
                                                                            ->flags &
                                                                        RUBY_T_MASK) ==
                                                                      RUBY_T_FLOAT))
                                                              : (!(((VALUE)(
                                                                        (v)) &
                                                                    RUBY_IMMEDIATE_MASK) ||
                                                                   !!(((VALUE)((
                                                                           v)) &
                                                                       (VALUE) ~(
                                                                           (VALUE)
                                                                               RUBY_Qnil)) ==
                                                                      0)) &&
                                                                 (int)(((struct
                                                                         RBasic
                                                                             *)((
                                                                            v)))
                                                                           ->flags &
                                                                       RUBY_T_MASK) ==
                                                                     (RUBY_T_STRING))) &&
                     rb_class_of((VALUE)(v)) == rb_cString) &&
                    ((((RUBY_T_STRING) == RUBY_T_FIXNUM)
                          ? (((int)(long)((result))) & RUBY_FIXNUM_FLAG)
                          : ((RUBY_T_STRING) == RUBY_T_TRUE)
                                ? (((result)) == ((VALUE)RUBY_Qtrue))
                                : ((RUBY_T_STRING) == RUBY_T_FALSE)
                                      ? (((result)) == ((VALUE)RUBY_Qfalse))
                                      : ((RUBY_T_STRING) == RUBY_T_NIL)
                                            ? (((result)) == ((VALUE)RUBY_Qnil))
                                            : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                                  ? (((result)) ==
                                                     ((VALUE)RUBY_Qundef))
                                                  : ((RUBY_T_STRING) ==
                                                     RUBY_T_SYMBOL)
                                                        ? ((((VALUE)((result)) &
                                                             ~((~(VALUE)0)
                                                               << RUBY_SPECIAL_SHIFT)) ==
                                                            RUBY_SYMBOL_FLAG) ||
                                                           (!(((VALUE)(
                                                                   (result)) &
                                                               RUBY_IMMEDIATE_MASK) ||
                                                              !!(((VALUE)((
                                                                      result)) &
                                                                  (VALUE) ~(
                                                                      (VALUE)
                                                                          RUBY_Qnil)) ==
                                                                 0)) &&
                                                            (int)(((struct
                                                                    RBasic *)((
                                                                       result)))
                                                                      ->flags &
                                                                  RUBY_T_MASK) ==
                                                                (RUBY_T_SYMBOL)))
                                                        : ((RUBY_T_STRING) ==
                                                           RUBY_T_FLOAT)
                                                              ? (((((int)(long)((
                                                                       result))) &
                                                                   RUBY_FLONUM_MASK) ==
                                                                  RUBY_FLONUM_FLAG) ||
                                                                 (!(((VALUE)((
                                                                         result)) &
                                                                     RUBY_IMMEDIATE_MASK) ||
                                                                    !!(((VALUE)((
                                                                            result)) &
                                                                        (VALUE) ~(
                                                                            (VALUE)
                                                                                RUBY_Qnil)) ==
                                                                       0)) &&
                                                                  (int)(((struct
                                                                          RBasic
                                                                              *)((
                                                                             result)))
                                                                            ->flags &
                                                                        RUBY_T_MASK) ==
                                                                      RUBY_T_FLOAT))
                                                              : (!(((VALUE)((
                                                                        result)) &
                                                                    RUBY_IMMEDIATE_MASK) ||
                                                                   !!(((VALUE)((
                                                                           result)) &
                                                                       (VALUE) ~(
                                                                           (VALUE)
                                                                               RUBY_Qnil)) ==
                                                                      0)) &&
                                                                 (int)(((struct
                                                                         RBasic
                                                                             *)((
                                                                            result)))
                                                                           ->flags &
                                                                       RUBY_T_MASK) ==
                                                                     (RUBY_T_STRING))) &&
                     rb_class_of((VALUE)(result)) == rb_cString) &&
                    (((cmp_opt).opt_inited & (1U << cmp_opt_String))
                         ? ((cmp_opt).opt_methods & (1U << cmp_opt_String))
                         : (((cmp_opt).opt_inited |= (1U << cmp_opt_String)),
                            rb_method_basic_definition_p(rb_cString, idCmp) &&
                                ((cmp_opt).opt_methods |=
                                 (1U << cmp_opt_String)))))
                       ? rb_str_cmp(v, result)
                       : ((((((int)(long)(v)) & RUBY_FLONUM_MASK) ==
                            RUBY_FLONUM_FLAG) ||
                           (!(((VALUE)(v)&RUBY_IMMEDIATE_MASK) ||
                              !!(((VALUE)(v) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                                 0)) &&
                            (int)(((struct RBasic *)(v))->flags &
                                  RUBY_T_MASK) == RUBY_T_FLOAT)) &&
                          (((((int)(long)(result)) & RUBY_FLONUM_MASK) ==
                            RUBY_FLONUM_FLAG) ||
                           (!(((VALUE)(result)&RUBY_IMMEDIATE_MASK) ||
                              !!(((VALUE)(result) &
                                  (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
                            (int)(((struct RBasic *)(result))->flags &
                                  RUBY_T_MASK) == RUBY_T_FLOAT)) &&
                          (((cmp_opt).opt_inited & (1U << cmp_opt_Float))
                               ? ((cmp_opt).opt_methods & (1U << cmp_opt_Float))
                               : (((cmp_opt).opt_inited |=
                                   (1U << cmp_opt_Float)),
                                  rb_method_basic_definition_p(rb_cFloat,
                                                               idCmp) &&
                                      ((cmp_opt).opt_methods |=
                                       (1U << cmp_opt_Float)))))
                             ? rb_float_cmp(v, result)
                             : rb_cmpint(rb_funcallv(v, idCmp, 1, &result), v,
                                         result)) < 0) {
          result = v;
        }
      }
      return result;
    }
  } else {
    VALUE ary = rb_ary_new_from_values(num, ptr);
    return __extension__({
      const int rb_funcall_argc = (0);
      const VALUE rb_funcall_args[] = {};
      const int rb_funcall_nargs =
          (int)(sizeof(rb_funcall_args) / sizeof(VALUE));
      rb_funcallv(ary, idMin,
                  __builtin_choose_expr(
                      __builtin_constant_p(rb_funcall_argc),
                      (((rb_funcall_argc) == 0
                            ? (rb_funcall_nargs) <= 1
                            : (rb_funcall_argc) == (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : ((rb_funcall_argc) /
                              ((rb_funcall_argc) == 0
                                   ? (rb_funcall_nargs) <= 1
                                   : (rb_funcall_argc) == (rb_funcall_nargs)))),
                      (((rb_funcall_argc) <= (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : (rb_fatal("argc(%d) exceeds actual arguments(%d)",
                                       rb_funcall_argc, rb_funcall_nargs),
                              0))),
                  rb_funcall_nargs ? rb_funcall_args : ((void *)0));
    });
  }
}

static int vm_ic_hit_p(IC ic, const VALUE *reg_ep) {
  if (ic->ic_serial == (ruby_vm_global_constant_state)) {
    return (ic->ic_cref == ((void *)0) ||
            ic->ic_cref == rb_vm_get_cref(reg_ep));
  }
  return 0;
}

static void vm_ic_update(IC ic, VALUE val, const VALUE *reg_ep) {
  ((void)0);
  ic->ic_value.value = val;
  ic->ic_serial = (ruby_vm_global_constant_state)-ruby_vm_const_missing_count;
  ic->ic_cref = vm_get_const_key_cref(reg_ep);
  ruby_vm_const_missing_count = 0;
}

static VALUE vm_once_dispatch(rb_execution_context_t *ec, ISEQ iseq, ISE is) {
  rb_thread_t *th = rb_ec_thread_ptr(ec);
  rb_thread_t *const RUNNING_THREAD_ONCE_DONE = (rb_thread_t *)(0x1);

again:
  if (is->once.running_thread == RUNNING_THREAD_ONCE_DONE) {
    return is->once.value;
  } else if (is->once.running_thread == ((void *)0)) {
    VALUE val;
    is->once.running_thread = th;
    val = rb_ensure(vm_once_exec, (VALUE)iseq, vm_once_clear, (VALUE)is);
    __extension__({
# 3291 "./vm_insnhelper.c"
#pragma clang diagnostic push
# 3291 "./vm_insnhelper.c"
      ;
# 3291 "./vm_insnhelper.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 3291 "./vm_insnhelper.c"
      ;
      typeof(rb_obj_write((VALUE)(ec->cfp->iseq), (VALUE *)(&is->once.value),
                          (VALUE)(val), "./vm_insnhelper.c", 3291))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(ec->cfp->iseq), (VALUE *)(&is->once.value),
                            (VALUE)(val), "./vm_insnhelper.c", 3291));
# 3291 "./vm_insnhelper.c"
#pragma clang diagnostic pop
# 3291 "./vm_insnhelper.c"
      ;
      unaligned_member_access_result;
    });

    is->once.running_thread = RUNNING_THREAD_ONCE_DONE;
    return val;
  } else if (is->once.running_thread == th) {

    return vm_once_exec((VALUE)iseq);
  } else {

    rb_vm_check_ints(ec);
    rb_thread_schedule();
    goto again;
  }
}

static OFFSET vm_case_dispatch(CDHASH hash, OFFSET else_offset, VALUE key) {
  switch (__extension__({
    VALUE arg_obj = (key);
    (((VALUE)(arg_obj)&RUBY_IMMEDIATE_MASK) ||
     !!(((VALUE)(arg_obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))
        ? -1
        : (int)(((struct RBasic *)(arg_obj))->flags & RUBY_T_MASK);
  })) {
  case -1:
  case RUBY_T_FLOAT:
  case RUBY_T_SYMBOL:
  case RUBY_T_BIGNUM:
  case RUBY_T_STRING:
    if (((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_EQQ)] &
                               ((1 << 6) | (1 << 0) | (1 << 1) | (1 << 9) |
                                (1 << 10) | (1 << 11) | (1 << 2))) == 0),
                           1)))) {

      st_data_t val;
      if ((((((int)(long)(key)) & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG) ||
           (!(((VALUE)(key)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(key) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
            (int)(((struct RBasic *)(key))->flags & RUBY_T_MASK) ==
                RUBY_T_FLOAT))) {
        double kval = rb_float_value_inline(key);
        if (!(sizeof(kval) == sizeof(float)
                  ? __inline_isinff((float)(kval))
                  : sizeof(kval) == sizeof(double)
                        ? __inline_isinfd((double)(kval))
                        : __inline_isinfl((long double)(kval))) &&
            modf(kval, &kval) == 0.0) {
          key = (((kval) < (9223372036854775807L >> 1) + 1) &&
                 ((kval) >= (((long)(-9223372036854775807L - 1L)) >> (int)(1))))
                    ? (((VALUE)((long)kval)) << 1 | RUBY_FIXNUM_FLAG)
                    : rb_dbl2big(kval);
        }
      }
      if (rb_hash_stlike_lookup(hash, key, &val)) {
        return ((long)(((long)((VALUE)val)) >> (int)(1)));
      } else {
        return else_offset;
      }
    }
  }
  return 0;
}

__attribute__((__noreturn__)) static void
vm_stack_consistency_error(const rb_execution_context_t *ec,
                           const rb_control_frame_t *, const VALUE *);

static void vm_stack_consistency_error(const rb_execution_context_t *ec,
                                       const rb_control_frame_t *cfp,
                                       const VALUE *bp) {
  const ptrdiff_t nsp = ((cfp->sp) - (ec)->vm_stack);
  const ptrdiff_t nbp = ((bp) - (ec)->vm_stack);
  static const char stack_consistency_error[] = "Stack consistency error (sp: %"
                                                "t"
                                                "d"
                                                ", bp: %"
                                                "t"
                                                "d"
                                                ")";

  VALUE mesg = rb_sprintf(stack_consistency_error, nsp, nbp);
  __extension__({
    (__builtin_constant_p("\n"))
        ? rb_str_cat((mesg), ("\n"), (long)strlen("\n"))
        : rb_str_cat_cstr((mesg), ("\n"));
  });
  rb_str_append(mesg, rb_iseq_disasm(cfp->iseq));
  rb_exc_fatal(rb_exc_new_str(rb_eFatal, mesg));
}

static VALUE vm_opt_plus(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_PLUS)] & ((1 << 0))) == 0),
          1)))) {
    return rb_fix_plus_fix(recv, obj);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_PLUS)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) +
                               rb_float_value_inline(obj));
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_PLUS)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) +
                               rb_float_value_inline(obj));
  } else if ((((struct RBasic *)(recv))->klass) == rb_cString &&
             (((struct RBasic *)(obj))->klass) == rb_cString &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_PLUS)] &
                     ((1 << 2))) == 0),
                 1)))) {
    return rb_str_plus(recv, obj);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cArray &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_PLUS)] &
                     ((1 << 3))) == 0),
                 1)))) {
    return rb_ary_plus(recv, obj);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_minus(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MINUS)] & ((1 << 0))) == 0),
          1)))) {
    return rb_fix_minus_fix(recv, obj);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_MINUS)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) -
                               rb_float_value_inline(obj));
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_MINUS)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) -
                               rb_float_value_inline(obj));
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_mult(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MULT)] & ((1 << 0))) == 0),
          1)))) {
    return rb_fix_mul_fix(recv, obj);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_MULT)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) *
                               rb_float_value_inline(obj));
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_MULT)] &
                     ((1 << 1))) == 0),
                 1)))) {
    return rb_float_new_inline(rb_float_value_inline(recv) *
                               rb_float_value_inline(obj));
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_div(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_DIV)] & ((1 << 0))) == 0),
          1)))) {
    return (((long)(((long)(obj)) >> (int)(1))) == 0)
               ? ((VALUE)RUBY_Qundef)
               : rb_fix_div_fix(recv, obj);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_DIV)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_flo_div_flo(recv, obj);
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_DIV)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_flo_div_flo(recv, obj);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_mod(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MOD)] & ((1 << 0))) == 0),
          1)))) {
    return (((long)(((long)(obj)) >> (int)(1))) == 0)
               ? ((VALUE)RUBY_Qundef)
               : rb_fix_mod_fix(recv, obj);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_MOD)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_new_inline(ruby_float_mod(rb_float_value_inline(recv),
                                              rb_float_value_inline(obj)));
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_MOD)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_new_inline(ruby_float_mod(rb_float_value_inline(recv),
                                              rb_float_value_inline(obj)));
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_neq(CALL_INFO ci, CALL_CACHE cc, CALL_INFO ci_eq,
                        CALL_CACHE cc_eq, VALUE recv, VALUE obj) {
  if (vm_method_cfunc_is(ci, cc, recv, rb_obj_not_equal)) {
    VALUE val = opt_eq_func(recv, obj, ci_eq, cc_eq);

    if (val != ((VALUE)RUBY_Qundef)) {
      return !(((VALUE)(val) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)
                 ? ((VALUE)RUBY_Qfalse)
                 : ((VALUE)RUBY_Qtrue);
    }
  }

  return ((VALUE)RUBY_Qundef);
}

static VALUE vm_opt_lt(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_LT)] & ((1 << 0))) == 0),
          1)))) {
    return (long)recv < (long)obj ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_LT)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_value_inline(recv) < rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_LT)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    ;
    return rb_float_value_inline(recv) < rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_le(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_LE)] & ((1 << 0))) == 0),
          1)))) {
    return (long)recv <= (long)obj ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_LE)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_value_inline(recv) <= rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_LE)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    ;
    return rb_float_value_inline(recv) <= rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_gt(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_GT)] & ((1 << 0))) == 0),
          1)))) {
    return (long)recv > (long)obj ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_GT)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_value_inline(recv) > rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_GT)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    ;
    return rb_float_value_inline(recv) > rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_ge(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_GE)] & ((1 << 0))) == 0),
          1)))) {
    return (long)recv >= (long)obj ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
  } else if ((((((recv) ^ 2) | ((obj) ^ 2)) & 3) == 0) &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_GE)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    return rb_float_value_inline(recv) >= rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) ||
             (((VALUE)(obj)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(obj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cFloat &&
             (((struct RBasic *)(obj))->klass) == rb_cFloat &&
             ((__builtin_expect(!!((rb_current_vm()->redefined_flag[(BOP_GE)] &
                                    ((1 << 1))) == 0),
                                1)))) {
    ;
    return rb_float_value_inline(recv) >= rb_float_value_inline(obj)
               ? ((VALUE)RUBY_Qtrue)
               : ((VALUE)RUBY_Qfalse);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_ltlt(VALUE recv, VALUE obj) {
  if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cString &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_LTLT)] &
                     ((1 << 2))) == 0),
                 1)))) {
    return rb_str_concat(recv, obj);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cArray &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_LTLT)] &
                     ((1 << 3))) == 0),
                 1)))) {
    return rb_ary_push(recv, obj);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_and(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_AND)] & ((1 << 0))) == 0),
          1)))) {
    return rb_long2num_inline(((long)(((long)(recv)) >> (int)(1))) &
                              ((long)(((long)(obj)) >> (int)(1))));
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_or(VALUE recv, VALUE obj) {
  if (((recv) & (obj)&1) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_OR)] & ((1 << 0))) == 0),
          1)))) {
    return rb_long2num_inline(((long)(((long)(recv)) >> (int)(1))) |
                              ((long)(((long)(obj)) >> (int)(1))));
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_aref(VALUE recv, VALUE obj) {
  if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cArray &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_AREF)] &
                     ((1 << 3))) == 0),
                 1)))) {
    if ((((int)(long)(obj)) & RUBY_FIXNUM_FLAG)) {
      return rb_ary_entry_internal(recv, ((long)(((long)(obj)) >> (int)(1))));
    } else {
      return rb_ary_aref1(recv, obj);
    }
  } else if ((((struct RBasic *)(recv))->klass) == rb_cHash &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_AREF)] &
                     ((1 << 4))) == 0),
                 1)))) {
    return rb_hash_aref(recv, obj);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_aset(VALUE recv, VALUE obj, VALUE set) {
  if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cArray &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_ASET)] &
                     ((1 << 3))) == 0),
                 1))) &&
             (((int)(long)(obj)) & RUBY_FIXNUM_FLAG)) {
    rb_ary_store(recv, ((long)(((long)(obj)) >> (int)(1))), set);
    return set;
  } else if ((((struct RBasic *)(recv))->klass) == rb_cHash &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_ASET)] &
                     ((1 << 4))) == 0),
                 1)))) {
    rb_hash_aset(recv, obj, set);
    return set;
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_aref_with(VALUE recv, VALUE key) {
  if (!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
        !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
      (((struct RBasic *)(recv))->klass) == rb_cHash &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_AREF)] & ((1 << 4))) == 0),
          1))) &&
      rb_hash_compare_by_id_p(recv) == ((VALUE)RUBY_Qfalse)) {
    return rb_hash_aref(recv, key);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_aset_with(VALUE recv, VALUE key, VALUE val) {
  if (!(((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
        !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
      (((struct RBasic *)(recv))->klass) == rb_cHash &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_ASET)] & ((1 << 4))) == 0),
          1))) &&
      rb_hash_compare_by_id_p(recv) == ((VALUE)RUBY_Qfalse)) {
    return rb_hash_aset(recv, key, val);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_length(VALUE recv, int bop) {
  if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cString &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(bop)] & ((1 << 2))) == 0),
                 1)))) {
    if (bop == BOP_EMPTY_P) {
      return rb_long2num_inline(
          (!(((struct RBasic *)(recv))->flags & RSTRING_NOEMBED)
               ? (long)((((struct RBasic *)(recv))->flags >>
                         RSTRING_EMBED_LEN_SHIFT) &
                        (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT))
               : ((struct RString *)(recv))->as.heap.len));
    } else {
      return rb_str_length(recv);
    }
  } else if ((((struct RBasic *)(recv))->klass) == rb_cArray &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(bop)] & ((1 << 3))) == 0),
                 1)))) {
    return rb_long2num_inline(rb_array_len(recv));
  } else if ((((struct RBasic *)(recv))->klass) == rb_cHash &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(bop)] & ((1 << 4))) == 0),
                 1)))) {
    return (((VALUE)(
                ((!(((struct RBasic *)((recv)))->flags & (RHASH_ST_TABLE_FLAG)))
                     ? ((unsigned int)((((struct RBasic *)(recv))->flags &
                                        (VALUE)RHASH_ARRAY_SIZE_MASK) >>
                                       RHASH_ARRAY_SIZE_SHIFT))
                     : ((((struct RHash *)(recv))->as.st)->num_entries))))
                << 1 |
            RUBY_FIXNUM_FLAG);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_empty_p(VALUE recv) {
  switch (vm_opt_length(recv, BOP_EMPTY_P)) {
  case ((VALUE)RUBY_Qundef):
    return ((VALUE)RUBY_Qundef);
  case (((VALUE)(0)) << 1 | RUBY_FIXNUM_FLAG):
    return ((VALUE)RUBY_Qtrue);
  default:
    return ((VALUE)RUBY_Qfalse);
  }
}

static VALUE vm_opt_succ(VALUE recv) {
  if ((((int)(long)(recv)) & RUBY_FIXNUM_FLAG) &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_SUCC)] & ((1 << 0))) == 0),
          1)))) {

    if (recv ==
        (((VALUE)((9223372036854775807L >> 1))) << 1 | RUBY_FIXNUM_FLAG)) {
      return rb_long2num_inline((9223372036854775807L >> 1) + 1);
    } else {
      return recv - 1 + (((VALUE)(1)) << 1 | RUBY_FIXNUM_FLAG);
    }
  } else if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return ((VALUE)RUBY_Qundef);
  } else if ((((struct RBasic *)(recv))->klass) == rb_cString &&
             ((__builtin_expect(
                 !!((rb_current_vm()->redefined_flag[(BOP_SUCC)] &
                     ((1 << 2))) == 0),
                 1)))) {
    return rb_str_succ(recv);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_not(CALL_INFO ci, CALL_CACHE cc, VALUE recv) {
  if (vm_method_cfunc_is(ci, cc, recv, rb_obj_not)) {
    return !(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)
               ? ((VALUE)RUBY_Qfalse)
               : ((VALUE)RUBY_Qtrue);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

static VALUE vm_opt_regexpmatch1(VALUE recv, VALUE obj) {
  if (((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MATCH)] & ((1 << 8))) == 0),
          1)))) {
    return rb_reg_match(recv, obj);
  } else {
    return __extension__({
      const int rb_funcall_argc = (1);
      const VALUE rb_funcall_args[] = {obj};
      const int rb_funcall_nargs =
          (int)(sizeof(rb_funcall_args) / sizeof(VALUE));
      rb_funcallv(recv, idEqTilde,
                  __builtin_choose_expr(
                      __builtin_constant_p(rb_funcall_argc),
                      (((rb_funcall_argc) == 0
                            ? (rb_funcall_nargs) <= 1
                            : (rb_funcall_argc) == (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : ((rb_funcall_argc) /
                              ((rb_funcall_argc) == 0
                                   ? (rb_funcall_nargs) <= 1
                                   : (rb_funcall_argc) == (rb_funcall_nargs)))),
                      (((rb_funcall_argc) <= (rb_funcall_nargs))
                           ? (rb_funcall_argc)
                           : (rb_fatal("argc(%d) exceeds actual arguments(%d)",
                                       rb_funcall_argc, rb_funcall_nargs),
                              0))),
                  rb_funcall_nargs ? rb_funcall_args : ((void *)0));
    });
  }
}

static VALUE vm_opt_regexpmatch2(VALUE recv, VALUE obj) {
  if (rb_class_of((VALUE)(recv)) == rb_cString &&
      ((__builtin_expect(
          !!((rb_current_vm()->redefined_flag[(BOP_MATCH)] & ((1 << 2))) == 0),
          1)))) {
    return rb_reg_match(obj, recv);
  } else {
    return ((VALUE)RUBY_Qundef);
  }
}

rb_event_flag_t rb_iseq_event_flags(const rb_iseq_t *iseq, size_t pos);

__attribute__((__noinline__)) static void vm_trace(rb_execution_context_t *ec,
                                                   rb_control_frame_t *reg_cfp,
                                                   const VALUE *pc);

static void vm_trace(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                     const VALUE *pc) {
  rb_event_flag_t vm_event_flags = ruby_vm_event_flags;

  if (vm_event_flags == 0) {
    return;
  } else {
    const rb_iseq_t *iseq = reg_cfp->iseq;
    size_t pos = pc - iseq->body->iseq_encoded;
    rb_event_flag_t events = rb_iseq_event_flags(iseq, pos);
    rb_event_flag_t event;

    if ((events & vm_event_flags) == 0) {
# 3851 "./vm_insnhelper.c"
      return;
    }

    if (ec->trace_arg != ((void *)0))
      return;

    if (0) {
      fprintf(
          __stderrp, "vm_trace>>%4d (%4x) - %s:%d %s\n", (int)pos, (int)events,
          (!(((struct RBasic *)(rb_iseq_path(iseq)))->flags & RSTRING_NOEMBED)
               ? ((struct RString *)(rb_iseq_path(iseq)))->as.ary
               : ((struct RString *)(rb_iseq_path(iseq)))->as.heap.ptr),
          (int)rb_iseq_line_no(iseq, pos),
          (!(((struct RBasic *)(rb_iseq_label(iseq)))->flags & RSTRING_NOEMBED)
               ? ((struct RString *)(rb_iseq_label(iseq)))->as.ary
               : ((struct RString *)(rb_iseq_label(iseq)))->as.heap.ptr));
    }

    ((void)0);
    ((void)0);
    ((void)0);

    if ((event = (events & (0x0002 | 0x0008 | 0x0100))) != 0) {
      ((void)0);

      reg_cfp->pc++;
      vm_dtrace(event, ec);
      do {
        const rb_event_flag_t flag_arg_ = (event);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, (((((reg_cfp)))->self)), 0, 0,
                                  0, ((VALUE)RUBY_Qundef), 0);
        }
      } while (0);
      reg_cfp->pc--;
    }
    if (events & 0x0001) {
      reg_cfp->pc++;
      vm_dtrace(0x0001, ec);
      do {
        const rb_event_flag_t flag_arg_ = (0x0001);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, (((((reg_cfp)))->self)), 0, 0,
                                  0, ((VALUE)RUBY_Qundef), 0);
        }
      } while (0);
      reg_cfp->pc--;
    }
    if (events & 0x010000) {
      reg_cfp->pc++;
      vm_dtrace(0x010000, ec);
      do {
        const rb_event_flag_t flag_arg_ = (0x010000);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, (((((reg_cfp)))->self)), 0, 0,
                                  0, ((VALUE)RUBY_Qundef), 0);
        }
      } while (0);
      reg_cfp->pc--;
    }
    if (events & 0x020000) {
      reg_cfp->pc++;
      vm_dtrace(0x020000, ec);
      do {
        const rb_event_flag_t flag_arg_ = (0x020000);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, (((((reg_cfp)))->self)), 0, 0,
                                  0, ((VALUE)RUBY_Qundef), 0);
        }
      } while (0);
      reg_cfp->pc--;
    }
    if ((event = (events & (0x0004 | 0x0010 | 0x0200))) != 0) {
      ((void)0);

      reg_cfp->pc++;
      vm_dtrace(event, ec);
      do {
        const rb_event_flag_t flag_arg_ = (event);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, (((((reg_cfp)))->self)), 0, 0,
                                  0, (*(((((reg_cfp)->sp))) - (0) - 1)), 0);
        }
      } while (0);
      reg_cfp->pc--;
    }
  }
}
# 3939 "./vm_insnhelper.c"
void Init_vm_stack_canary(void) {}
# 313 "vm.c" 2

# 1 "./vm_exec.c" 1
# 47 "./vm_exec.c"
static VALUE vm_exec_core(rb_execution_context_t *ec, VALUE initial) {
# 68 "./vm_exec.c"
  register const VALUE *reg_pc __asm__("r"
                                       "14");
  register rb_control_frame_t *reg_cfp __asm__("r"
                                               "15");
# 100 "./vm_exec.c"
# 1 "./vmtc.inc" 1
# 38 "./vmtc.inc"
  static const void *const insns_address_table[] = {
      __extension__(&&INSN_LABEL_nop),
      __extension__(&&INSN_LABEL_getlocal),
      __extension__(&&INSN_LABEL_setlocal),
      __extension__(&&INSN_LABEL_getblockparam),
      __extension__(&&INSN_LABEL_setblockparam),
      __extension__(&&INSN_LABEL_getblockparamproxy),
      __extension__(&&INSN_LABEL_getspecial),
      __extension__(&&INSN_LABEL_setspecial),
      __extension__(&&INSN_LABEL_getinstancevariable),
      __extension__(&&INSN_LABEL_setinstancevariable),
      __extension__(&&INSN_LABEL_getclassvariable),
      __extension__(&&INSN_LABEL_setclassvariable),
      __extension__(&&INSN_LABEL_getconstant),
      __extension__(&&INSN_LABEL_setconstant),
      __extension__(&&INSN_LABEL_getglobal),
      __extension__(&&INSN_LABEL_setglobal),
      __extension__(&&INSN_LABEL_putnil),
      __extension__(&&INSN_LABEL_putself),
      __extension__(&&INSN_LABEL_putobject),
      __extension__(&&INSN_LABEL_putspecialobject),
      __extension__(&&INSN_LABEL_putiseq),
      __extension__(&&INSN_LABEL_putstring),
      __extension__(&&INSN_LABEL_concatstrings),
      __extension__(&&INSN_LABEL_tostring),
      __extension__(&&INSN_LABEL_freezestring),
      __extension__(&&INSN_LABEL_toregexp),
      __extension__(&&INSN_LABEL_intern),
      __extension__(&&INSN_LABEL_newarray),
      __extension__(&&INSN_LABEL_duparray),
      __extension__(&&INSN_LABEL_expandarray),
      __extension__(&&INSN_LABEL_concatarray),
      __extension__(&&INSN_LABEL_splatarray),
      __extension__(&&INSN_LABEL_newhash),
      __extension__(&&INSN_LABEL_newhashfromarray),
      __extension__(&&INSN_LABEL_newrange),
      __extension__(&&INSN_LABEL_pop),
      __extension__(&&INSN_LABEL_dup),
      __extension__(&&INSN_LABEL_dupn),
      __extension__(&&INSN_LABEL_swap),
      __extension__(&&INSN_LABEL_reverse),
      __extension__(&&INSN_LABEL_reput),
      __extension__(&&INSN_LABEL_topn),
      __extension__(&&INSN_LABEL_setn),
      __extension__(&&INSN_LABEL_adjuststack),
      __extension__(&&INSN_LABEL_defined),
      __extension__(&&INSN_LABEL_checkmatch),
      __extension__(&&INSN_LABEL_checkkeyword),
      __extension__(&&INSN_LABEL_checktype),
      __extension__(&&INSN_LABEL_defineclass),
      __extension__(&&INSN_LABEL_send),
      __extension__(&&INSN_LABEL_opt_send_without_block),
      __extension__(&&INSN_LABEL_opt_str_freeze),
      __extension__(&&INSN_LABEL_opt_str_uminus),
      __extension__(&&INSN_LABEL_opt_newarray_max),
      __extension__(&&INSN_LABEL_opt_newarray_min),
      __extension__(&&INSN_LABEL_invokesuper),
      __extension__(&&INSN_LABEL_invokeblock),
      __extension__(&&INSN_LABEL_leave),
      __extension__(&&INSN_LABEL_throw),
      __extension__(&&INSN_LABEL_jump),
      __extension__(&&INSN_LABEL_branchif),
      __extension__(&&INSN_LABEL_branchunless),
      __extension__(&&INSN_LABEL_branchnil),
      __extension__(&&INSN_LABEL_opt_getinlinecache),
      __extension__(&&INSN_LABEL_opt_setinlinecache),
      __extension__(&&INSN_LABEL_once),
      __extension__(&&INSN_LABEL_opt_case_dispatch),
      __extension__(&&INSN_LABEL_opt_plus),
      __extension__(&&INSN_LABEL_opt_minus),
      __extension__(&&INSN_LABEL_opt_mult),
      __extension__(&&INSN_LABEL_opt_div),
      __extension__(&&INSN_LABEL_opt_mod),
      __extension__(&&INSN_LABEL_opt_eq),
      __extension__(&&INSN_LABEL_opt_neq),
      __extension__(&&INSN_LABEL_opt_lt),
      __extension__(&&INSN_LABEL_opt_le),
      __extension__(&&INSN_LABEL_opt_gt),
      __extension__(&&INSN_LABEL_opt_ge),
      __extension__(&&INSN_LABEL_opt_ltlt),
      __extension__(&&INSN_LABEL_opt_and),
      __extension__(&&INSN_LABEL_opt_or),
      __extension__(&&INSN_LABEL_opt_aref),
      __extension__(&&INSN_LABEL_opt_aset),
      __extension__(&&INSN_LABEL_opt_aset_with),
      __extension__(&&INSN_LABEL_opt_aref_with),
      __extension__(&&INSN_LABEL_opt_length),
      __extension__(&&INSN_LABEL_opt_size),
      __extension__(&&INSN_LABEL_opt_empty_p),
      __extension__(&&INSN_LABEL_opt_succ),
      __extension__(&&INSN_LABEL_opt_not),
      __extension__(&&INSN_LABEL_opt_regexpmatch1),
      __extension__(&&INSN_LABEL_opt_regexpmatch2),
      __extension__(&&INSN_LABEL_opt_call_c_function),
      __extension__(&&INSN_LABEL_bitblt),
      __extension__(&&INSN_LABEL_answer),
      __extension__(&&INSN_LABEL_getlocal_WC_0),
      __extension__(&&INSN_LABEL_getlocal_WC_1),
      __extension__(&&INSN_LABEL_setlocal_WC_0),
      __extension__(&&INSN_LABEL_setlocal_WC_1),
      __extension__(&&INSN_LABEL_putobject_INT2FIX_0_),
      __extension__(&&INSN_LABEL_putobject_INT2FIX_1_),
      __extension__(&&INSN_LABEL_trace_nop),
      __extension__(&&INSN_LABEL_trace_getlocal),
      __extension__(&&INSN_LABEL_trace_setlocal),
      __extension__(&&INSN_LABEL_trace_getblockparam),
      __extension__(&&INSN_LABEL_trace_setblockparam),
      __extension__(&&INSN_LABEL_trace_getblockparamproxy),
      __extension__(&&INSN_LABEL_trace_getspecial),
      __extension__(&&INSN_LABEL_trace_setspecial),
      __extension__(&&INSN_LABEL_trace_getinstancevariable),
      __extension__(&&INSN_LABEL_trace_setinstancevariable),
      __extension__(&&INSN_LABEL_trace_getclassvariable),
      __extension__(&&INSN_LABEL_trace_setclassvariable),
      __extension__(&&INSN_LABEL_trace_getconstant),
      __extension__(&&INSN_LABEL_trace_setconstant),
      __extension__(&&INSN_LABEL_trace_getglobal),
      __extension__(&&INSN_LABEL_trace_setglobal),
      __extension__(&&INSN_LABEL_trace_putnil),
      __extension__(&&INSN_LABEL_trace_putself),
      __extension__(&&INSN_LABEL_trace_putobject),
      __extension__(&&INSN_LABEL_trace_putspecialobject),
      __extension__(&&INSN_LABEL_trace_putiseq),
      __extension__(&&INSN_LABEL_trace_putstring),
      __extension__(&&INSN_LABEL_trace_concatstrings),
      __extension__(&&INSN_LABEL_trace_tostring),
      __extension__(&&INSN_LABEL_trace_freezestring),
      __extension__(&&INSN_LABEL_trace_toregexp),
      __extension__(&&INSN_LABEL_trace_intern),
      __extension__(&&INSN_LABEL_trace_newarray),
      __extension__(&&INSN_LABEL_trace_duparray),
      __extension__(&&INSN_LABEL_trace_expandarray),
      __extension__(&&INSN_LABEL_trace_concatarray),
      __extension__(&&INSN_LABEL_trace_splatarray),
      __extension__(&&INSN_LABEL_trace_newhash),
      __extension__(&&INSN_LABEL_trace_newhashfromarray),
      __extension__(&&INSN_LABEL_trace_newrange),
      __extension__(&&INSN_LABEL_trace_pop),
      __extension__(&&INSN_LABEL_trace_dup),
      __extension__(&&INSN_LABEL_trace_dupn),
      __extension__(&&INSN_LABEL_trace_swap),
      __extension__(&&INSN_LABEL_trace_reverse),
      __extension__(&&INSN_LABEL_trace_reput),
      __extension__(&&INSN_LABEL_trace_topn),
      __extension__(&&INSN_LABEL_trace_setn),
      __extension__(&&INSN_LABEL_trace_adjuststack),
      __extension__(&&INSN_LABEL_trace_defined),
      __extension__(&&INSN_LABEL_trace_checkmatch),
      __extension__(&&INSN_LABEL_trace_checkkeyword),
      __extension__(&&INSN_LABEL_trace_checktype),
      __extension__(&&INSN_LABEL_trace_defineclass),
      __extension__(&&INSN_LABEL_trace_send),
      __extension__(&&INSN_LABEL_trace_opt_send_without_block),
      __extension__(&&INSN_LABEL_trace_opt_str_freeze),
      __extension__(&&INSN_LABEL_trace_opt_str_uminus),
      __extension__(&&INSN_LABEL_trace_opt_newarray_max),
      __extension__(&&INSN_LABEL_trace_opt_newarray_min),
      __extension__(&&INSN_LABEL_trace_invokesuper),
      __extension__(&&INSN_LABEL_trace_invokeblock),
      __extension__(&&INSN_LABEL_trace_leave),
      __extension__(&&INSN_LABEL_trace_throw),
      __extension__(&&INSN_LABEL_trace_jump),
      __extension__(&&INSN_LABEL_trace_branchif),
      __extension__(&&INSN_LABEL_trace_branchunless),
      __extension__(&&INSN_LABEL_trace_branchnil),
      __extension__(&&INSN_LABEL_trace_opt_getinlinecache),
      __extension__(&&INSN_LABEL_trace_opt_setinlinecache),
      __extension__(&&INSN_LABEL_trace_once),
      __extension__(&&INSN_LABEL_trace_opt_case_dispatch),
      __extension__(&&INSN_LABEL_trace_opt_plus),
      __extension__(&&INSN_LABEL_trace_opt_minus),
      __extension__(&&INSN_LABEL_trace_opt_mult),
      __extension__(&&INSN_LABEL_trace_opt_div),
      __extension__(&&INSN_LABEL_trace_opt_mod),
      __extension__(&&INSN_LABEL_trace_opt_eq),
      __extension__(&&INSN_LABEL_trace_opt_neq),
      __extension__(&&INSN_LABEL_trace_opt_lt),
      __extension__(&&INSN_LABEL_trace_opt_le),
      __extension__(&&INSN_LABEL_trace_opt_gt),
      __extension__(&&INSN_LABEL_trace_opt_ge),
      __extension__(&&INSN_LABEL_trace_opt_ltlt),
      __extension__(&&INSN_LABEL_trace_opt_and),
      __extension__(&&INSN_LABEL_trace_opt_or),
      __extension__(&&INSN_LABEL_trace_opt_aref),
      __extension__(&&INSN_LABEL_trace_opt_aset),
      __extension__(&&INSN_LABEL_trace_opt_aset_with),
      __extension__(&&INSN_LABEL_trace_opt_aref_with),
      __extension__(&&INSN_LABEL_trace_opt_length),
      __extension__(&&INSN_LABEL_trace_opt_size),
      __extension__(&&INSN_LABEL_trace_opt_empty_p),
      __extension__(&&INSN_LABEL_trace_opt_succ),
      __extension__(&&INSN_LABEL_trace_opt_not),
      __extension__(&&INSN_LABEL_trace_opt_regexpmatch1),
      __extension__(&&INSN_LABEL_trace_opt_regexpmatch2),
      __extension__(&&INSN_LABEL_trace_opt_call_c_function),
      __extension__(&&INSN_LABEL_trace_bitblt),
      __extension__(&&INSN_LABEL_trace_answer),
      __extension__(&&INSN_LABEL_trace_getlocal_WC_0),
      __extension__(&&INSN_LABEL_trace_getlocal_WC_1),
      __extension__(&&INSN_LABEL_trace_setlocal_WC_0),
      __extension__(&&INSN_LABEL_trace_setlocal_WC_1),
      __extension__(&&INSN_LABEL_trace_putobject_INT2FIX_0_),
      __extension__(&&INSN_LABEL_trace_putobject_INT2FIX_1_),
  };

  _Static_assert(
      ((int)(sizeof(insns_address_table) / sizeof((insns_address_table)[0]))) ==
          VM_INSTRUCTION_SIZE,
      "numberof_insns_address_table"
      ": "
      "numberof(insns_address_table) == VM_INSTRUCTION_SIZE");
# 101 "./vm_exec.c" 2
  if ((__builtin_expect(!!(ec == 0), 0))) {
    return (VALUE)insns_address_table;
  }

  reg_cfp = ec->cfp;
  reg_pc = reg_cfp->pc;

first:;
  __extension__({ goto *(void const *)(*(reg_pc)); });
  ;
  {
    ;

# 1 "./vm.inc" 1
# 42 "./vm.inc"
  INSN_LABEL_nop:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "nop",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
    start_of_nop:;
      ;
      if (!(leaf = attr_leaf_nop()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_nop()))));
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_nop()))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_nop()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getlocal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getlocal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_getlocal:;
      idx = (lindex_t)((reg_pc)[(1)]);
      level = (rb_num_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_getlocal(idx, level)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal(idx, level)))));
      ;
      ;
      ;
      ;
# 81 "insns.def"
      {
        val = *(vm_get_ep(((((reg_cfp)->ep))), level) - idx);
        ((void)0);
        (void)(level > 0);
      }
# 87 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getlocal(idx, level)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal(idx, level)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setlocal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setlocal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_setlocal:;
      idx = (lindex_t)((reg_pc)[(1)]);
      level = (rb_num_t)((reg_pc)[(2)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setlocal(idx, level)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal(idx, level)))));
      ;
      ;
      ;
      ;
# 95 "insns.def"
      {
        vm_env_write(vm_get_ep(((((reg_cfp)->ep))), level), -(int)idx, val);
        ((void)0);
        (void)(level > 0);
      }
# 125 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setlocal(idx, level)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal(idx, level)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getblockparam:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getblockparam",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_getblockparam:;
      idx = (lindex_t)((reg_pc)[(1)]);
      level = (rb_num_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_getblockparam(idx, level)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getblockparam(idx, level)))));
      ;
      ;
      ;
      ;
# 107 "insns.def"
      {
        const VALUE *ep = vm_get_ep(((((reg_cfp)->ep))), level);
        ((void)0);

        if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
          val = rb_vm_bh_to_procval(ec, VM_ENV_BLOCK_HANDLER(ep));
          vm_env_write(ep, -(int)idx, val);
          VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
        } else {
          val = *(ep - idx);
          ((void)0);
          (void)(level > 0);
        }
      }
# 171 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getblockparam(idx, level)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getblockparam(idx, level)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setblockparam:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setblockparam",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_setblockparam:;
      idx = (lindex_t)((reg_pc)[(1)]);
      level = (rb_num_t)((reg_pc)[(2)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setblockparam(idx, level)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_setblockparam(idx, level)))));
      ;
      ;
      ;
      ;
# 129 "insns.def"
      {
        const VALUE *ep = vm_get_ep(((((reg_cfp)->ep))), level);
        ((void)0);

        vm_env_write(ep, -(int)idx, val);
        ((void)0);
        (void)(level > 0);

        VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
      }
# 214 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setblockparam(idx, level)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_setblockparam(idx, level)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getblockparamproxy:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getblockparamproxy",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_getblockparamproxy:;
      idx = (lindex_t)((reg_pc)[(1)]);
      level = (rb_num_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_getblockparamproxy(idx, level)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getblockparamproxy(idx, level)))));
      ;
      ;
      ;
      ;
# 148 "insns.def"
      {
        const VALUE *ep = vm_get_ep(((((reg_cfp)->ep))), level);
        ((void)0);

        if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
          VALUE block_handler = VM_ENV_BLOCK_HANDLER(ep);

          if (block_handler) {
            switch (vm_block_handler_type(block_handler)) {
            case block_handler_type_iseq:
            case block_handler_type_ifunc:
              val = rb_block_param_proxy;
              break;
            case block_handler_type_symbol:
              val = rb_sym_to_proc(VM_BH_TO_SYMBOL(block_handler));
              goto INSN_LABEL_NAME_OF_CURRENT_INSN_set;
            case block_handler_type_proc:
              val = VM_BH_TO_PROC(block_handler);
              goto INSN_LABEL_NAME_OF_CURRENT_INSN_set;
            default:
              __builtin_unreachable();
            }
          } else {
            val = ((VALUE)RUBY_Qnil);
          INSN_LABEL_NAME_OF_CURRENT_INSN_set:
            vm_env_write(ep, -(int)idx, val);
            VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
          }
        } else {
          val = *(ep - idx);
          ((void)0);
          (void)(level > 0);
        }
      }
# 281 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getblockparamproxy(idx, level)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getblockparamproxy(idx, level)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getspecial:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getspecial",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t key, type;

    start_of_getspecial:;
      key = (rb_num_t)((reg_pc)[(1)]);
      type = (rb_num_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_getspecial(key, type)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getspecial(key, type)))));
      ;
      ;
      ;
      ;
# 191 "insns.def"
      {
        val = vm_getspecial(ec, (VM_EP_LEP(((((reg_cfp)->ep))))), key, type);
      }
# 315 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getspecial(key, type)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getspecial(key, type)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setspecial:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setspecial",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE obj;
      __attribute__((__unused__)) rb_num_t key;

    start_of_setspecial:;
      key = (rb_num_t)((reg_pc)[(1)]);
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setspecial(key)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setspecial(key)))));
      ;
      ;
      ;
# 201 "insns.def"
      {
        lep_svar_set(ec, (VM_EP_LEP(((((reg_cfp)->ep))))), key, obj);
      }
# 348 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setspecial(key)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setspecial(key)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getinstancevariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getinstancevariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) IC ic;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE val;

    start_of_getinstancevariable:;
      id = (ID)((reg_pc)[(1)]);
      ic = (IC)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_getinstancevariable(id, ic)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getinstancevariable(id, ic)))));
      ;
      ;
      ;
      ;
# 213 "insns.def"
      {
        val = vm_getinstancevariable((((((reg_cfp)))->self)), id, ic);
      }
# 382 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getinstancevariable(id, ic)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_getinstancevariable(id, ic)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setinstancevariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setinstancevariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) IC ic;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE val;

    start_of_setinstancevariable:;
      id = (ID)((reg_pc)[(1)]);
      ic = (IC)((reg_pc)[(2)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setinstancevariable(id, ic)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_setinstancevariable(id, ic)))));
      ;
      ;
      ;
      ;
# 223 "insns.def"
      {
        vm_setinstancevariable((((((reg_cfp)))->self)), id, val, ic);
      }
# 418 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setinstancevariable(id, ic)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_setinstancevariable(id, ic)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getclassvariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getclassvariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE val;

    start_of_getclassvariable:;
      id = (ID)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_getclassvariable(id)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getclassvariable(id)))));
      ;
      ;
      ;
# 235 "insns.def"
      {
        val = rb_cvar_get(vm_get_cvar_base(rb_vm_get_cref(((((reg_cfp)->ep)))),
                                           (((reg_cfp)))),
                          id);
      }
# 449 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getclassvariable(id)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getclassvariable(id)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setclassvariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setclassvariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE val;

    start_of_setclassvariable:;
      id = (ID)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setclassvariable(id)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setclassvariable(id)))));
      ;
      ;
      ;
# 247 "insns.def"
      {
        vm_ensure_not_refinement_module((((((reg_cfp)))->self)));
        rb_cvar_set(vm_get_cvar_base(rb_vm_get_cref(((((reg_cfp)->ep)))),
                                     (((reg_cfp)))),
                    id, val);
      }
# 483 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setclassvariable(id)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setclassvariable(id)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getconstant:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getconstant",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE klass, val;

    start_of_getconstant:;
      id = (ID)((reg_pc)[(1)]);
      klass = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_getconstant(id)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getconstant(id)))));
      ;
      ;
      ;
# 263 "insns.def"
      {
        val = vm_get_ev_const(ec, klass, id, 0);
      }
# 515 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getconstant(id)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getconstant(id)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setconstant:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setconstant",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) VALUE cbase, val;

    start_of_setconstant:;
      id = (ID)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (1) - 1));
      cbase = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setconstant(id)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setconstant(id)))));
      ;
      ;
      ;
# 279 "insns.def"
      {
        vm_check_if_namespace(cbase);
        vm_ensure_not_refinement_module((((((reg_cfp)))->self)));
        rb_const_set(cbase, id, val);
      }
# 551 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setconstant(id)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setconstant(id)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getglobal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getglobal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) GENTRY entry;
      __attribute__((__unused__)) VALUE val;

    start_of_getglobal:;
      entry = (GENTRY)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_getglobal(entry)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getglobal(entry)))));
      ;
      ;
      ;
# 292 "insns.def"
      {
        val = rb_gvar_get((struct rb_global_entry *)((VALUE)entry));
      }
# 582 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getglobal(entry)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getglobal(entry)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setglobal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setglobal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) GENTRY entry;
      __attribute__((__unused__)) VALUE val;

    start_of_setglobal:;
      entry = (GENTRY)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setglobal(entry)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setglobal(entry)))));
      ;
      ;
      ;
# 303 "insns.def"
      {
        rb_gvar_set((struct rb_global_entry *)((VALUE)entry), (val));
      }
# 615 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setglobal(entry)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setglobal(entry)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putnil:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putnil",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_putnil:;
      ;
      if (!(leaf = attr_leaf_putnil()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putnil()))));
      ;
      ;
# 317 "insns.def"
      {
        val = ((VALUE)RUBY_Qnil);
      }
# 643 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putnil()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putnil()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putself:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putself",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_putself:;
      ;
      if (!(leaf = attr_leaf_putself()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putself()))));
      ;
      ;
# 327 "insns.def"
      {
        val = (((((reg_cfp)))->self));
      }
# 672 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putself()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putself()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putobject:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putobject",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_putobject:;
      val = (VALUE)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_putobject(val)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putobject(val)))));
      ;
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putobject(val)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putobject(val)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putspecialobject:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putspecialobject",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t value_type;

    start_of_putspecialobject:;
      value_type = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_putspecialobject(value_type)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putspecialobject(value_type)))));
      ;
      ;
      ;
# 349 "insns.def"
      {
        enum vm_special_object_type type;

        type = (enum vm_special_object_type)value_type;
        val = vm_get_special_object(((((reg_cfp)->ep))), type);
      }
# 731 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putspecialobject(value_type)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putspecialobject(value_type)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putiseq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putiseq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ISEQ iseq;
      __attribute__((__unused__)) VALUE ret;

    start_of_putiseq:;
      iseq = (ISEQ)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_putiseq(iseq)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putiseq(iseq)))));
      ;
      ;
      ;
# 363 "insns.def"
      {
        ret = (VALUE)iseq;
      }
# 763 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putiseq(iseq)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ret;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putiseq(iseq)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putstring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putstring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE str, val;

    start_of_putstring:;
      str = (VALUE)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_putstring(str)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putstring(str)))));
      ;
      ;
      ;
# 373 "insns.def"
      {
        val = rb_str_resurrect(str);
      }
# 794 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putstring(str)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_putstring(str)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_concatstrings:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "concatstrings",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t num;

    start_of_concatstrings:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_concatstrings(num)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_concatstrings(num)))));
      ;
      ;
      ;
# 384 "insns.def"
      {
        val = rb_str_concat_literals(num, (((((reg_cfp)->sp))) - (num)));
      }
# 826 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_concatstrings(num)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_concatstrings(num)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_tostring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "tostring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE str, val;

    start_of_tostring:;
      val = (*(((((reg_cfp)->sp))) - (1) - 1));
      str = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_tostring()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_tostring()))));
      ;
      ;
# 394 "insns.def"
      {
        val = rb_obj_as_string_result(str, val);
      }
# 857 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_tostring()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_tostring()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_freezestring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "freezestring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE debug_info, str;

    start_of_freezestring:;
      debug_info = (VALUE)((reg_pc)[(1)]);
      str = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_freezestring(debug_info)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_freezestring(debug_info)))));
      ;
      ;
      ;
# 404 "insns.def"
      {
        vm_freezestring(str, debug_info);
      }
# 889 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_freezestring(debug_info)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = str;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_freezestring(debug_info)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_toregexp:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "toregexp",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t cnt, opt;

    start_of_toregexp:;
      opt = (rb_num_t)((reg_pc)[(1)]);
      cnt = (rb_num_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_toregexp(opt, cnt)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_toregexp(opt, cnt)))));
      ;
      ;
      ;
      ;
# 420 "insns.def"
      {
        const VALUE ary =
            rb_ary_tmp_new_from_values(0, cnt, (((((reg_cfp)->sp))) - (cnt)));
        val = rb_reg_new_ary(ary, (int)opt);
        rb_ary_clear(ary);
      }
# 925 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_toregexp(opt, cnt)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_toregexp(opt, cnt)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_intern:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "intern",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE str, sym;

    start_of_intern:;
      str = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_intern()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_intern()))));
      ;
      ;
# 432 "insns.def"
      {
        sym = rb_str_intern(str);
      }
# 955 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_intern()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = sym;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_intern()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_newarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "newarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t num;

    start_of_newarray:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_newarray(num)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newarray(num)))));
      ;
      ;
      ;
# 443 "insns.def"
      {
        val = rb_ary_new_from_values(num, (((((reg_cfp)->sp))) - (num)));
      }
# 987 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_newarray(num)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newarray(num)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_duparray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "duparray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ary, val;

    start_of_duparray:;
      ary = (VALUE)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_duparray(ary)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_duparray(ary)))));
      ;
      ;
      ;
# 453 "insns.def"
      {
        val = rb_ary_resurrect(ary);
      }
# 1018 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_duparray(ary)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_duparray(ary)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_expandarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "expandarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ary;
      __attribute__((__unused__)) rb_num_t flag, num;

    start_of_expandarray:;
      num = (rb_num_t)((reg_pc)[(1)]);
      flag = (rb_num_t)((reg_pc)[(2)]);
      ary = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_expandarray(num, flag)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_expandarray(num, flag)))));
      ;
      ;
      ;
# 473 "insns.def"
      {
        vm_expandarray(((((reg_cfp)->sp))), ary, num, (int)flag);
      }
# 1052 "vm.inc"
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_expandarray(num, flag)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_expandarray(num, flag)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_concatarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "concatarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ary, ary1, ary2;

    start_of_concatarray:;
      ary1 = (*(((((reg_cfp)->sp))) - (1) - 1));
      ary2 = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_concatarray()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_concatarray()))));
      ;
      ;
# 484 "insns.def"
      {
        ary = vm_concat_array(ary1, ary2);
      }
# 1081 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_concatarray()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ary;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_concatarray()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_splatarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "splatarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ary, flag, obj;

    start_of_splatarray:;
      flag = (VALUE)((reg_pc)[(1)]);
      ary = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_splatarray(flag)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_splatarray(flag)))));
      ;
      ;
      ;
# 495 "insns.def"
      {
        obj = vm_splat_array(flag, ary);
      }
# 1113 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_splatarray(flag)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = obj;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_splatarray(flag)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_newhash:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "newhash",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t num;

    start_of_newhash:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_newhash(num)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newhash(num)))));
      ;
      ;
      ;
# 507 "insns.def"
      {
        do {
          if ((__builtin_expect(!!(({
                int _r = __dtrace_isenabled$ruby$hash__create$v1();
                __asm__ volatile("");
                _r;
              })),
                                0))) {
            int dtrace_line;
            const char *dtrace_file = rb_source_location_cstr(&dtrace_line);
            if (!dtrace_file)
              dtrace_file = "";
            do {
              __asm__ volatile(".reference "
                               "___dtrace_typedefs$ruby$v2");
              __dtrace_probe$ruby$hash__create$v1$6c6f6e67$63686172202a$696e74(
                  num, dtrace_file, dtrace_line);
              __asm__ volatile(
                  ".reference "
                  "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
            } while (0);
          }
        } while (0);

        val = rb_hash_new_with_size(num / 2);

        if (num) {
          rb_hash_bulk_insert(num, (((((reg_cfp)->sp))) - (num)), val);
        }
      }
# 1151 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_newhash(num)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newhash(num)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_newhashfromarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "newhashfromarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ary, hash;
      __attribute__((__unused__)) rb_num_t num;

    start_of_newhashfromarray:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ary = (VALUE)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_newhashfromarray(num, ary)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_newhashfromarray(num, ary)))));
      ;
      ;
      ;
      ;
# 524 "insns.def"
      {
        ((void)0);
        hash = rb_hash_new_with_size(num);
        rb_hash_bulk_insert(num * 2, rb_array_const_ptr_transient(ary), hash);
      }
# 1187 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_newhashfromarray(num, ary)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = hash;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_newhashfromarray(num, ary)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_newrange:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "newrange",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE high, low, val;
      __attribute__((__unused__)) rb_num_t flag;

    start_of_newrange:;
      flag = (rb_num_t)((reg_pc)[(1)]);
      low = (*(((((reg_cfp)->sp))) - (1) - 1));
      high = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_newrange(flag)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newrange(flag)))));
      ;
      ;
      ;
# 538 "insns.def"
      {
        val = rb_range_new(low, high, (int)flag);
      }
# 1221 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_newrange(flag)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_newrange(flag)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_pop:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "pop",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_pop:;
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_pop()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_pop()))));
      ;
      ;
# 552 "insns.def"
      {
        (void)val;
      }
# 1252 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_pop()))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_pop()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_dup:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "dup",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val, val1, val2;

    start_of_dup:;
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_dup()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_dup()))));
      ;
      ;
# 563 "insns.def"
      {
        val1 = val2 = val;
      }
# 1281 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_dup()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val2;
      (*(((((reg_cfp)->sp))) - (1) - 1)) = val1;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_dup()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_dupn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "dupn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) rb_num_t n;

    start_of_dupn:;
      n = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_dupn(n)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_dupn(n)))));
      ;
      ;
# 574 "insns.def"
      {
        void *dst = ((((reg_cfp)->sp)));
        void *src = (((((reg_cfp)->sp))) - (n));

        __builtin___memcpy_chk((dst), (src), sizeof(VALUE) * (size_t)(n),
                               __builtin_object_size((dst), 0));
      }
# 1315 "vm.inc"
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_dupn(n)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_dupn(n)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_swap:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "swap",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE obj, val;

    start_of_swap:;
      val = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_swap()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_swap()))));
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_swap()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      (*(((((reg_cfp)->sp))) - (1) - 1)) = obj;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_swap()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_reverse:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "reverse",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) rb_num_t n;

    start_of_reverse:;
      n = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_reverse(n)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_reverse(n)))));
      ;
      ;
# 598 "insns.def"
      {
        rb_num_t i;
        VALUE *sp = (((((reg_cfp)->sp))) - (n));

        for (i = 0; i < n / 2; i++) {
          VALUE v0 = sp[i];
          VALUE v1 = (*(((((reg_cfp)->sp))) - (i)-1));
          sp[i] = v1;
          (*(((((reg_cfp)->sp))) - (i)-1)) = v0;
        }
      }
# 1376 "vm.inc"
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_reverse(n)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_reverse(n)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_reput:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "reput",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_reput:;
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_reput()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_reput()))));
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_reput()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_reput()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_topn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "topn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t n;

    start_of_topn:;
      n = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_topn(n)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_topn(n)))));
      ;
      ;
      ;
# 628 "insns.def"
      {
        val = (*(((((reg_cfp)->sp))) - (n)-1));
      }
# 1429 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_topn(n)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_topn(n)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t n;

    start_of_setn:;
      n = (rb_num_t)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setn(n)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setn(n)))));
      ;
      ;
      ;
# 639 "insns.def"
      {
        (*(((((reg_cfp)->sp))) - (n)-1)) = val;
      }
# 1462 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setn(n)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setn(n)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_adjuststack:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "adjuststack",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) rb_num_t n;

    start_of_adjuststack:;
      n = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_adjuststack(n)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_adjuststack(n)))));
      ;
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_adjuststack(n)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_adjuststack(n)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_defined:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "defined",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE needstr, obj, v, val;
      __attribute__((__unused__)) rb_num_t op_type;

    start_of_defined:;
      op_type = (rb_num_t)((reg_pc)[(1)]);
      obj = (VALUE)((reg_pc)[(2)]);
      needstr = (VALUE)((reg_pc)[(3)]);
      v = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_defined(op_type, obj, needstr)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_defined(op_type, obj, needstr)))));
      ;
      ;
      ;
      ;
      ;
# 665 "insns.def"
      {
        val = vm_defined(ec, (((reg_cfp))), op_type, obj, needstr, v);
      }
# 1522 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_defined(op_type, obj, needstr)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_defined(op_type, obj, needstr)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_checkmatch:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "checkmatch",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE pattern, result, target;
      __attribute__((__unused__)) rb_num_t flag;

    start_of_checkmatch:;
      flag = (rb_num_t)((reg_pc)[(1)]);
      target = (*(((((reg_cfp)->sp))) - (1) - 1));
      pattern = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_checkmatch(flag)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_checkmatch(flag)))));
      ;
      ;
      ;
# 682 "insns.def"
      {
        result = vm_check_match(ec, target, pattern, flag);
      }
# 1556 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_checkmatch(flag)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = result;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_checkmatch(flag)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_checkkeyword:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "checkkeyword",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ret;
      __attribute__((__unused__)) lindex_t keyword_index, kw_bits_index;

    start_of_checkkeyword:;
      kw_bits_index = (lindex_t)((reg_pc)[(1)]);
      keyword_index = (lindex_t)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_checkkeyword(kw_bits_index, keyword_index)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc +
               (attr_width_checkkeyword(kw_bits_index, keyword_index)))));
      ;
      ;
      ;
      ;
# 692 "insns.def"
      {
        ret =
            vm_check_keyword(kw_bits_index, keyword_index, ((((reg_cfp)->ep))));
      }
# 1590 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) +=
       (((attr_sp_inc_checkkeyword(kw_bits_index, keyword_index)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ret;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc +
               (attr_width_checkkeyword(kw_bits_index, keyword_index)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_checktype:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "checktype",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ret, val;
      __attribute__((__unused__)) rb_num_t type;

    start_of_checktype:;
      type = (rb_num_t)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_checktype(type)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_checktype(type)))));
      ;
      ;
      ;
# 702 "insns.def"
      {
        ret = (rb_type((VALUE)(val)) == (int)type) ? ((VALUE)RUBY_Qtrue)
                                                   : ((VALUE)RUBY_Qfalse);
      }
# 1623 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_checktype(type)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ret;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_checktype(type)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_defineclass:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "defineclass",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ID id;
      __attribute__((__unused__)) ISEQ class_iseq;
      __attribute__((__unused__)) VALUE cbase, super, val;
      __attribute__((__unused__)) rb_num_t flags;

    start_of_defineclass:;
      id = (ID)((reg_pc)[(1)]);
      class_iseq = (ISEQ)((reg_pc)[(2)]);
      flags = (rb_num_t)((reg_pc)[(3)]);
      cbase = (*(((((reg_cfp)->sp))) - (1) - 1));
      super = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_defineclass(id, class_iseq, flags)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_defineclass(id, class_iseq, flags)))));
      ((((reg_cfp)->sp) -= (((attr_popn_defineclass(id, class_iseq, flags))))));
      ;
      ;
      ;
      ;
      ;
# 718 "insns.def"
      {
        VALUE klass = vm_find_or_create_class_by_id(id, flags, cbase, super);

        rb_iseq_check(class_iseq);

        vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL,
                      klass, ((VM_EP_LEP(((((reg_cfp)->ep)))))[(-1)]),
                      (VALUE)vm_cref_push(ec, klass, ((void *)0), 0),
                      class_iseq->body->iseq_encoded, ((((reg_cfp)->sp))),
                      class_iseq->body->local_table_size,
                      class_iseq->body->stack_max);
        {
          (reg_cfp) = ec->cfp;
          reg_pc = reg_cfp->pc;
        };
        ;
        __extension__({ goto *(void const *)(*(reg_pc)); });
        ;
        ;
      }
# 1676 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_defineclass(id, class_iseq, flags)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_send:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "send",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) ISEQ blockiseq;
      __attribute__((__unused__)) VALUE val;

    start_of_send:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      blockiseq = (ISEQ)((reg_pc)[(3)]);
      ;
      if (!(leaf = attr_leaf_send(ci, cc, blockiseq)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_send(ci, cc, blockiseq)))));
      ((((reg_cfp)->sp) -= (((attr_popn_send(ci, cc, blockiseq))))));
      ;
      ;
      ;
      ;
      ;
# 745 "insns.def"
      {
        struct rb_calling_info calling;

        calling.block_handler =
            vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, 0);
        calling.recv =
            (*(((((reg_cfp)->sp))) - (calling.argc = ci->orig_argc) - 1));
        vm_search_method(ci, cc, calling.recv);
        do {
          VALUE v = (*(cc)->call)(ec, (((reg_cfp))), (&calling), (ci), (cc));
          if (v == ((VALUE)RUBY_Qundef)) {
            do {
              if ((val = mjit_exec(ec)) == ((VALUE)RUBY_Qundef)) {
                {
                  (reg_cfp) = ec->cfp;
                  reg_pc = reg_cfp->pc;
                };
                ;
                __extension__({ goto *(void const *)(*(reg_pc)); });
                ;
                ;
              }
            } while (0);
          } else {
            val = v;
          }
        } while (0);
      }
# 1719 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_send(ci, cc, blockiseq)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_send_without_block:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_send_without_block",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE val;

    start_of_opt_send_without_block:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_opt_send_without_block(ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_send_without_block(ci, cc)))));
      ((((reg_cfp)->sp) -= (((attr_popn_opt_send_without_block(ci, cc))))));
      ;
      ;
      ;
      ;
# 762 "insns.def"
      {
        struct rb_calling_info calling;
        calling.block_handler = 0;
        vm_search_method(
            ci, cc,
            calling.recv =
                (*(((((reg_cfp)->sp))) - (calling.argc = ci->orig_argc) - 1)));
        do {
          VALUE v = (*(cc)->call)(ec, (((reg_cfp))), (&calling), (ci), (cc));
          if (v == ((VALUE)RUBY_Qundef)) {
            do {
              if ((val = mjit_exec(ec)) == ((VALUE)RUBY_Qundef)) {
                {
                  (reg_cfp) = ec->cfp;
                  reg_pc = reg_cfp->pc;
                };
                ;
                __extension__({ goto *(void const *)(*(reg_pc)); });
                ;
                ;
              }
            } while (0);
          } else {
            val = v;
          }
        } while (0);
      }
# 1757 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_send_without_block(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_str_freeze:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_str_freeze",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE str, val;

    start_of_opt_str_freeze:;
      str = (VALUE)((reg_pc)[(1)]);
      ci = (CALL_INFO)((reg_pc)[(2)]);
      cc = (CALL_CACHE)((reg_pc)[(3)]);
      ;
      if (!(leaf = attr_leaf_opt_str_freeze(str, ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_str_freeze(str, ci, cc)))));
      ;
      ;
      ;
      ;
      ;
# 774 "insns.def"
      {
        val = vm_opt_str_freeze(str, BOP_FREEZE, idFreeze);

        if (val == ((VALUE)RUBY_Qundef)) {
          ((*((((reg_cfp)->sp))) = (rb_str_resurrect(str))),
           (((reg_cfp)->sp) += (((1)))));
          do {
            rb_snum_t x = leaf ? attr_width_opt_str_freeze(str, ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 1798 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_str_freeze(str, ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_str_freeze(str, ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_str_uminus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_str_uminus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE str, val;

    start_of_opt_str_uminus:;
      str = (VALUE)((reg_pc)[(1)]);
      ci = (CALL_INFO)((reg_pc)[(2)]);
      cc = (CALL_CACHE)((reg_pc)[(3)]);
      ;
      if (!(leaf = attr_leaf_opt_str_uminus(str, ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_str_uminus(str, ci, cc)))));
      ;
      ;
      ;
      ;
      ;
# 788 "insns.def"
      {
        val = vm_opt_str_freeze(str, BOP_UMINUS, idUMinus);

        if (val == ((VALUE)RUBY_Qundef)) {
          ((*((((reg_cfp)->sp))) = (rb_str_resurrect(str))),
           (((reg_cfp)->sp) += (((1)))));
          do {
            rb_snum_t x = leaf ? attr_width_opt_str_uminus(str, ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 1840 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_str_uminus(str, ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_str_uminus(str, ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_newarray_max:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_newarray_max",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t num;

    start_of_opt_newarray_max:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_opt_newarray_max(num)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_newarray_max(num)))));
      ;
      ;
      ;
# 808 "insns.def"
      {
        val = vm_opt_newarray_max(num, (((((reg_cfp)->sp))) - (num)));
      }
# 1872 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_newarray_max(num)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_newarray_max(num)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_newarray_min:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_newarray_min",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) rb_num_t num;

    start_of_opt_newarray_min:;
      num = (rb_num_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_opt_newarray_min(num)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_newarray_min(num)))));
      ;
      ;
      ;
# 820 "insns.def"
      {
        val = vm_opt_newarray_min(num, (((((reg_cfp)->sp))) - (num)));
      }
# 1904 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_newarray_min(num)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_newarray_min(num)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_invokesuper:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "invokesuper",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) ISEQ blockiseq;
      __attribute__((__unused__)) VALUE val;

    start_of_invokesuper:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      blockiseq = (ISEQ)((reg_pc)[(3)]);
      ;
      if (!(leaf = attr_leaf_invokesuper(ci, cc, blockiseq)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_invokesuper(ci, cc, blockiseq)))));
      ((((reg_cfp)->sp) -= (((attr_popn_invokesuper(ci, cc, blockiseq))))));
      ;
      ;
      ;
      ;
      ;
# 831 "insns.def"
      {
        struct rb_calling_info calling;

        calling.block_handler =
            vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, 1);
        calling.recv =
            (*(((((reg_cfp)->sp))) - (calling.argc = ci->orig_argc) - 1));
        vm_search_super_method(ec, (((reg_cfp))), &calling, ci, cc);
        do {
          VALUE v = (*(cc)->call)(ec, (((reg_cfp))), (&calling), (ci), (cc));
          if (v == ((VALUE)RUBY_Qundef)) {
            do {
              if ((val = mjit_exec(ec)) == ((VALUE)RUBY_Qundef)) {
                {
                  (reg_cfp) = ec->cfp;
                  reg_pc = reg_cfp->pc;
                };
                ;
                __extension__({ goto *(void const *)(*(reg_pc)); });
                ;
                ;
              }
            } while (0);
          } else {
            val = v;
          }
        } while (0);
      }
# 1948 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_invokesuper(ci, cc, blockiseq)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_invokeblock:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "invokeblock",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE val;

    start_of_invokeblock:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_invokeblock(ci)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_invokeblock(ci)))));
      ((((reg_cfp)->sp) -= (((attr_popn_invokeblock(ci))))));
      ;
      ;
      ;
# 848 "insns.def"
      {
        struct rb_calling_info calling;
        VALUE block_handler;

        calling.argc = ci->orig_argc;
        calling.block_handler = 0;
        calling.recv = ((VALUE)RUBY_Qundef);

        block_handler = VM_CF_BLOCK_HANDLER((((reg_cfp))));
        if (block_handler == 0) {
          rb_vm_localjump_error("no block given (yield)", ((VALUE)RUBY_Qnil),
                                0);
        }

        val = vm_invoke_block(ec, (((reg_cfp))), &calling, ci, block_handler);
        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            if ((val = mjit_exec(ec)) == ((VALUE)RUBY_Qundef)) {
              {
                (reg_cfp) = ec->cfp;
                reg_pc = reg_cfp->pc;
              };
              ;
              __extension__({ goto *(void const *)(*(reg_pc)); });
              ;
              ;
            }
          } while (0);
        }
      }
# 1995 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_invokeblock(ci)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_leave:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "leave",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_leave:;
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_leave()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_leave()))));
      ((((reg_cfp)->sp) -= (((attr_popn_leave())))));
      ;
      ;
# 878 "insns.def"
      {
        if (1) {
          const VALUE *const bp = vm_base_ptr(reg_cfp);
          if (reg_cfp->sp != bp) {
            vm_stack_consistency_error(ec, reg_cfp, bp);
          }
        }

        rb_vm_check_ints(ec);

        if (vm_pop_frame(ec, (((reg_cfp))), ((((reg_cfp)->ep))))) {

          return val;

        } else {
          {
            (reg_cfp) = ec->cfp;
            reg_pc = reg_cfp->pc;
          };
        }
      }
# 2044 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_leave()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_throw:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "throw",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE throwobj, val;
      __attribute__((__unused__)) rb_num_t throw_state;

    start_of_throw:;
      throw_state = (rb_num_t)((reg_pc)[(1)]);
      throwobj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_throw(throw_state)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_throw(throw_state)))));
      ;
      ;
      ;
# 913 "insns.def"
      {
        rb_vm_check_ints(ec);
        val = vm_throw(ec, (((reg_cfp))), throw_state, throwobj);
        return (VALUE)(val);
      }
# 2079 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_throw(throw_state)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_throw(throw_state)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_jump:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "jump",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) OFFSET dst;

    start_of_jump:;
      dst = (OFFSET)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_jump(dst)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_jump(dst)))));
      ;
      ;
      ;
# 932 "insns.def"
      {
        rb_vm_check_ints(ec);
        ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
      }
# 2111 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_jump(dst)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_jump(dst)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_branchif:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "branchif",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) OFFSET dst;
      __attribute__((__unused__)) VALUE val;

    start_of_branchif:;
      dst = (OFFSET)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_branchif(dst)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchif(dst)))));
      ;
      ;
      ;
# 945 "insns.def"
      {
        if (!(((VALUE)(val) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
          rb_vm_check_ints(ec);
          ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
        }
      }
# 2146 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_branchif(dst)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchif(dst)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_branchunless:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "branchunless",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) OFFSET dst;
      __attribute__((__unused__)) VALUE val;

    start_of_branchunless:;
      dst = (OFFSET)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_branchunless(dst)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchunless(dst)))));
      ;
      ;
      ;
# 960 "insns.def"
      {
        if (!!(((VALUE)(val) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
          rb_vm_check_ints(ec);
          ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
        }
      }
# 2181 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_branchunless(dst)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchunless(dst)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_branchnil:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "branchnil",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) OFFSET dst;
      __attribute__((__unused__)) VALUE val;

    start_of_branchnil:;
      dst = (OFFSET)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_branchnil(dst)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchnil(dst)))));
      ;
      ;
      ;
# 975 "insns.def"
      {
        if (!((VALUE)(val) != ((VALUE)RUBY_Qnil))) {
          rb_vm_check_ints(ec);
          ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
        }
      }
# 2216 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_branchnil(dst)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_branchnil(dst)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_getinlinecache:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_getinlinecache",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) IC ic;
      __attribute__((__unused__)) OFFSET dst;
      __attribute__((__unused__)) VALUE val;

    start_of_opt_getinlinecache:;
      dst = (OFFSET)((reg_pc)[(1)]);
      ic = (IC)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_opt_getinlinecache(dst, ic)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_getinlinecache(dst, ic)))));
      ;
      ;
      ;
      ;
# 992 "insns.def"
      {
        if (vm_ic_hit_p(ic, ((((reg_cfp)->ep))))) {
          val = ic->ic_value.value;
          ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
        } else {
          val = ((VALUE)RUBY_Qnil);
        }
      }
# 2256 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_getinlinecache(dst, ic)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_getinlinecache(dst, ic)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_setinlinecache:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_setinlinecache",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) IC ic;
      __attribute__((__unused__)) VALUE val;

    start_of_opt_setinlinecache:;
      ic = (IC)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_setinlinecache(ic)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_setinlinecache(ic)))));
      ;
      ;
      ;
# 1008 "insns.def"
      {
        vm_ic_update(ic, val, ((((reg_cfp)->ep))));
      }
# 2289 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_setinlinecache(ic)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_setinlinecache(ic)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_once:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "once",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) ISE ise;
      __attribute__((__unused__)) ISEQ iseq;
      __attribute__((__unused__)) VALUE val;

    start_of_once:;
      iseq = (ISEQ)((reg_pc)[(1)]);
      ise = (ISE)((reg_pc)[(2)]);
      ;
      if (!(leaf = attr_leaf_once(iseq, ise)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_once(iseq, ise)))));
      ((((reg_cfp)->sp) -= (((attr_popn_once(iseq, ise))))));
      ;
      ;
      ;
      ;
# 1018 "insns.def"
      {
        val = vm_once_dispatch(ec, iseq, ise);
      }
# 2325 "vm.inc"
      ;
      ;
      ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_once(iseq, ise)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_case_dispatch:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_case_dispatch",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CDHASH hash;
      __attribute__((__unused__)) OFFSET else_offset;
      __attribute__((__unused__)) VALUE key;

    start_of_opt_case_dispatch:;
      hash = (CDHASH)((reg_pc)[(1)]);
      else_offset = (OFFSET)((reg_pc)[(2)]);
      key = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_case_dispatch(hash, else_offset)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_case_dispatch(hash, else_offset)))));
      ;
      ;
      ;
      ;
# 1029 "insns.def"
      {
        OFFSET dst = vm_case_dispatch(hash, else_offset, key);

        if (dst) {
          ((reg_cfp->pc = reg_pc = (reg_pc + (dst))));
        }
      }
# 2364 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) +=
       (((attr_sp_inc_opt_case_dispatch(hash, else_offset)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_case_dispatch(hash, else_offset)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_plus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_plus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_plus:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_plus(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_plus(ci, cc)))));
      ;
      ;
      ;
      ;
# 1048 "insns.def"
      {
        val = vm_opt_plus(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_plus(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2404 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_plus(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_plus(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_minus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_minus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_minus:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_minus(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_minus(ci, cc)))));
      ;
      ;
      ;
      ;
# 1062 "insns.def"
      {
        val = vm_opt_minus(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_minus(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2445 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_minus(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_minus(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_mult:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_mult",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_mult:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_mult(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_mult(ci, cc)))));
      ;
      ;
      ;
      ;
# 1076 "insns.def"
      {
        val = vm_opt_mult(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_mult(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2486 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_mult(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_mult(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_div:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_div",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_div:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_div(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_div(ci, cc)))));
      ;
      ;
      ;
      ;
# 1090 "insns.def"
      {
        val = vm_opt_div(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_div(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2527 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_div(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_div(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_mod:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_mod",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_mod:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_mod(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_mod(ci, cc)))));
      ;
      ;
      ;
      ;
# 1104 "insns.def"
      {
        val = vm_opt_mod(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_mod(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2568 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_mod(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_mod(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_eq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_eq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_eq:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_eq(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_eq(ci, cc)))));
      ;
      ;
      ;
      ;
# 1122 "insns.def"
      {
        val = opt_eq_func(recv, obj, ci, cc);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_eq(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2609 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_eq(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_eq(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_neq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_neq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc, cc_eq;
      __attribute__((__unused__)) CALL_INFO ci, ci_eq;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_neq:;
      ci_eq = (CALL_INFO)((reg_pc)[(1)]);
      cc_eq = (CALL_CACHE)((reg_pc)[(2)]);
      ci = (CALL_INFO)((reg_pc)[(3)]);
      cc = (CALL_CACHE)((reg_pc)[(4)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_neq(ci_eq, cc_eq, ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_neq(ci_eq, cc_eq, ci, cc)))));
      ;
      ;
      ;
      ;
      ;
      ;
# 1138 "insns.def"
      {
        val = vm_opt_neq(ci, cc, ci_eq, cc_eq, recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_neq(ci_eq, cc_eq, ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2654 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_neq(ci_eq, cc_eq, ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_neq(ci_eq, cc_eq, ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_lt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_lt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_lt:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_lt(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_lt(ci, cc)))));
      ;
      ;
      ;
      ;
# 1152 "insns.def"
      {
        val = vm_opt_lt(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_lt(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2695 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_lt(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_lt(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_le:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_le",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_le:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_le(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_le(ci, cc)))));
      ;
      ;
      ;
      ;
# 1166 "insns.def"
      {
        val = vm_opt_le(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_le(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2736 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_le(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_le(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_gt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_gt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_gt:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_gt(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_gt(ci, cc)))));
      ;
      ;
      ;
      ;
# 1180 "insns.def"
      {
        val = vm_opt_gt(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_gt(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2777 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_gt(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_gt(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_ge:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_ge",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_ge:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_ge(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_ge(ci, cc)))));
      ;
      ;
      ;
      ;
# 1194 "insns.def"
      {
        val = vm_opt_ge(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_ge(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2818 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_ge(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_ge(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_ltlt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_ltlt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_ltlt:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_ltlt(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_ltlt(ci, cc)))));
      ;
      ;
      ;
      ;
# 1208 "insns.def"
      {
        val = vm_opt_ltlt(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_ltlt(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2859 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_ltlt(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_ltlt(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_and:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_and",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_and:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_and(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_and(ci, cc)))));
      ;
      ;
      ;
      ;
# 1222 "insns.def"
      {
        val = vm_opt_and(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_and(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2900 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_and(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_and(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_or:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_or",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_or:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_or(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_or(ci, cc)))));
      ;
      ;
      ;
      ;
# 1236 "insns.def"
      {
        val = vm_opt_or(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_or(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2941 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_or(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_or(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_aref:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_aref",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_aref:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_aref(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_aref(ci, cc)))));
      ;
      ;
      ;
      ;
# 1255 "insns.def"
      {
        val = vm_opt_aref(recv, obj);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_aref(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 2982 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_aref(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_aref(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_aset:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_aset",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj, recv, set, val;

    start_of_opt_aset:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (2) - 1));
      obj = (*(((((reg_cfp)->sp))) - (1) - 1));
      set = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_aset(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_aset(ci, cc)))));
      ;
      ;
      ;
      ;
# 1272 "insns.def"
      {
        val = vm_opt_aset(recv, obj, set);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_aset(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3024 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_aset(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_aset(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_aset_with:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_aset_with",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE key, recv, val;

    start_of_opt_aset_with:;
      key = (VALUE)((reg_pc)[(1)]);
      ci = (CALL_INFO)((reg_pc)[(2)]);
      cc = (CALL_CACHE)((reg_pc)[(3)]);
      recv = (*(((((reg_cfp)->sp))) - (1) - 1));
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_aset_with(key, ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_aset_with(key, ci, cc)))));
      ;
      ;
      ;
      ;
      ;
# 1288 "insns.def"
      {
        VALUE tmp = vm_opt_aset_with(recv, key, val);

        if (tmp != ((VALUE)RUBY_Qundef)) {
          val = tmp;
        } else {

          (*(((((reg_cfp)->sp))) - (0) - 1)) = rb_str_resurrect(key);
          ((*((((reg_cfp)->sp))) = (val)), (((reg_cfp)->sp) += (((1)))));

          do {
            rb_snum_t x = leaf ? attr_width_opt_aset_with(key, ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3074 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_aset_with(key, ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_aset_with(key, ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_aref_with:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_aref_with",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE key, recv, val;

    start_of_opt_aref_with:;
      key = (VALUE)((reg_pc)[(1)]);
      ci = (CALL_INFO)((reg_pc)[(2)]);
      cc = (CALL_CACHE)((reg_pc)[(3)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_aref_with(key, ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_aref_with(key, ci, cc)))));
      ;
      ;
      ;
      ;
      ;
# 1311 "insns.def"
      {
        val = vm_opt_aref_with(recv, key);

        if (val == ((VALUE)RUBY_Qundef)) {

          ((*((((reg_cfp)->sp))) = (rb_str_resurrect(key))),
           (((reg_cfp)->sp) += (((1)))));

          do {
            rb_snum_t x = leaf ? attr_width_opt_aref_with(key, ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3119 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_aref_with(key, ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_aref_with(key, ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_length:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_length",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE recv, val;

    start_of_opt_length:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_length(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_length(ci, cc)))));
      ;
      ;
      ;
      ;
# 1328 "insns.def"
      {
        val = vm_opt_length(recv, BOP_LENGTH);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_length(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3159 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_length(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_length(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_size:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_size",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE recv, val;

    start_of_opt_size:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_size(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_size(ci, cc)))));
      ;
      ;
      ;
      ;
# 1342 "insns.def"
      {
        val = vm_opt_length(recv, BOP_SIZE);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_size(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3199 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_size(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_size(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_empty_p:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_empty_p",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE recv, val;

    start_of_opt_empty_p:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_empty_p(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_empty_p(ci, cc)))));
      ;
      ;
      ;
      ;
# 1356 "insns.def"
      {
        val = vm_opt_empty_p(recv);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_empty_p(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3239 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_empty_p(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_empty_p(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_succ:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_succ",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE recv, val;

    start_of_opt_succ:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_succ(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_succ(ci, cc)))));
      ;
      ;
      ;
      ;
# 1370 "insns.def"
      {
        val = vm_opt_succ(recv);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_succ(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3279 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_succ(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_succ(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_not:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_not",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE recv, val;

    start_of_opt_not:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      recv = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_not(ci, cc)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_not(ci, cc)))));
      ;
      ;
      ;
      ;
# 1384 "insns.def"
      {
        val = vm_opt_not(ci, cc, recv);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_not(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3319 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_not(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_opt_not(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_regexpmatch1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_regexpmatch1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE obj, recv, val;

    start_of_opt_regexpmatch1:;
      recv = (VALUE)((reg_pc)[(1)]);
      obj = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_regexpmatch1(recv)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_regexpmatch1(recv)))));
      ;
      ;
      ;
# 1399 "insns.def"
      {
        val = vm_opt_regexpmatch1(recv, obj);
      }
# 3351 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_regexpmatch1(recv)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_regexpmatch1(recv)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_regexpmatch2:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_regexpmatch2",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) CALL_CACHE cc;
      __attribute__((__unused__)) CALL_INFO ci;
      __attribute__((__unused__)) VALUE obj1, obj2, val;

    start_of_opt_regexpmatch2:;
      ci = (CALL_INFO)((reg_pc)[(1)]);
      cc = (CALL_CACHE)((reg_pc)[(2)]);
      obj2 = (*(((((reg_cfp)->sp))) - (1) - 1));
      obj1 = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_opt_regexpmatch2(ci, cc)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_regexpmatch2(ci, cc)))));
      ;
      ;
      ;
      ;
# 1409 "insns.def"
      {
        val = vm_opt_regexpmatch2(obj2, obj1);

        if (val == ((VALUE)RUBY_Qundef)) {
          do {
            rb_snum_t x = leaf ? attr_width_opt_regexpmatch2(ci, cc) : 0;
            rb_snum_t y = attr_width_opt_send_without_block(0, 0);
            rb_snum_t z = x - y;
            ((reg_cfp->pc = reg_pc = (reg_pc + (z))));
            goto start_of_opt_send_without_block;
            ;
          } while (0);
        }
      }
# 3392 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_opt_regexpmatch2(ci, cc)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_regexpmatch2(ci, cc)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_opt_call_c_function:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "opt_call_c_function",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) rb_insn_func_t funcptr;

    start_of_opt_call_c_function:;
      funcptr = (rb_insn_func_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_opt_call_c_function(funcptr)))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_call_c_function(funcptr)))));
      ((((reg_cfp)->sp) -= (((attr_popn_opt_call_c_function(funcptr))))));
      ;
      ;
      ;
# 1425 "insns.def"
      {
        reg_cfp = (funcptr)(ec, reg_cfp);

        if (reg_cfp == 0) {
          VALUE err = ec->errinfo;
          ec->errinfo = ((VALUE)RUBY_Qnil);
          return (VALUE)(err);
        }

        {
          (reg_cfp) = ec->cfp;
          reg_pc = reg_cfp->pc;
        };
        ;
        __extension__({ goto *(void const *)(*(reg_pc)); });
        ;
        ;
      }
# 3433 "vm.inc"
      ;
      ;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_opt_call_c_function(funcptr)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_bitblt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "bitblt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ret;

    start_of_bitblt:;
      ;
      if (!(leaf = attr_leaf_bitblt()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_bitblt()))));
      ;
      ;
# 1444 "insns.def"
      {
        ret = __extension__({
          (__builtin_constant_p("a bit of bacon, lettuce and tomato"))
              ? rb_str_new_static(
                    ("a bit of bacon, lettuce and tomato"),
                    (long)strlen("a bit of bacon, lettuce and tomato"))
              : rb_str_new_cstr("a bit of bacon, lettuce and tomato");
        });
      }
# 3460 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_bitblt()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ret;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_bitblt()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_answer:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "answer",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE ret;

    start_of_answer:;
      ;
      if (!(leaf = attr_leaf_answer()))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_answer()))));
      ;
      ;
# 1454 "insns.def"
      {
        ret = (((VALUE)(42)) << 1 | RUBY_FIXNUM_FLAG);
      }
# 3489 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_answer()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = ret;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_answer()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getlocal_WC_0:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getlocal_WC_0",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_getlocal_WC_0:;
# 10 "defs/opt_operand.def"
      level = 0;
# 3514 "vm.inc"
      idx = (lindex_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_getlocal_WC_0(idx)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal_WC_0(idx)))));
      ;
      ;
      ;
# 81 "insns.def"
      {
        val = *(vm_get_ep(((((reg_cfp)->ep))), level) - idx);
        ((void)0);
        (void)(level > 0);
      }
# 3527 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getlocal_WC_0(idx)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal_WC_0(idx)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_getlocal_WC_1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "getlocal_WC_1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_getlocal_WC_1:;
# 11 "defs/opt_operand.def"
      level = 1;
# 3552 "vm.inc"
      idx = (lindex_t)((reg_pc)[(1)]);
      ;
      if (!(leaf = attr_leaf_getlocal_WC_1(idx)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal_WC_1(idx)))));
      ;
      ;
      ;
# 81 "insns.def"
      {
        val = *(vm_get_ep(((((reg_cfp)->ep))), level) - idx);
        ((void)0);
        (void)(level > 0);
      }
# 3565 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_getlocal_WC_1(idx)))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_getlocal_WC_1(idx)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setlocal_WC_0:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setlocal_WC_0",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_setlocal_WC_0:;
# 12 "defs/opt_operand.def"
      level = 0;
# 3590 "vm.inc"
      idx = (lindex_t)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setlocal_WC_0(idx)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal_WC_0(idx)))));
      ;
      ;
      ;
# 95 "insns.def"
      {
        vm_env_write(vm_get_ep(((((reg_cfp)->ep))), level), -(int)idx, val);
        ((void)0);
        (void)(level > 0);
      }
# 3604 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setlocal_WC_0(idx)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal_WC_0(idx)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_setlocal_WC_1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "setlocal_WC_1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;
      __attribute__((__unused__)) lindex_t idx;
      __attribute__((__unused__)) rb_num_t level;

    start_of_setlocal_WC_1:;
# 13 "defs/opt_operand.def"
      level = 1;
# 3628 "vm.inc"
      idx = (lindex_t)((reg_pc)[(1)]);
      val = (*(((((reg_cfp)->sp))) - (0) - 1));
      ;
      if (!(leaf = attr_leaf_setlocal_WC_1(idx)))
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal_WC_1(idx)))));
      ;
      ;
      ;
# 95 "insns.def"
      {
        vm_env_write(vm_get_ep(((((reg_cfp)->ep))), level), -(int)idx, val);
        ((void)0);
        (void)(level > 0);
      }
# 3642 "vm.inc"
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_setlocal_WC_1(idx)))));
      if (leaf)
        ((reg_cfp->pc = reg_pc = (reg_pc + (attr_width_setlocal_WC_1(idx)))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putobject_INT2FIX_0_:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putobject_INT2FIX_0_",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_putobject_INT2FIX_0_:;
# 15 "defs/opt_operand.def"
      val = (((VALUE)(0)) << 1 | RUBY_FIXNUM_FLAG);
# 3664 "vm.inc"
      ;
      if (!(leaf = attr_leaf_putobject_INT2FIX_0_()))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putobject_INT2FIX_0_()))));
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putobject_INT2FIX_0_()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putobject_INT2FIX_0_()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_putobject_INT2FIX_1_:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "putobject_INT2FIX_1_",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {

      _Bool leaf;
      __attribute__((__unused__)) VALUE *canary;
      __attribute__((__unused__)) VALUE val;

    start_of_putobject_INT2FIX_1_:;
# 16 "defs/opt_operand.def"
      val = (((VALUE)(1)) << 1 | RUBY_FIXNUM_FLAG);
# 3689 "vm.inc"
      ;
      if (!(leaf = attr_leaf_putobject_INT2FIX_1_()))
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putobject_INT2FIX_1_()))));
      ;
      ;
      (((reg_cfp)->sp) += (((attr_sp_inc_putobject_INT2FIX_1_()))));
      (*(((((reg_cfp)->sp))) - (0) - 1)) = val;
      if (leaf)
        ((reg_cfp->pc = reg_pc =
              (reg_pc + (attr_width_putobject_INT2FIX_1_()))));
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_nop:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_nop",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_nop;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getlocal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getlocal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getlocal;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setlocal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setlocal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setlocal;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getblockparam:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getblockparam",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getblockparam;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setblockparam:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setblockparam",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setblockparam;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getblockparamproxy:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_getblockparamproxy",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getblockparamproxy;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getspecial:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getspecial",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getspecial;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setspecial:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setspecial",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setspecial;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getinstancevariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_getinstancevariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getinstancevariable;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setinstancevariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_setinstancevariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setinstancevariable;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getclassvariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getclassvariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getclassvariable;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setclassvariable:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setclassvariable",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setclassvariable;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getconstant:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getconstant",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getconstant;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setconstant:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setconstant",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setconstant;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getglobal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getglobal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getglobal;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setglobal:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setglobal",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setglobal;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putnil:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putnil",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putnil;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putself:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putself",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putself;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putobject:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putobject",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putobject;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putspecialobject:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putspecialobject",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putspecialobject;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putiseq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putiseq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putiseq;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putstring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_putstring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putstring;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_concatstrings:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_concatstrings",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_concatstrings;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_tostring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_tostring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_tostring;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_freezestring:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_freezestring",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_freezestring;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_toregexp:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_toregexp",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_toregexp;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_intern:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_intern",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_intern;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_newarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_newarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_newarray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_duparray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_duparray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_duparray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_expandarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_expandarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_expandarray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_concatarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_concatarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_concatarray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_splatarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_splatarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_splatarray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_newhash:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_newhash",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_newhash;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_newhashfromarray:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_newhashfromarray",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_newhashfromarray;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_newrange:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_newrange",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_newrange;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_pop:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_pop",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_pop;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_dup:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_dup",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_dup;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_dupn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_dupn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_dupn;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_swap:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_swap",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_swap;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_reverse:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_reverse",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_reverse;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_reput:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_reput",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_reput;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_topn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_topn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_topn;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setn:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setn",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setn;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_adjuststack:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_adjuststack",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_adjuststack;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_defined:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_defined",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_defined;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_checkmatch:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_checkmatch",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_checkmatch;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_checkkeyword:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_checkkeyword",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_checkkeyword;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_checktype:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_checktype",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_checktype;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_defineclass:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_defineclass",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_defineclass;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_send:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_send",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_send;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_send_without_block:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_opt_send_without_block",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_send_without_block;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_str_freeze:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_str_freeze",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_str_freeze;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_str_uminus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_str_uminus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_str_uminus;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_newarray_max:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_newarray_max",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_newarray_max;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_newarray_min:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_newarray_min",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_newarray_min;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_invokesuper:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_invokesuper",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_invokesuper;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_invokeblock:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_invokeblock",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_invokeblock;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_leave:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_leave",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_leave;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_throw:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_throw",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_throw;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_jump:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_jump",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_jump;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_branchif:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_branchif",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_branchif;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_branchunless:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_branchunless",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_branchunless;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_branchnil:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_branchnil",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_branchnil;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_getinlinecache:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_opt_getinlinecache",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_getinlinecache;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_setinlinecache:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_opt_setinlinecache",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_setinlinecache;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_once:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_once",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_once;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_case_dispatch:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_case_dispatch",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_case_dispatch;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_plus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_plus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_plus;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_minus:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_minus",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_minus;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_mult:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_mult",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_mult;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_div:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_div",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_div;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_mod:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_mod",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_mod;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_eq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_eq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_eq;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_neq:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_neq",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_neq;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_lt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_lt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_lt;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_le:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_le",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_le;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_gt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_gt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_gt;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_ge:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_ge",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_ge;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_ltlt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_ltlt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_ltlt;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_and:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_and",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_and;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_or:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_or",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_or;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_aref:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_aref",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_aref;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_aset:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_aset",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_aset;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_aset_with:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_aset_with",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_aset_with;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_aref_with:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_aref_with",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_aref_with;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_length:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_length",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_length;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_size:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_size",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_size;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_empty_p:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_empty_p",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_empty_p;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_succ:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_succ",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_succ;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_not:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_not",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_not;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_regexpmatch1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_regexpmatch1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_regexpmatch1;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_regexpmatch2:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_opt_regexpmatch2",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_regexpmatch2;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_opt_call_c_function:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_opt_call_c_function",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_opt_call_c_function;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_bitblt:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_bitblt",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_bitblt;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_answer:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_answer",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_answer;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getlocal_WC_0:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getlocal_WC_0",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getlocal_WC_0;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_getlocal_WC_1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_getlocal_WC_1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_getlocal_WC_1;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setlocal_WC_0:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setlocal_WC_0",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setlocal_WC_0;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_setlocal_WC_1:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n", "trace_setlocal_WC_1",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_setlocal_WC_1;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putobject_INT2FIX_0_:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_putobject_INT2FIX_0_",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putobject_INT2FIX_0_;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }

  INSN_LABEL_trace_putobject_INT2FIX_1_:
    if (0)
      fprintf(__stderrp, "exec: %s@(%d, %d)@%s:%d\n",
              "trace_putobject_INT2FIX_1_",
              (int)(reg_pc - reg_cfp->iseq->body->iseq_encoded),
              (int)(reg_cfp->pc - reg_cfp->iseq->body->iseq_encoded),
              (!(((struct RBasic *)(rb_iseq_path(reg_cfp->iseq)))->flags &
                 RSTRING_NOEMBED)
                   ? ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))->as.ary
                   : ((struct RString *)(rb_iseq_path(reg_cfp->iseq)))
                         ->as.heap.ptr),
              (int)(rb_iseq_line_no(
                  reg_cfp->iseq, reg_pc - reg_cfp->iseq->body->iseq_encoded)));
    ;
    {
      vm_trace(ec, (((reg_cfp))), (reg_pc));
      goto start_of_putobject_INT2FIX_1_;
      ;
      ;
      ;
      __extension__({ goto *(void const *)(*(reg_pc)); });
      ;
      ;
      ;
    }
# 117 "./vm_exec.c" 2

    rb_bug("unknown insn: %"
           "l"
           "d",
           (*(reg_pc)));
  };

  rb_bug("vm_eval: unreachable");
  goto first;
}

const void **rb_vm_get_insns_address_table(void) {
  return (const void **)vm_exec_core(0, 0);
}
# 317 "vm.c" 2

# 1 "./vm_method.c" 1

# 1 "./id_table.h" 1

struct rb_id_table;

enum rb_id_table_iterator_result {
  ID_TABLE_CONTINUE = ST_CONTINUE,
  ID_TABLE_STOP = ST_STOP,
  ID_TABLE_DELETE = ST_DELETE,
  ID_TABLE_ITERATOR_RESULT_END
};

struct rb_id_table *rb_id_table_create(size_t size);
void rb_id_table_free(struct rb_id_table *tbl);
void rb_id_table_clear(struct rb_id_table *tbl);

size_t rb_id_table_size(const struct rb_id_table *tbl);
size_t rb_id_table_memsize(const struct rb_id_table *tbl);

int rb_id_table_insert(struct rb_id_table *tbl, ID id, VALUE val);
int rb_id_table_lookup(struct rb_id_table *tbl, ID id, VALUE *valp);
int rb_id_table_delete(struct rb_id_table *tbl, ID id);

typedef enum rb_id_table_iterator_result
rb_id_table_foreach_func_t(ID id, VALUE val, void *data);
typedef enum rb_id_table_iterator_result
rb_id_table_foreach_values_func_t(VALUE val, void *data);
void rb_id_table_foreach(struct rb_id_table *tbl,
                         rb_id_table_foreach_func_t *func, void *data);
void rb_id_table_foreach_values(struct rb_id_table *tbl,
                                rb_id_table_foreach_values_func_t *func,
                                void *data);
# 6 "./vm_method.c" 2
# 28 "./vm_method.c"
static int vm_redefinition_check_flag(VALUE klass);
static void rb_vm_check_redefinition_opt_method(const rb_method_entry_t *me,
                                                VALUE klass);
# 40 "./vm_method.c"
struct cache_entry {
  rb_serial_t method_state;
  rb_serial_t class_serial;
  ID mid;
  rb_method_entry_t *me;
  VALUE defined_class;
};

static struct {
  unsigned int size;
  unsigned int mask;
  struct cache_entry *entries;
} global_method_cache = {
    0x800,
    (0x800 - 1),
};

static void rb_class_clear_method_cache(VALUE klass, VALUE arg) {
  mjit_remove_class_serial(((((struct RClass *)(klass))->ptr)->class_serial));
  ((((struct RClass *)(klass))->ptr)->class_serial) = rb_next_class_serial();

  if ((((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_ICLASS)))) {
    struct rb_id_table *table =
        ((((struct RClass *)(klass))->ptr)->callable_m_tbl);
    if (table) {
      rb_id_table_clear(table);
    }
  } else {
    if (((((struct RClass *)(klass))->ptr)->callable_m_tbl) != 0) {
      rb_obj_info_dump(klass);
      rb_bug("RCLASS_CALLABLE_M_TBL(klass) != 0");
    }
  }

  rb_class_foreach_subclass(klass, rb_class_clear_method_cache, arg);
}

void rb_clear_constant_cache(void) { (++ruby_vm_global_constant_state); }

void rb_clear_method_cache_by_class(VALUE klass) {
  if (klass && klass != ((VALUE)RUBY_Qundef)) {
    int global =
        klass == rb_cBasicObject || klass == rb_cObject || klass == rb_mKernel;

    do {
      if ((__builtin_expect(!!(({
            int _r = __dtrace_isenabled$ruby$method__cache__clear$v1();
            __asm__ volatile("");
            _r;
          })),
                            0))) {
        int dtrace_line;
        const char *dtrace_file = rb_source_location_cstr(&dtrace_line);
        if (!dtrace_file)
          dtrace_file = "";
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$method__cache__clear$v1$63686172202a$63686172202a$696e74(
              (global ? "global" : rb_class2name(klass)), dtrace_file,
              dtrace_line);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    } while (0);

    if (global) {
      (++ruby_vm_global_method_state);
    } else {
      rb_class_clear_method_cache(klass, ((VALUE)RUBY_Qnil));
    }
  }

  if (klass == rb_mKernel) {
    rb_subclass_entry_t *entry = (((struct RClass *)(klass))->ptr)->subclasses;

    for (; entry != ((void *)0); entry = entry->next) {
      struct rb_id_table *table =
          ((((struct RClass *)(entry->klass))->ptr)->callable_m_tbl);
      if (table)
        rb_id_table_clear(table);
    }
  }
}

VALUE
rb_f_notimplement(int argc, const VALUE *argv, VALUE obj) {
  rb_notimplement();

  __builtin_unreachable();
}

static void rb_define_notimplement_method_id(VALUE mod, ID id,
                                             rb_method_visibility_t visi) {
  rb_add_method(mod, id, VM_METHOD_TYPE_NOTIMPLEMENTED, (void *)1, visi);
}

void rb_add_method_cfunc(VALUE klass, ID mid, VALUE (*func)(), int argc,
                         rb_method_visibility_t visi) {
  if (argc < -2 || 15 < argc)
    rb_raise(rb_eArgError, "arity out of range: %d for -2..15", argc);
  if (func != rb_f_notimplement) {
    rb_method_cfunc_t opt;
    opt.func = func;
    opt.argc = argc;
    rb_add_method(klass, mid, VM_METHOD_TYPE_CFUNC, &opt, visi);
  } else {
    rb_define_notimplement_method_id(klass, mid, visi);
  }
}

static void rb_method_definition_release(rb_method_definition_t *def,
                                         int complemented) {
  if (def != ((void *)0)) {
    const int alias_count = def->alias_count;
    const int complemented_count = def->complemented_count;
    ((void)0);
    ((void)0);

    if (alias_count + complemented_count == 0) {
      if (0)
        fprintf(__stderrp, "-%p-%s:%d,%d (remove)\n", (void *)def,
                rb_id2name(def->original_id), alias_count, complemented_count);
      ruby_xfree(def);
    } else {
      if (complemented)
        def->complemented_count--;
      else if (def->alias_count > 0)
        def->alias_count--;

      if (0)
        fprintf(__stderrp, "-%p-%s:%d->%d,%d->%d (dec)\n", (void *)def,
                rb_id2name(def->original_id), alias_count, def->alias_count,
                complemented_count, def->complemented_count);
    }
  }
}

void rb_free_method_entry(const rb_method_entry_t *me) {
  rb_method_definition_release(me->def, ((me)->flags & ((VALUE)RUBY_FL_USER7)));
}

static inline rb_method_entry_t *search_method(VALUE klass, ID id,
                                               VALUE *defined_class_ptr);
extern int rb_method_definition_eq(const rb_method_definition_t *d1,
                                   const rb_method_definition_t *d2);

static inline rb_method_entry_t *lookup_method_table(VALUE klass, ID id) {
  st_data_t body;
  struct rb_id_table *m_tbl = (((struct RClass *)(klass))->m_tbl);

  if (rb_id_table_lookup(m_tbl, id, &body)) {
    return (rb_method_entry_t *)body;
  } else {
    return 0;
  }
}

static VALUE (*call_cfunc_invoker_func(int argc))(VALUE (*func)(), VALUE recv,
                                                  int argc, const VALUE *) {
  switch (argc) {
  case -2:
    return &call_cfunc_m2;
  case -1:
    return &call_cfunc_m1;
  case 0:
    return &call_cfunc_0;
  case 1:
    return &call_cfunc_1;
  case 2:
    return &call_cfunc_2;
  case 3:
    return &call_cfunc_3;
  case 4:
    return &call_cfunc_4;
  case 5:
    return &call_cfunc_5;
  case 6:
    return &call_cfunc_6;
  case 7:
    return &call_cfunc_7;
  case 8:
    return &call_cfunc_8;
  case 9:
    return &call_cfunc_9;
  case 10:
    return &call_cfunc_10;
  case 11:
    return &call_cfunc_11;
  case 12:
    return &call_cfunc_12;
  case 13:
    return &call_cfunc_13;
  case 14:
    return &call_cfunc_14;
  case 15:
    return &call_cfunc_15;
  default:
    rb_bug("call_cfunc_func: unsupported length: %d", argc);
  }
}

static void setup_method_cfunc_struct(rb_method_cfunc_t *cfunc, VALUE (*func)(),
                                      int argc) {
  cfunc->func = func;
  cfunc->argc = argc;
  cfunc->invoker = call_cfunc_invoker_func(argc);
}

__attribute__((__visibility__("default"))) extern void
rb_method_definition_set(const rb_method_entry_t *me,
                         rb_method_definition_t *def, void *opts) {
  *(rb_method_definition_t **)&me->def = def;

  if (opts != ((void *)0)) {
    switch (def->type) {
    case VM_METHOD_TYPE_ISEQ: {
      rb_method_iseq_t *iseq_body = (rb_method_iseq_t *)opts;
      rb_cref_t *method_cref, *cref = iseq_body->cref;

      __extension__({
# 239 "./vm_method.c"
#pragma clang diagnostic push
# 239 "./vm_method.c"
        ;
# 239 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 239 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.iseq.iseqptr),
                            (VALUE)(iseq_body->iseqptr), "./vm_method.c",
                            239)) unaligned_member_access_result =
            (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.iseq.iseqptr),
                          (VALUE)(iseq_body->iseqptr), "./vm_method.c", 239));
# 239 "./vm_method.c"
#pragma clang diagnostic pop
# 239 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });

      if (0)
        vm_cref_dump("rb_method_definition_create", cref);

      if (cref) {
        method_cref = cref;
      } else {
        method_cref = vm_cref_new_toplevel(rb_current_execution_context());
      }

      __extension__({
# 250 "./vm_method.c"
#pragma clang diagnostic push
# 250 "./vm_method.c"
        ;
# 250 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 250 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.iseq.cref),
                            (VALUE)(method_cref), "./vm_method.c", 250))
            unaligned_member_access_result =
                (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.iseq.cref),
                              (VALUE)(method_cref), "./vm_method.c", 250));
# 250 "./vm_method.c"
#pragma clang diagnostic pop
# 250 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });
      return;
    }
    case VM_METHOD_TYPE_CFUNC: {
      rb_method_cfunc_t *cfunc = (rb_method_cfunc_t *)opts;
      setup_method_cfunc_struct(__extension__({
# 256 "./vm_method.c"
#pragma clang diagnostic push
# 256 "./vm_method.c"
                                  ;
# 256 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 256 "./vm_method.c"
                                  ;
                                  typeof(&(def)->body.cfunc)
                                      unaligned_member_access_result =
                                          (&(def)->body.cfunc);
# 256 "./vm_method.c"
#pragma clang diagnostic pop
# 256 "./vm_method.c"
                                  ;
                                  unaligned_member_access_result;
                                }),
                                cfunc->func, cfunc->argc);
      return;
    }
    case VM_METHOD_TYPE_ATTRSET:
    case VM_METHOD_TYPE_IVAR: {
      const rb_execution_context_t *ec = rb_current_execution_context();
      rb_control_frame_t *cfp;
      int line;

      def->body.attr.id = (ID)(VALUE)opts;

      cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

      if (cfp && (line = rb_vm_get_sourceline(cfp))) {
        VALUE location = __extension__({
          const VALUE args_to_new_ary[] = {
              rb_iseq_path(cfp->iseq),
              (((VALUE)(line)) << 1 | RUBY_FIXNUM_FLAG)};
          if (__builtin_constant_p(2)) {
            _Static_assert(((int)(sizeof(args_to_new_ary) /
                                  sizeof((args_to_new_ary)[0]))) == (2),
                           "rb_ary_new_from_args"
                           ": "
                           "numberof(args_to_new_ary) == (2)");
          }
          rb_ary_new_from_values(
              ((int)(sizeof(args_to_new_ary) / sizeof((args_to_new_ary)[0]))),
              args_to_new_ary);
        });
        __extension__({
# 272 "./vm_method.c"
#pragma clang diagnostic push
# 272 "./vm_method.c"
          ;
# 272 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 272 "./vm_method.c"
          ;
          typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.attr.location),
                              (VALUE)(rb_ary_freeze(location)), "./vm_method.c",
                              272)) unaligned_member_access_result =
              (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.attr.location),
                            (VALUE)(rb_ary_freeze(location)), "./vm_method.c",
                            272));
# 272 "./vm_method.c"
#pragma clang diagnostic pop
# 272 "./vm_method.c"
          ;
          unaligned_member_access_result;
        });
      } else {
        ((void)0);
      }
      return;
    }
    case VM_METHOD_TYPE_BMETHOD:
      __extension__({
# 280 "./vm_method.c"
#pragma clang diagnostic push
# 280 "./vm_method.c"
        ;
# 280 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 280 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.proc),
                            (VALUE)((VALUE)opts), "./vm_method.c", 280))
            unaligned_member_access_result =
                (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.proc),
                              (VALUE)((VALUE)opts), "./vm_method.c", 280));
# 280 "./vm_method.c"
#pragma clang diagnostic pop
# 280 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });
      return;
    case VM_METHOD_TYPE_NOTIMPLEMENTED:
      setup_method_cfunc_struct(__extension__({
# 283 "./vm_method.c"
#pragma clang diagnostic push
# 283 "./vm_method.c"
                                  ;
# 283 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 283 "./vm_method.c"
                                  ;
                                  typeof(&(def)->body.cfunc)
                                      unaligned_member_access_result =
                                          (&(def)->body.cfunc);
# 283 "./vm_method.c"
#pragma clang diagnostic pop
# 283 "./vm_method.c"
                                  ;
                                  unaligned_member_access_result;
                                }),
                                rb_f_notimplement, -1);
      return;
    case VM_METHOD_TYPE_OPTIMIZED:
      def->body.optimize_type = (enum method_optimized_type)opts;
      return;
    case VM_METHOD_TYPE_REFINED: {
      const rb_method_refined_t *refined = (rb_method_refined_t *)opts;
      __extension__({
# 291 "./vm_method.c"
#pragma clang diagnostic push
# 291 "./vm_method.c"
        ;
# 291 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 291 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.refined.orig_me),
                            (VALUE)(refined->orig_me), "./vm_method.c",
                            291)) unaligned_member_access_result =
            (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.refined.orig_me),
                          (VALUE)(refined->orig_me), "./vm_method.c", 291));
# 291 "./vm_method.c"
#pragma clang diagnostic pop
# 291 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });
      __extension__({
# 292 "./vm_method.c"
#pragma clang diagnostic push
# 292 "./vm_method.c"
        ;
# 292 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 292 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me), (VALUE *)(&def->body.refined.owner),
                            (VALUE)(refined->owner), "./vm_method.c", 292))
            unaligned_member_access_result =
                (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.refined.owner),
                              (VALUE)(refined->owner), "./vm_method.c", 292));
# 292 "./vm_method.c"
#pragma clang diagnostic pop
# 292 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });
      return;
    }
    case VM_METHOD_TYPE_ALIAS:
      __extension__({
# 296 "./vm_method.c"
#pragma clang diagnostic push
# 296 "./vm_method.c"
        ;
# 296 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 296 "./vm_method.c"
        ;
        typeof(rb_obj_write((VALUE)(me),
                            (VALUE *)(&def->body.alias.original_me),
                            (VALUE)((rb_method_entry_t *)opts), "./vm_method.c",
                            296)) unaligned_member_access_result =
            (rb_obj_write((VALUE)(me), (VALUE *)(&def->body.alias.original_me),
                          (VALUE)((rb_method_entry_t *)opts), "./vm_method.c",
                          296));
# 296 "./vm_method.c"
#pragma clang diagnostic pop
# 296 "./vm_method.c"
        ;
        unaligned_member_access_result;
      });
      return;
    case VM_METHOD_TYPE_ZSUPER:
    case VM_METHOD_TYPE_UNDEF:
    case VM_METHOD_TYPE_MISSING:
      return;
    }
  }
}

static void method_definition_reset(const rb_method_entry_t *me) {
  rb_method_definition_t *def = me->def;

  switch (def->type) {
  case VM_METHOD_TYPE_ISEQ:
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.iseq.iseqptr), "./vm_method.c", 313);
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.iseq.cref), "./vm_method.c", 314);
    break;
  case VM_METHOD_TYPE_ATTRSET:
  case VM_METHOD_TYPE_IVAR:
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.attr.location), "./vm_method.c", 318);
    break;
  case VM_METHOD_TYPE_BMETHOD:
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.proc), "./vm_method.c", 321);
    break;
  case VM_METHOD_TYPE_REFINED:
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.refined.orig_me), "./vm_method.c", 324);
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.refined.owner), "./vm_method.c", 325);
    break;
  case VM_METHOD_TYPE_ALIAS:
    rb_obj_written((VALUE)(me), (VALUE)(((VALUE)RUBY_Qundef)),
                   (VALUE)(def->body.alias.original_me), "./vm_method.c", 328);
    break;
  case VM_METHOD_TYPE_CFUNC:
  case VM_METHOD_TYPE_ZSUPER:
  case VM_METHOD_TYPE_MISSING:
  case VM_METHOD_TYPE_OPTIMIZED:
  case VM_METHOD_TYPE_UNDEF:
  case VM_METHOD_TYPE_NOTIMPLEMENTED:
    break;
  }
}

__attribute__((__visibility__("default"))) extern rb_method_definition_t *
rb_method_definition_create(rb_method_type_t type, ID mid) {
  rb_method_definition_t *def;
  def = (((rb_method_definition_t *)ruby_xcalloc(
      (size_t)(1), sizeof(rb_method_definition_t))));
  def->type = type;
  def->original_id = mid;
  return def;
}

static rb_method_definition_t *
method_definition_addref(rb_method_definition_t *def) {
  def->alias_count++;
  if (0)
    fprintf(__stderrp, "+%p-%s:%d\n", (void *)def, rb_id2name(def->original_id),
            def->alias_count);
  return def;
}

static rb_method_definition_t *
method_definition_addref_complement(rb_method_definition_t *def) {
  def->complemented_count++;
  if (0)
    fprintf(__stderrp, "+%p-%s:%d\n", (void *)def, rb_id2name(def->original_id),
            def->complemented_count);
  return def;
}

static rb_method_entry_t *
rb_method_entry_alloc(ID called_id, VALUE owner, VALUE defined_class,
                      const rb_method_definition_t *def) {
  rb_method_entry_t *me = (rb_method_entry_t *)rb_imemo_new(
      imemo_ment, (VALUE)def, (VALUE)called_id, owner, defined_class);
  return me;
}

static VALUE filter_defined_class(VALUE klass) {
  switch ((int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK)) {
  case RUBY_T_CLASS:
    return klass;
  case RUBY_T_MODULE:
    return 0;
  case RUBY_T_ICLASS:
    break;
  }
  rb_bug("filter_defined_class: %s", rb_obj_info(klass));
}

rb_method_entry_t *rb_method_entry_create(ID called_id, VALUE klass,
                                          rb_method_visibility_t visi,
                                          const rb_method_definition_t *def) {
  rb_method_entry_t *me =
      rb_method_entry_alloc(called_id, klass, filter_defined_class(klass), def);
  METHOD_ENTRY_FLAGS_SET(me, visi, (rb_current_vm()->running) ? 0 : 1);
  if (def != ((void *)0))
    method_definition_reset(me);
  return me;
}

const rb_method_entry_t *
rb_method_entry_clone(const rb_method_entry_t *src_me) {
  rb_method_entry_t *me = rb_method_entry_alloc(
      src_me->called_id, src_me->owner, src_me->defined_class,
      method_definition_addref(src_me->def));
  METHOD_ENTRY_FLAGS_COPY(me, src_me);
  return me;
}

__attribute__((
    __visibility__("default"))) extern const rb_callable_method_entry_t *
rb_method_entry_complement_defined_class(const rb_method_entry_t *src_me,
                                         ID called_id, VALUE defined_class) {
  rb_method_definition_t *def = src_me->def;
  rb_method_entry_t *me;
  struct {
    const struct rb_method_entry_struct *orig_me;
    VALUE owner;
  } refined = {0};

  if (!src_me->defined_class && def->type == VM_METHOD_TYPE_REFINED &&
      def->body.refined.orig_me) {
    const rb_method_entry_t *orig_me =
        rb_method_entry_clone(def->body.refined.orig_me);
    __extension__({
# 420 "./vm_method.c"
#pragma clang diagnostic push
# 420 "./vm_method.c"
      ;
# 420 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 420 "./vm_method.c"
      ;
      typeof(rb_obj_write((VALUE)((VALUE)orig_me),
                          (VALUE *)(&orig_me->defined_class),
                          (VALUE)(defined_class), "./vm_method.c", 420))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)((VALUE)orig_me),
                            (VALUE *)(&orig_me->defined_class),
                            (VALUE)(defined_class), "./vm_method.c", 420));
# 420 "./vm_method.c"
#pragma clang diagnostic pop
# 420 "./vm_method.c"
      ;
      unaligned_member_access_result;
    });
    refined.orig_me = orig_me;
    refined.owner = orig_me->owner;
    def = ((void *)0);
  } else {
    def = method_definition_addref_complement(def);
  }
  me = rb_method_entry_alloc(called_id, src_me->owner, defined_class, def);
  METHOD_ENTRY_FLAGS_COPY(me, src_me);
  ((me)->flags = (me)->flags | ((VALUE)RUBY_FL_USER7));
  if (!def) {
    def = rb_method_definition_create(VM_METHOD_TYPE_REFINED, called_id);
    rb_method_definition_set(me, def, &refined);
  }

  ((void)0);

  return (rb_callable_method_entry_t *)me;
}

void rb_method_entry_copy(rb_method_entry_t *dst,
                          const rb_method_entry_t *src) {
  *(rb_method_definition_t **)&dst->def = method_definition_addref(src->def);
  method_definition_reset(dst);
  dst->called_id = src->called_id;
  __extension__({
# 447 "./vm_method.c"
#pragma clang diagnostic push
# 447 "./vm_method.c"
    ;
# 447 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 447 "./vm_method.c"
    ;
    typeof(rb_obj_write((VALUE)((VALUE)dst), (VALUE *)(&dst->owner),
                        (VALUE)(src->owner), "./vm_method.c", 447))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)((VALUE)dst), (VALUE *)(&dst->owner),
                          (VALUE)(src->owner), "./vm_method.c", 447));
# 447 "./vm_method.c"
#pragma clang diagnostic pop
# 447 "./vm_method.c"
    ;
    unaligned_member_access_result;
  });
  __extension__({
# 448 "./vm_method.c"
#pragma clang diagnostic push
# 448 "./vm_method.c"
    ;
# 448 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 448 "./vm_method.c"
    ;
    typeof(rb_obj_write((VALUE)((VALUE)dst), (VALUE *)(&dst->defined_class),
                        (VALUE)(src->defined_class), "./vm_method.c", 448))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)((VALUE)dst), (VALUE *)(&dst->defined_class),
                          (VALUE)(src->defined_class), "./vm_method.c", 448));
# 448 "./vm_method.c"
#pragma clang diagnostic pop
# 448 "./vm_method.c"
    ;
    unaligned_member_access_result;
  });
  METHOD_ENTRY_FLAGS_COPY(dst, src);
}

static void make_method_entry_refined(VALUE owner, rb_method_entry_t *me) {
  if (me->def->type == VM_METHOD_TYPE_REFINED) {
    return;
  } else {
    struct {
      struct rb_method_entry_struct *orig_me;
      VALUE owner;
    } refined;
    rb_method_definition_t *def;

    rb_vm_check_redefinition_opt_method(me, me->owner);

    refined.orig_me = rb_method_entry_alloc(
        me->called_id, me->owner, me->defined_class ? me->defined_class : owner,
        method_definition_addref(me->def));
    METHOD_ENTRY_FLAGS_COPY(refined.orig_me, me);
    refined.owner = owner;

    def = rb_method_definition_create(VM_METHOD_TYPE_REFINED, me->called_id);
    rb_method_definition_set(me, def, (void *)&refined);
    METHOD_ENTRY_VISI_SET(me, METHOD_VISI_PUBLIC);
  }
}

void rb_add_refined_method_entry(VALUE refined_class, ID mid) {
  rb_method_entry_t *me = lookup_method_table(refined_class, mid);

  if (me) {
    make_method_entry_refined(refined_class, me);
    rb_clear_method_cache_by_class(refined_class);
  } else {
    rb_add_method(refined_class, mid, VM_METHOD_TYPE_REFINED, 0,
                  METHOD_VISI_PUBLIC);
  }
}

static void check_override_opt_method(VALUE klass, VALUE arg) {
  ID mid = (ID)arg;
  const rb_method_entry_t *me, *newme;

  if (vm_redefinition_check_flag(klass)) {
    me = lookup_method_table(((((struct RClass *)(klass))->ptr)->origin_), mid);
    if (me) {
      newme = rb_method_entry(klass, mid);
      if (newme != me)
        rb_vm_check_redefinition_opt_method(me, me->owner);
    }
  }
  rb_class_foreach_subclass(klass, check_override_opt_method, (VALUE)mid);
}

static rb_method_entry_t *
rb_method_entry_make(VALUE klass, ID mid, VALUE defined_class,
                     rb_method_visibility_t visi, rb_method_type_t type,
                     rb_method_definition_t *def, ID original_id, void *opts) {
  rb_method_entry_t *me;
  struct rb_id_table *mtbl;
  st_data_t data;
  int make_refined = 0;

  if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
    klass = rb_cObject;
  }
  if (!((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
           !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
         (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) != RUBY_T_NODE)
            ? (((struct RBasic *)((klass)))->flags &
               ((((VALUE)RUBY_FL_SINGLETON))))
            : 0) &&
      type != VM_METHOD_TYPE_NOTIMPLEMENTED && type != VM_METHOD_TYPE_ZSUPER) {
    switch (mid) {
    case idInitialize:
    case idInitialize_copy:
    case idInitialize_clone:
    case idInitialize_dup:
    case idRespond_to_missing:
      visi = METHOD_VISI_PRIVATE;
    }
  }

  rb_class_modify_check(klass);

  if (((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((klass)))->flags & ((RMODULE_IS_REFINEMENT)))
           : 0)) {
    VALUE refined_class = rb_refinement_module_get_refined_class(klass);
    rb_add_refined_method_entry(refined_class, mid);
  }
  if (type == VM_METHOD_TYPE_REFINED) {
    rb_method_entry_t *old_me =
        lookup_method_table(((((struct RClass *)(klass))->ptr)->origin_), mid);
    if (old_me)
      rb_vm_check_redefinition_opt_method(old_me, klass);
  } else {
    klass = ((((struct RClass *)(klass))->ptr)->origin_);
  }
  mtbl = (((struct RClass *)(klass))->m_tbl);

  if (rb_id_table_lookup(mtbl, mid, &data)) {
    rb_method_entry_t *old_me = (rb_method_entry_t *)data;
    rb_method_definition_t *old_def = old_me->def;

    if (rb_method_definition_eq(old_def, def))
      return old_me;
    rb_vm_check_redefinition_opt_method(old_me, klass);

    if (old_def->type == VM_METHOD_TYPE_REFINED)
      make_refined = 1;

    if (!(((VALUE)((*rb_ruby_verbose_ptr())) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
          0) &&
        type != VM_METHOD_TYPE_UNDEF && (old_def->alias_count == 0) &&
        !make_refined && old_def->type != VM_METHOD_TYPE_UNDEF &&
        old_def->type != VM_METHOD_TYPE_ZSUPER &&
        old_def->type != VM_METHOD_TYPE_ALIAS) {
      const rb_iseq_t *iseq = 0;

      rb_warning("method redefined; discarding old %"
                 "l"
                 "i"
                 "\v",
                 rb_id2str(mid));
      switch (old_def->type) {
      case VM_METHOD_TYPE_ISEQ:
        iseq = def_iseq_ptr(old_def);
        break;
      case VM_METHOD_TYPE_BMETHOD:
        iseq = rb_proc_get_iseq(old_def->body.proc, 0);
        break;
      default:
        break;
      }
      if (iseq) {
        rb_compile_warning(
            (!(((struct RBasic *)(rb_iseq_path(iseq)))->flags & RSTRING_NOEMBED)
                 ? ((struct RString *)(rb_iseq_path(iseq)))->as.ary
                 : ((struct RString *)(rb_iseq_path(iseq)))->as.heap.ptr),
            ((int)rb_fix2int((VALUE)(iseq->body->location.first_lineno))),
            "previous definition of %"
            "l"
            "i"
            "\v"
            " was here",
            rb_id2str(old_def->original_id));
      }
    }
  }

  me = rb_method_entry_create(mid, defined_class, visi, ((void *)0));
  if (def == ((void *)0))
    def = rb_method_definition_create(type, original_id);
  rb_method_definition_set(me, def, opts);

  rb_clear_method_cache_by_class(klass);

  if (klass == rb_cObject && mid == idInitialize) {
    rb_warn("redefining Object#initialize may cause infinite loop");
  }

  if (mid == idObject_id || mid == id__send__) {
    if (type == VM_METHOD_TYPE_ISEQ && search_method(klass, mid, 0)) {
      rb_warn("redefining `%s' may cause serious problems", rb_id2name(mid));
    }
  }

  if (make_refined) {
    make_method_entry_refined(klass, me);
  }

  rb_id_table_insert(mtbl, mid, (VALUE)me);
  rb_obj_written((VALUE)(klass), (VALUE)(((VALUE)RUBY_Qundef)),
                 (VALUE)((VALUE)me), "./vm_method.c", 619);

  ((void)0);

  if ((((RUBY_T_MODULE) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_MODULE) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_MODULE)))) {
    check_override_opt_method(klass, (VALUE)mid);
  }

  return me;
}
# 642 "./vm_method.c"
static void method_added(VALUE klass, ID mid) {
  if ((rb_current_vm()->running)) {
    do {
      const VALUE arg = (rb_id2sym(mid));
      VALUE recv_class = (klass);
      ID hook_id = (idMethod_added);
      if (((!(((VALUE)((klass)) & RUBY_IMMEDIATE_MASK) ||
              !!(((VALUE)((klass)) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
            (int)(((struct RBasic *)((klass)))->flags & RUBY_T_MASK) !=
                RUBY_T_NODE)
               ? (((struct RBasic *)(((klass))))->flags &
                  ((((VALUE)RUBY_FL_SINGLETON))))
               : 0)) {
        recv_class = rb_ivar_get((klass), id__attached__);
        hook_id = idSingleton_method_added;
      }
      rb_funcallv(recv_class, hook_id, 1, &arg);
    } while (0);
  }
}

rb_method_entry_t *rb_add_method(VALUE klass, ID mid, rb_method_type_t type,
                                 void *opts, rb_method_visibility_t visi) {
  rb_method_entry_t *me = rb_method_entry_make(klass, mid, klass, visi, type,
                                               ((void *)0), mid, opts);

  if (type != VM_METHOD_TYPE_UNDEF && type != VM_METHOD_TYPE_REFINED) {
    method_added(klass, mid);
  }

  return me;
}

void rb_add_method_iseq(VALUE klass, ID mid, const rb_iseq_t *iseq,
                        rb_cref_t *cref, rb_method_visibility_t visi) {
  struct {
    const rb_iseq_t *iseqptr;
    rb_cref_t *cref;
  } iseq_body;

  iseq_body.iseqptr = iseq;
  iseq_body.cref = cref;
  rb_add_method(klass, mid, VM_METHOD_TYPE_ISEQ, &iseq_body, visi);
}

static rb_method_entry_t *method_entry_set(VALUE klass, ID mid,
                                           const rb_method_entry_t *me,
                                           rb_method_visibility_t visi,
                                           VALUE defined_class) {
  rb_method_entry_t *newme =
      rb_method_entry_make(klass, mid, defined_class, visi, me->def->type,
                           method_definition_addref(me->def), 0, ((void *)0));
  method_added(klass, mid);
  return newme;
}

rb_method_entry_t *rb_method_entry_set(VALUE klass, ID mid,
                                       const rb_method_entry_t *me,
                                       rb_method_visibility_t visi) {
  return method_entry_set(klass, mid, me, visi, klass);
}

void rb_define_alloc_func(VALUE klass, VALUE (*func)(VALUE)) {
  (!((((RUBY_T_CLASS)) == RUBY_T_FIXNUM)
         ? (((int)(long)((VALUE)(klass))) & RUBY_FIXNUM_FLAG)
         : (((RUBY_T_CLASS)) == RUBY_T_TRUE)
               ? (((VALUE)(klass)) == ((VALUE)RUBY_Qtrue))
               : (((RUBY_T_CLASS)) == RUBY_T_FALSE)
                     ? (((VALUE)(klass)) == ((VALUE)RUBY_Qfalse))
                     : (((RUBY_T_CLASS)) == RUBY_T_NIL)
                           ? (((VALUE)(klass)) == ((VALUE)RUBY_Qnil))
                           : (((RUBY_T_CLASS)) == RUBY_T_UNDEF)
                                 ? (((VALUE)(klass)) == ((VALUE)RUBY_Qundef))
                                 : (((RUBY_T_CLASS)) == RUBY_T_SYMBOL)
                                       ? ((((VALUE)((VALUE)(klass)) &
                                            ~((~(VALUE)0)
                                              << RUBY_SPECIAL_SHIFT)) ==
                                           RUBY_SYMBOL_FLAG) ||
                                          (!(((VALUE)((VALUE)(klass)) &
                                              RUBY_IMMEDIATE_MASK) ||
                                             !!(((VALUE)((VALUE)(klass)) &
                                                 (VALUE) ~((VALUE)RUBY_Qnil)) ==
                                                0)) &&
                                           (int)(((struct RBasic *)((VALUE)(
                                                      klass)))
                                                     ->flags &
                                                 RUBY_T_MASK) ==
                                               (RUBY_T_SYMBOL)))
                                       : (((RUBY_T_CLASS)) == RUBY_T_FLOAT)
                                             ? (((((int)(long)((VALUE)(
                                                      klass))) &
                                                  RUBY_FLONUM_MASK) ==
                                                 RUBY_FLONUM_FLAG) ||
                                                (!(((VALUE)((VALUE)(klass)) &
                                                    RUBY_IMMEDIATE_MASK) ||
                                                   !!(((VALUE)((VALUE)(klass)) &
                                                       (VALUE) ~(
                                                           (VALUE)RUBY_Qnil)) ==
                                                      0)) &&
                                                 (int)(((struct RBasic *)((
                                                            VALUE)(klass)))
                                                           ->flags &
                                                       RUBY_T_MASK) ==
                                                     RUBY_T_FLOAT))
                                             : (!(((VALUE)((VALUE)(klass)) &
                                                   RUBY_IMMEDIATE_MASK) ||
                                                  !!(((VALUE)((VALUE)(klass)) &
                                                      (VALUE) ~(
                                                          (VALUE)RUBY_Qnil)) ==
                                                     0)) &&
                                                (int)(((struct RBasic *)((
                                                           VALUE)(klass)))
                                                          ->flags &
                                                      RUBY_T_MASK) ==
                                                    ((RUBY_T_CLASS)))) ||
           ((RUBY_T_CLASS) == RUBY_T_DATA &&
            (((struct RTypedData *)(klass))->typed_flag == 1))
       ? rb_unexpected_type((VALUE)(klass), (RUBY_T_CLASS))
       : (void)0);
  (((struct RClass *)(klass))->ptr)->allocator = func;
}

void rb_undef_alloc_func(VALUE klass) {
  rb_define_alloc_func(klass, ((rb_alloc_func_t)-1));
}

rb_alloc_func_t rb_get_alloc_func(VALUE klass) {
  (!((((RUBY_T_CLASS)) == RUBY_T_FIXNUM)
         ? (((int)(long)((VALUE)(klass))) & RUBY_FIXNUM_FLAG)
         : (((RUBY_T_CLASS)) == RUBY_T_TRUE)
               ? (((VALUE)(klass)) == ((VALUE)RUBY_Qtrue))
               : (((RUBY_T_CLASS)) == RUBY_T_FALSE)
                     ? (((VALUE)(klass)) == ((VALUE)RUBY_Qfalse))
                     : (((RUBY_T_CLASS)) == RUBY_T_NIL)
                           ? (((VALUE)(klass)) == ((VALUE)RUBY_Qnil))
                           : (((RUBY_T_CLASS)) == RUBY_T_UNDEF)
                                 ? (((VALUE)(klass)) == ((VALUE)RUBY_Qundef))
                                 : (((RUBY_T_CLASS)) == RUBY_T_SYMBOL)
                                       ? ((((VALUE)((VALUE)(klass)) &
                                            ~((~(VALUE)0)
                                              << RUBY_SPECIAL_SHIFT)) ==
                                           RUBY_SYMBOL_FLAG) ||
                                          (!(((VALUE)((VALUE)(klass)) &
                                              RUBY_IMMEDIATE_MASK) ||
                                             !!(((VALUE)((VALUE)(klass)) &
                                                 (VALUE) ~((VALUE)RUBY_Qnil)) ==
                                                0)) &&
                                           (int)(((struct RBasic *)((VALUE)(
                                                      klass)))
                                                     ->flags &
                                                 RUBY_T_MASK) ==
                                               (RUBY_T_SYMBOL)))
                                       : (((RUBY_T_CLASS)) == RUBY_T_FLOAT)
                                             ? (((((int)(long)((VALUE)(
                                                      klass))) &
                                                  RUBY_FLONUM_MASK) ==
                                                 RUBY_FLONUM_FLAG) ||
                                                (!(((VALUE)((VALUE)(klass)) &
                                                    RUBY_IMMEDIATE_MASK) ||
                                                   !!(((VALUE)((VALUE)(klass)) &
                                                       (VALUE) ~(
                                                           (VALUE)RUBY_Qnil)) ==
                                                      0)) &&
                                                 (int)(((struct RBasic *)((
                                                            VALUE)(klass)))
                                                           ->flags &
                                                       RUBY_T_MASK) ==
                                                     RUBY_T_FLOAT))
                                             : (!(((VALUE)((VALUE)(klass)) &
                                                   RUBY_IMMEDIATE_MASK) ||
                                                  !!(((VALUE)((VALUE)(klass)) &
                                                      (VALUE) ~(
                                                          (VALUE)RUBY_Qnil)) ==
                                                     0)) &&
                                                (int)(((struct RBasic *)((
                                                           VALUE)(klass)))
                                                          ->flags &
                                                      RUBY_T_MASK) ==
                                                    ((RUBY_T_CLASS)))) ||
           ((RUBY_T_CLASS) == RUBY_T_DATA &&
            (((struct RTypedData *)(klass))->typed_flag == 1))
       ? rb_unexpected_type((VALUE)(klass), (RUBY_T_CLASS))
       : (void)0);

  for (; klass; klass = RCLASS_SUPER(klass)) {
    rb_alloc_func_t allocator = (((struct RClass *)(klass))->ptr)->allocator;
    if (allocator == ((rb_alloc_func_t)-1))
      break;
    if (allocator)
      return allocator;
  }
  return 0;
}

static inline rb_method_entry_t *search_method(VALUE klass, ID id,
                                               VALUE *defined_class_ptr) {
  rb_method_entry_t *me;

  for (; klass; klass = RCLASS_SUPER(klass)) {
    ((void)0);
    if ((me = lookup_method_table(klass, id)) != 0)
      break;
  }

  if (defined_class_ptr)
    *defined_class_ptr = klass;
  return me;
}

const rb_method_entry_t *rb_method_entry_at(VALUE klass, ID id) {
  return lookup_method_table(klass, id);
}

static rb_method_entry_t *
method_entry_get_without_cache(VALUE klass, ID id, VALUE *defined_class_ptr) {
  VALUE defined_class;
  rb_method_entry_t *me = search_method(klass, id, &defined_class);

  if ((rb_current_vm()->running)) {
    if (1) {
      struct cache_entry *ent;
      ent = (global_method_cache.entries +
             ((((klass) >> 3) ^ (id)) & (global_method_cache.mask)));
      ent->class_serial = ((((struct RClass *)(klass))->ptr)->class_serial);
      ent->method_state = (ruby_vm_global_method_state);
      ent->defined_class = defined_class;
      ent->mid = id;

      if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF)) {
        me = ent->me = ((void *)0);
      } else {
        ent->me = me;
      }
    } else if ((!(me) || !(me)->def ||
                (me)->def->type == VM_METHOD_TYPE_UNDEF)) {
      me = ((void *)0);
    }
  } else if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF)) {
    me = ((void *)0);
  }

  if (defined_class_ptr)
    *defined_class_ptr = defined_class;
  return me;
}
# 796 "./vm_method.c"
static rb_method_entry_t *method_entry_get(VALUE klass, ID id,
                                           VALUE *defined_class_ptr) {

  struct cache_entry *ent;
  ent = (global_method_cache.entries +
         ((((klass) >> 3) ^ (id)) & (global_method_cache.mask)));
  if (ent->method_state == (ruby_vm_global_method_state) &&
      ent->class_serial == ((((struct RClass *)(klass))->ptr)->class_serial) &&
      ent->mid == id) {

    if (defined_class_ptr)
      *defined_class_ptr = ent->defined_class;
    ((void)0);
    return ent->me;
  }

  ((void)0);
  return method_entry_get_without_cache(klass, id, defined_class_ptr);
}

__attribute__((__visibility__("default"))) extern const rb_method_entry_t *
rb_method_entry(VALUE klass, ID id) {
  return method_entry_get(klass, id, ((void *)0));
}

static const rb_callable_method_entry_t *
prepare_callable_method_entry(VALUE defined_class, ID id,
                              const rb_method_entry_t *me) {
  struct rb_id_table *mtbl;
  const rb_callable_method_entry_t *cme;

  if (me && me->defined_class == 0) {
    ((void)0);
    ((void)0);
    ((void)0);

    mtbl = ((((struct RClass *)(defined_class))->ptr)->callable_m_tbl);

    if (mtbl && rb_id_table_lookup(mtbl, id, (VALUE *)&me)) {
      ((void)0);
      cme = (rb_callable_method_entry_t *)me;
      ((void)0);
    } else {
      if (!mtbl) {
        mtbl = (((struct RClass *)(defined_class))->ptr)->callable_m_tbl =
            rb_id_table_create(0);
      }
      cme = rb_method_entry_complement_defined_class(me, me->called_id,
                                                     defined_class);
      rb_id_table_insert(mtbl, id, (VALUE)cme);
      ((void)0);
    }
  } else {
    cme = (const rb_callable_method_entry_t *)me;
    ((void)0);
  }

  return cme;
}

__attribute__((
    __visibility__("default"))) extern const rb_callable_method_entry_t *
rb_callable_method_entry(VALUE klass, ID id) {
  VALUE defined_class;
  rb_method_entry_t *me = method_entry_get(klass, id, &defined_class);
  return prepare_callable_method_entry(defined_class, id, me);
}

static const rb_method_entry_t *
resolve_refined_method(VALUE refinements, const rb_method_entry_t *me,
                       VALUE *defined_class_ptr);

static const rb_method_entry_t *
method_entry_resolve_refinement(VALUE klass, ID id, int with_refinement,
                                VALUE *defined_class_ptr) {
  const rb_method_entry_t *me = method_entry_get(klass, id, defined_class_ptr);

  if (me) {
    if (me->def->type == VM_METHOD_TYPE_REFINED) {
      if (with_refinement) {
        const rb_cref_t *cref = rb_vm_cref();
        VALUE refinements = cref ? CREF_REFINEMENTS(cref) : ((VALUE)RUBY_Qnil);
        me = resolve_refined_method(refinements, me, defined_class_ptr);
      } else {
        me = resolve_refined_method(((VALUE)RUBY_Qnil), me, defined_class_ptr);
      }

      if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF))
        me = ((void *)0);
    }
  }

  return me;
}

__attribute__((
    __visibility__("default"))) extern const rb_callable_method_entry_t *
rb_callable_method_entry_with_refinements(VALUE klass, ID id,
                                          VALUE *defined_class_ptr) {
  VALUE defined_class,
      *dcp = defined_class_ptr ? defined_class_ptr : &defined_class;
  const rb_method_entry_t *me =
      method_entry_resolve_refinement(klass, id, 1, dcp);
  return prepare_callable_method_entry(*dcp, id, me);
}

const rb_method_entry_t *
rb_method_entry_without_refinements(VALUE klass, ID id,
                                    VALUE *defined_class_ptr) {
  return method_entry_resolve_refinement(klass, id, 0, defined_class_ptr);
}

__attribute__((
    __visibility__("default"))) extern const rb_callable_method_entry_t *
rb_callable_method_entry_without_refinements(VALUE klass, ID id,
                                             VALUE *defined_class_ptr) {
  VALUE defined_class,
      *dcp = defined_class_ptr ? defined_class_ptr : &defined_class;
  const rb_method_entry_t *me =
      method_entry_resolve_refinement(klass, id, 0, dcp);
  return prepare_callable_method_entry(*dcp, id, me);
}

static const rb_method_entry_t *refined_method_original_method_entry(
    VALUE refinements, const rb_method_entry_t *me, VALUE *defined_class_ptr) {
  VALUE super;

  if (me->def->body.refined.orig_me) {
    if (defined_class_ptr)
      *defined_class_ptr = me->def->body.refined.orig_me->defined_class;
    return me->def->body.refined.orig_me;
  } else if (!(super = RCLASS_SUPER(me->owner))) {
    return 0;
  } else {
    rb_method_entry_t *tmp_me;
    tmp_me = method_entry_get(super, me->called_id, defined_class_ptr);
    return resolve_refined_method(refinements, tmp_me, defined_class_ptr);
  }
}

static const rb_method_entry_t *
resolve_refined_method(VALUE refinements, const rb_method_entry_t *me,
                       VALUE *defined_class_ptr) {
  if (me && me->def->type == VM_METHOD_TYPE_REFINED) {
    VALUE refinement;
    rb_method_entry_t *tmp_me;

    refinement = find_refinement(refinements, me->owner);
    if (!((VALUE)(refinement) != ((VALUE)RUBY_Qnil))) {
      return refined_method_original_method_entry(refinements, me,
                                                  defined_class_ptr);
    } else {
      tmp_me = method_entry_get(refinement, me->called_id, defined_class_ptr);

      if (tmp_me && tmp_me->def->type != VM_METHOD_TYPE_REFINED) {
        return tmp_me;
      } else {
        return refined_method_original_method_entry(refinements, me,
                                                    defined_class_ptr);
      }
    }
  } else {
    return me;
  }
}

const rb_method_entry_t *
rb_resolve_refined_method(VALUE refinements, const rb_method_entry_t *me) {
  return resolve_refined_method(refinements, me, ((void *)0));
}

static const rb_callable_method_entry_t *
rb_resolve_refined_method_callable(VALUE refinements,
                                   const rb_callable_method_entry_t *me) {
  VALUE defined_class = me->defined_class;
  const rb_method_entry_t *resolved_me = resolve_refined_method(
      refinements, (const rb_method_entry_t *)me, &defined_class);

  if (resolved_me && resolved_me->defined_class == 0) {
    return rb_method_entry_complement_defined_class(resolved_me, me->called_id,
                                                    defined_class);
  } else {
    return (const rb_callable_method_entry_t *)resolved_me;
  }
}

static void remove_method(VALUE klass, ID mid) {
  VALUE data;
  rb_method_entry_t *me = 0;
  VALUE self = klass;

  klass = ((((struct RClass *)(klass))->ptr)->origin_);
  rb_class_modify_check(klass);
  if (mid == idObject_id || mid == id__send__ || mid == idInitialize) {
    rb_warn("removing `%s' may cause serious problems", rb_id2name(mid));
  }

  if (!rb_id_table_lookup((((struct RClass *)(klass))->m_tbl), mid, &data) ||
      !(me = (rb_method_entry_t *)data) ||
      (!me->def || me->def->type == VM_METHOD_TYPE_UNDEF) ||
      ((me->def)->type == VM_METHOD_TYPE_REFINED &&
       (!((me->def)->body.refined.orig_me) ||
        !((me->def)->body.refined.orig_me)->def ||
        ((me->def)->body.refined.orig_me)->def->type ==
            VM_METHOD_TYPE_UNDEF))) {
    rb_exc_raise(rb_name_err_new(
        __extension__({
          (__builtin_constant_p("method `%1$s' not defined in %2$s"))
              ? rb_fstring_new(
                    ("method `%1$s' not defined in %2$s"),
                    (long)strlen("method `%1$s' not defined in %2$s"))
              : rb_fstring_cstr("method `%1$s' not defined in %2$s");
        }),
        (klass), ((rb_id2sym(mid)))));
  }

  rb_id_table_delete((((struct RClass *)(klass))->m_tbl), mid);

  rb_vm_check_redefinition_opt_method(me, klass);
  rb_clear_method_cache_by_class(klass);

  if (me->def->type == VM_METHOD_TYPE_REFINED) {
    rb_add_refined_method_entry(klass, mid);
  }

  do {
    const VALUE arg = (rb_id2sym(mid));
    VALUE recv_class = (self);
    ID hook_id = (idMethod_removed);
    if (((!(((VALUE)((self)) & RUBY_IMMEDIATE_MASK) ||
            !!(((VALUE)((self)) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
          (int)(((struct RBasic *)((self)))->flags & RUBY_T_MASK) !=
              RUBY_T_NODE)
             ? (((struct RBasic *)(((self))))->flags &
                ((((VALUE)RUBY_FL_SINGLETON))))
             : 0)) {
      recv_class = rb_ivar_get((self), id__attached__);
      hook_id = idSingleton_method_removed;
    }
    rb_funcallv(recv_class, hook_id, 1, &arg);
  } while (0);
}

void rb_remove_method_id(VALUE klass, ID mid) { remove_method(klass, mid); }

void rb_remove_method(VALUE klass, const char *name) {
  remove_method(klass, (__builtin_constant_p(name) ? __extension__({
                  static ID rb_intern_id_cache;
                  if (!rb_intern_id_cache)
                    rb_intern_id_cache =
                        rb_intern2(((name)), (long)strlen((name)));
                  (ID) rb_intern_id_cache;
                })
                                                   : rb_intern(name)));
}
# 1035 "./vm_method.c"
static VALUE rb_mod_remove_method(int argc, VALUE *argv, VALUE mod) {
  int i;

  for (i = 0; i < argc; i++) {
    VALUE v = argv[i];
    ID id = rb_check_id(&v);
    if (!id) {
      rb_exc_raise(rb_name_err_new(
          __extension__({
            (__builtin_constant_p("method `%1$s' not defined in %2$s"))
                ? rb_fstring_new(
                      ("method `%1$s' not defined in %2$s"),
                      (long)strlen("method `%1$s' not defined in %2$s"))
                : rb_fstring_cstr("method `%1$s' not defined in %2$s");
          }),
          (mod), (v)));
    }
    remove_method(mod, id);
  }
  return mod;
}

static void rb_export_method(VALUE klass, ID name,
                             rb_method_visibility_t visi) {
  rb_method_entry_t *me;
  VALUE defined_class;
  VALUE origin_class = ((((struct RClass *)(klass))->ptr)->origin_);

  me = search_method(origin_class, name, &defined_class);
  if (!me &&
      (((RUBY_T_MODULE) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_MODULE) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_MODULE)))) {
    me = search_method(rb_cObject, name, &defined_class);
  }

  if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF) ||
      ((me->def)->type == VM_METHOD_TYPE_REFINED &&
       (!((me->def)->body.refined.orig_me) ||
        !((me->def)->body.refined.orig_me)->def ||
        ((me->def)->body.refined.orig_me)->def->type ==
            VM_METHOD_TYPE_UNDEF))) {
    rb_print_undef(klass, name, METHOD_VISI_UNDEF);
  }

  if ((rb_method_visibility_t)(
          ((me)->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
          ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)) != visi) {
    rb_vm_check_redefinition_opt_method(me, klass);

    if (klass == defined_class || origin_class == defined_class) {
      METHOD_ENTRY_VISI_SET(me, visi);

      if (me->def->type == VM_METHOD_TYPE_REFINED &&
          me->def->body.refined.orig_me) {
        METHOD_ENTRY_VISI_SET(
            (rb_method_entry_t *)me->def->body.refined.orig_me, visi);
      }
      rb_clear_method_cache_by_class(klass);
    } else {
      rb_add_method(klass, name, VM_METHOD_TYPE_ZSUPER, 0, visi);
    }
  }
}

int rb_method_boundp(VALUE klass, ID id, int ex) {
  const rb_method_entry_t *me =
      rb_method_entry_without_refinements(klass, id, ((void *)0));

  if (me != 0) {
    if ((ex & ~0x02) &&
        (((rb_method_visibility_t)(((me)->flags & (((VALUE)RUBY_FL_USER4) |
                                                   ((VALUE)RUBY_FL_USER5))) >>
                                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)) ==
          METHOD_VISI_PRIVATE) ||
         ((ex & 0x02) &&
          ((rb_method_visibility_t)(((me)->flags & (((VALUE)RUBY_FL_USER4) |
                                                    ((VALUE)RUBY_FL_USER5))) >>
                                    ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)) ==
           METHOD_VISI_PROTECTED)))) {
      return 0;
    }

    if (me->def->type == VM_METHOD_TYPE_NOTIMPLEMENTED) {
      if (ex & 0x02)
        return 2;
      return 0;
    }
    return 1;
  }
  return 0;
}

static rb_method_visibility_t rb_scope_visibility_get(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (!vm_env_cref_by_cref(cfp->ep)) {
    return METHOD_VISI_PUBLIC;
  } else {
    return CREF_SCOPE_VISI(rb_vm_cref())->method_visi;
  }
}

static int rb_scope_module_func_check(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (!vm_env_cref_by_cref(cfp->ep)) {
    return 0;
  } else {
    return CREF_SCOPE_VISI(rb_vm_cref())->module_func;
  }
}

static void vm_cref_set_visibility(rb_method_visibility_t method_visi,
                                   int module_func) {
  rb_scope_visibility_t *scope_visi =
      (rb_scope_visibility_t *)&rb_vm_cref()->scope_visi;
  scope_visi->method_visi = method_visi;
  scope_visi->module_func = module_func;
}

void rb_scope_visibility_set(rb_method_visibility_t visi) {
  vm_cref_set_visibility(visi, 0);
}

static void rb_scope_module_func_set(void) {
  vm_cref_set_visibility(METHOD_VISI_PRIVATE, 1);
}

void rb_attr(VALUE klass, ID id, int read, int write, int ex) {
  ID attriv;
  rb_method_visibility_t visi;

  if (!ex) {
    visi = METHOD_VISI_PUBLIC;
  } else {
    switch (rb_scope_visibility_get()) {
    case METHOD_VISI_PRIVATE:
      if (rb_scope_module_func_check()) {
        rb_warning("attribute accessor as module_function");
      }
      visi = METHOD_VISI_PRIVATE;
      break;
    case METHOD_VISI_PROTECTED:
      visi = METHOD_VISI_PROTECTED;
      break;
    default:
      visi = METHOD_VISI_PUBLIC;
      break;
    }
  }

  attriv = rb_intern_str(rb_sprintf("@%"
                                    "l"
                                    "i"
                                    "\v",
                                    rb_id2str(id)));
  if (read) {
    rb_add_method(klass, id, VM_METHOD_TYPE_IVAR, (void *)attriv, visi);
  }
  if (write) {
    rb_add_method(klass, rb_id_attrset(id), VM_METHOD_TYPE_ATTRSET,
                  (void *)attriv, visi);
  }
}

void rb_undef(VALUE klass, ID id) {
  const rb_method_entry_t *me;

  if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eTypeError, "no class to undef method");
  }
  rb_class_modify_check(klass);
  if (id == idObject_id || id == id__send__ || id == idInitialize) {
    rb_warn("undefining `%s' may cause serious problems", rb_id2name(id));
  }

  me = search_method(klass, id, 0);
  if (me && me->def->type == VM_METHOD_TYPE_REFINED) {
    me = rb_resolve_refined_method(((VALUE)RUBY_Qnil), me);
  }

  if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF) ||
      ((me->def)->type == VM_METHOD_TYPE_REFINED &&
       (!((me->def)->body.refined.orig_me) ||
        !((me->def)->body.refined.orig_me)->def ||
        ((me->def)->body.refined.orig_me)->def->type ==
            VM_METHOD_TYPE_UNDEF))) {
    rb_method_name_error(klass, rb_id2str(id));
  }

  rb_add_method(klass, id, VM_METHOD_TYPE_UNDEF, 0, METHOD_VISI_PUBLIC);

  do {
    const VALUE arg = (rb_id2sym(id));
    VALUE recv_class = (klass);
    ID hook_id = (idMethod_undefined);
    if (((!(((VALUE)((klass)) & RUBY_IMMEDIATE_MASK) ||
            !!(((VALUE)((klass)) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
          (int)(((struct RBasic *)((klass)))->flags & RUBY_T_MASK) !=
              RUBY_T_NODE)
             ? (((struct RBasic *)(((klass))))->flags &
                ((((VALUE)RUBY_FL_SINGLETON))))
             : 0)) {
      recv_class = rb_ivar_get((klass), id__attached__);
      hook_id = idSingleton_method_undefined;
    }
    rb_funcallv(recv_class, hook_id, 1, &arg);
  } while (0);
}
# 1266 "./vm_method.c"
static VALUE rb_mod_undef_method(int argc, VALUE *argv, VALUE mod) {
  int i;
  for (i = 0; i < argc; i++) {
    VALUE v = argv[i];
    ID id = rb_check_id(&v);
    if (!id) {
      rb_method_name_error(mod, v);
    }
    rb_undef(mod, id);
  }
  return mod;
}

static rb_method_visibility_t check_definition_visibility(VALUE mod, int argc,
                                                          VALUE *argv) {
  const rb_method_entry_t *me;
  VALUE mid, include_super, lookup_mod = mod;
  int inc_super;
  ID id;

  __builtin_choose_expr(
      __builtin_constant_p("11"),
      rb_scan_args_set(
          argc, argv, rb_scan_args_n_lead("11"), rb_scan_args_n_opt("11"),
          rb_scan_args_n_trail("11"), rb_scan_args_f_var("11"),
          rb_scan_args_f_hash("11"), rb_scan_args_f_block("11"),
          (0, ((VALUE *[]){&mid, &include_super})), (char *)"11",
          (sizeof((VALUE *[]){&mid, &include_super}) / sizeof(VALUE *))),
      rb_scan_args(argc, argv, "11", &mid, &include_super));
  id = rb_check_id(&mid);
  if (!id)
    return METHOD_VISI_UNDEF;

  if (argc == 1) {
    inc_super = 1;
  } else {
    inc_super = !(((VALUE)(include_super) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0);
    if (!inc_super) {
      lookup_mod = ((((struct RClass *)(mod))->ptr)->origin_);
    }
  }

  me = rb_method_entry_without_refinements(lookup_mod, id, ((void *)0));
  if (me) {
    if (me->def->type == VM_METHOD_TYPE_NOTIMPLEMENTED)
      return METHOD_VISI_UNDEF;
    if (!inc_super && me->owner != mod)
      return METHOD_VISI_UNDEF;
    return (rb_method_visibility_t)(
        ((me)->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
        ((((VALUE)RUBY_FL_USHIFT) + 4) + 0));
  }
  return METHOD_VISI_UNDEF;
}
# 1347 "./vm_method.c"
static VALUE rb_mod_method_defined(int argc, VALUE *argv, VALUE mod) {
  rb_method_visibility_t visi = check_definition_visibility(mod, argc, argv);
  return (visi == METHOD_VISI_PUBLIC || visi == METHOD_VISI_PROTECTED)
             ? ((VALUE)RUBY_Qtrue)
             : ((VALUE)RUBY_Qfalse);
}

static VALUE check_definition(VALUE mod, int argc, VALUE *argv,
                              rb_method_visibility_t visi) {
  return (check_definition_visibility(mod, argc, argv) == visi)
             ? ((VALUE)RUBY_Qtrue)
             : ((VALUE)RUBY_Qfalse);
}
# 1390 "./vm_method.c"
static VALUE rb_mod_public_method_defined(int argc, VALUE *argv, VALUE mod) {
  return check_definition(mod, argc, argv, METHOD_VISI_PUBLIC);
}
# 1426 "./vm_method.c"
static VALUE rb_mod_private_method_defined(int argc, VALUE *argv, VALUE mod) {
  return check_definition(mod, argc, argv, METHOD_VISI_PRIVATE);
}
# 1462 "./vm_method.c"
static VALUE rb_mod_protected_method_defined(int argc, VALUE *argv, VALUE mod) {
  return check_definition(mod, argc, argv, METHOD_VISI_PROTECTED);
}

int rb_method_entry_eq(const rb_method_entry_t *m1,
                       const rb_method_entry_t *m2) {
  return rb_method_definition_eq(m1->def, m2->def);
}

static const rb_method_definition_t *
original_method_definition(const rb_method_definition_t *def) {
again:
  if (def) {
    switch (def->type) {
    case VM_METHOD_TYPE_REFINED:
      if (def->body.refined.orig_me) {
        def = def->body.refined.orig_me->def;
        goto again;
      }
      break;
    case VM_METHOD_TYPE_ALIAS:
      def = def->body.alias.original_me->def;
      goto again;
    default:
      break;
    }
  }
  return def;
}

__attribute__((__visibility__("default"))) extern int
rb_method_definition_eq(const rb_method_definition_t *d1,
                        const rb_method_definition_t *d2) {
  d1 = original_method_definition(d1);
  d2 = original_method_definition(d2);

  if (d1 == d2)
    return 1;
  if (!d1 || !d2)
    return 0;
  if (d1->type != d2->type)
    return 0;

  switch (d1->type) {
  case VM_METHOD_TYPE_ISEQ:
    return d1->body.iseq.iseqptr == d2->body.iseq.iseqptr;
  case VM_METHOD_TYPE_CFUNC:
    return d1->body.cfunc.func == d2->body.cfunc.func &&
           d1->body.cfunc.argc == d2->body.cfunc.argc;
  case VM_METHOD_TYPE_ATTRSET:
  case VM_METHOD_TYPE_IVAR:
    return d1->body.attr.id == d2->body.attr.id;
  case VM_METHOD_TYPE_BMETHOD:
    return !(((VALUE)(rb_equal(d1->body.proc, d2->body.proc)) &
              (VALUE) ~((VALUE)RUBY_Qnil)) == 0);
  case VM_METHOD_TYPE_MISSING:
    return d1->original_id == d2->original_id;
  case VM_METHOD_TYPE_ZSUPER:
  case VM_METHOD_TYPE_NOTIMPLEMENTED:
  case VM_METHOD_TYPE_UNDEF:
    return 1;
  case VM_METHOD_TYPE_OPTIMIZED:
    return d1->body.optimize_type == d2->body.optimize_type;
  case VM_METHOD_TYPE_REFINED:
  case VM_METHOD_TYPE_ALIAS:
    break;
  }
  rb_bug("rb_method_definition_eq: unsupported type: %d\n", d1->type);
}

static st_index_t rb_hash_method_definition(st_index_t hash,
                                            const rb_method_definition_t *def) {
  hash = st_hash_uint((hash), (def->type));
  def = original_method_definition(def);

  if (!def)
    return hash;

  switch (def->type) {
  case VM_METHOD_TYPE_ISEQ:
    return st_hash_uint((hash), ((st_index_t)def->body.iseq.iseqptr));
  case VM_METHOD_TYPE_CFUNC:
    hash = st_hash_uint((hash), ((st_index_t)def->body.cfunc.func));
    return st_hash_uint((hash), (def->body.cfunc.argc));
  case VM_METHOD_TYPE_ATTRSET:
  case VM_METHOD_TYPE_IVAR:
    return st_hash_uint((hash), (def->body.attr.id));
  case VM_METHOD_TYPE_BMETHOD:
    return rb_hash_proc(hash, def->body.proc);
  case VM_METHOD_TYPE_MISSING:
    return st_hash_uint((hash), (def->original_id));
  case VM_METHOD_TYPE_ZSUPER:
  case VM_METHOD_TYPE_NOTIMPLEMENTED:
  case VM_METHOD_TYPE_UNDEF:
    return hash;
  case VM_METHOD_TYPE_OPTIMIZED:
    return st_hash_uint((hash), (def->body.optimize_type));
  case VM_METHOD_TYPE_REFINED:
  case VM_METHOD_TYPE_ALIAS:
    break;
  }
  rb_bug("rb_hash_method_definition: unsupported method type (%d)\n",
         def->type);
}

st_index_t rb_hash_method_entry(st_index_t hash, const rb_method_entry_t *me) {
  return rb_hash_method_definition(hash, me->def);
}

void rb_alias(VALUE klass, ID alias_name, ID original_name) {
  const VALUE target_klass = klass;
  VALUE defined_class;
  const rb_method_entry_t *orig_me;
  rb_method_visibility_t visi = METHOD_VISI_UNDEF;

  if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eTypeError, "no class to make alias");
  }

  rb_class_modify_check(klass);

again:
  orig_me = search_method(klass, original_name, &defined_class);
  if (orig_me && orig_me->def->type == VM_METHOD_TYPE_REFINED) {
    orig_me = rb_resolve_refined_method(((VALUE)RUBY_Qnil), orig_me);
  }

  if ((!(orig_me) || !(orig_me)->def ||
       (orig_me)->def->type == VM_METHOD_TYPE_UNDEF) ||
      ((orig_me->def)->type == VM_METHOD_TYPE_REFINED &&
       (!((orig_me->def)->body.refined.orig_me) ||
        !((orig_me->def)->body.refined.orig_me)->def ||
        ((orig_me->def)->body.refined.orig_me)->def->type ==
            VM_METHOD_TYPE_UNDEF))) {
    if ((!(((RUBY_T_MODULE) == RUBY_T_FIXNUM)
               ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
               : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                     ? ((klass) == ((VALUE)RUBY_Qtrue))
                     : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                           ? ((klass) == ((VALUE)RUBY_Qfalse))
                           : ((RUBY_T_MODULE) == RUBY_T_NIL)
                                 ? ((klass) == ((VALUE)RUBY_Qnil))
                                 : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                       ? ((klass) == ((VALUE)RUBY_Qundef))
                                       : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                             ? ((((VALUE)(klass) &
                                                  ~((~(VALUE)0)
                                                    << RUBY_SPECIAL_SHIFT)) ==
                                                 RUBY_SYMBOL_FLAG) ||
                                                (!(((VALUE)(
                                                       klass)&RUBY_IMMEDIATE_MASK) ||
                                                   !!(((VALUE)(klass) &
                                                       (VALUE) ~(
                                                           (VALUE)RUBY_Qnil)) ==
                                                      0)) &&
                                                 (int)(((struct RBasic
                                                             *)(klass))
                                                           ->flags &
                                                       RUBY_T_MASK) ==
                                                     (RUBY_T_SYMBOL)))
                                             : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                                   ? (((((int)(long)(klass)) &
                                                        RUBY_FLONUM_MASK) ==
                                                       RUBY_FLONUM_FLAG) ||
                                                      (!(((VALUE)(
                                                             klass)&RUBY_IMMEDIATE_MASK) ||
                                                         !!(((VALUE)(klass) &
                                                             (VALUE) ~(
                                                                 (VALUE)
                                                                     RUBY_Qnil)) ==
                                                            0)) &&
                                                       (int)(((struct RBasic
                                                                   *)(klass))
                                                                 ->flags &
                                                             RUBY_T_MASK) ==
                                                           RUBY_T_FLOAT))
                                                   : (!(((VALUE)(
                                                            klass)&RUBY_IMMEDIATE_MASK) ||
                                                        !!(((VALUE)(klass) &
                                                            (VALUE) ~(
                                                                (VALUE)
                                                                    RUBY_Qnil)) ==
                                                           0)) &&
                                                      (int)(((struct RBasic
                                                                  *)(klass))
                                                                ->flags &
                                                            RUBY_T_MASK) ==
                                                          (RUBY_T_MODULE)))) ||
        (orig_me = search_method(rb_cObject, original_name, &defined_class),
         (!(orig_me) || !(orig_me)->def ||
          (orig_me)->def->type == VM_METHOD_TYPE_UNDEF))) {
      rb_print_undef(klass, original_name, METHOD_VISI_UNDEF);
    }
  }

  if (orig_me->def->type == VM_METHOD_TYPE_ZSUPER) {
    klass = RCLASS_SUPER(klass);
    original_name = orig_me->def->original_id;
    visi = (rb_method_visibility_t)(
        ((orig_me)->flags &
         (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
        ((((VALUE)RUBY_FL_USHIFT) + 4) + 0));
    goto again;
  }

  if (visi == METHOD_VISI_UNDEF)
    visi = (rb_method_visibility_t)(
        ((orig_me)->flags &
         (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
        ((((VALUE)RUBY_FL_USHIFT) + 4) + 0));

  if (orig_me->defined_class == 0) {
    rb_method_entry_make(target_klass, alias_name, target_klass, visi,
                         VM_METHOD_TYPE_ALIAS, ((void *)0), orig_me->called_id,
                         (void *)rb_method_entry_clone(orig_me));
    method_added(target_klass, alias_name);
  } else {
    rb_method_entry_t *alias_me;

    alias_me = method_entry_set(target_klass, alias_name, orig_me, visi,
                                orig_me->owner);
    __extension__({
# 1621 "./vm_method.c"
#pragma clang diagnostic push
# 1621 "./vm_method.c"
      ;
# 1621 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 1621 "./vm_method.c"
      ;
      typeof(rb_obj_write((VALUE)(alias_me), (VALUE *)(&alias_me->owner),
                          (VALUE)(target_klass), "./vm_method.c", 1621))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(alias_me), (VALUE *)(&alias_me->owner),
                            (VALUE)(target_klass), "./vm_method.c", 1621));
# 1621 "./vm_method.c"
#pragma clang diagnostic pop
# 1621 "./vm_method.c"
      ;
      unaligned_member_access_result;
    });
    __extension__({
# 1622 "./vm_method.c"
#pragma clang diagnostic push
# 1622 "./vm_method.c"
      ;
# 1622 "./vm_method.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 1622 "./vm_method.c"
      ;
      typeof(rb_obj_write((VALUE)(alias_me),
                          (VALUE *)(&alias_me->defined_class),
                          (VALUE)(defined_class), "./vm_method.c",
                          1622)) unaligned_member_access_result =
          (rb_obj_write((VALUE)(alias_me), (VALUE *)(&alias_me->defined_class),
                        (VALUE)(defined_class), "./vm_method.c", 1622));
# 1622 "./vm_method.c"
#pragma clang diagnostic pop
# 1622 "./vm_method.c"
      ;
      unaligned_member_access_result;
    });
  }
}
# 1648 "./vm_method.c"
static VALUE rb_mod_alias_method(VALUE mod, VALUE newname, VALUE oldname) {
  ID oldid = rb_check_id(&oldname);
  if (!oldid) {
    rb_print_undef_str(mod, oldname);
  }
  rb_alias(mod, rb_to_id(newname), oldid);
  return mod;
}

static void set_method_visibility(VALUE self, int argc, const VALUE *argv,
                                  rb_method_visibility_t visi) {
  int i;

  __extension__({
    do {
      VALUE frozen_obj = (self);
      if ((__builtin_expect(
              !!((!(!(((VALUE)(frozen_obj)&RUBY_IMMEDIATE_MASK) ||
                      !!(((VALUE)(frozen_obj) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                         0)) &&
                    (int)(((struct RBasic *)(frozen_obj))->flags &
                          RUBY_T_MASK) != RUBY_T_NODE) ||
                  (((struct RBasic *)(frozen_obj))->flags & RUBY_FL_FREEZE))),
              0))) {
        rb_error_frozen_object(frozen_obj);
      }
    } while (0);
  });
  if (argc == 0) {
    rb_warning("%"
               "l"
               "i"
               "\v"
               " with no argument is just ignored",
               rb_id_quote_unprintable(rb_frame_callee()));
    return;
  }

  for (i = 0; i < argc; i++) {
    VALUE v = argv[i];
    ID id = rb_check_id(&v);
    if (!id) {
      rb_print_undef_str(self, v);
    }
    rb_export_method(self, id, visi);
  }
}

static VALUE set_visibility(int argc, const VALUE *argv, VALUE module,
                            rb_method_visibility_t visi) {
  if (argc == 0) {
    rb_scope_visibility_set(visi);
  } else {
    set_method_visibility(module, argc, argv, visi);
  }
  return module;
}
# 1705 "./vm_method.c"
static VALUE rb_mod_public(int argc, VALUE *argv, VALUE module) {
  return set_visibility(argc, argv, module, METHOD_VISI_PUBLIC);
}
# 1732 "./vm_method.c"
static VALUE rb_mod_protected(int argc, VALUE *argv, VALUE module) {
  return set_visibility(argc, argv, module, METHOD_VISI_PROTECTED);
}
# 1761 "./vm_method.c"
static VALUE rb_mod_private(int argc, VALUE *argv, VALUE module) {
  return set_visibility(argc, argv, module, METHOD_VISI_PRIVATE);
}
# 1777 "./vm_method.c"
static VALUE rb_mod_public_method(int argc, VALUE *argv, VALUE obj) {
  set_method_visibility(rb_singleton_class(obj), argc, argv,
                        METHOD_VISI_PUBLIC);
  return obj;
}
# 1803 "./vm_method.c"
static VALUE rb_mod_private_method(int argc, VALUE *argv, VALUE obj) {
  set_method_visibility(rb_singleton_class(obj), argc, argv,
                        METHOD_VISI_PRIVATE);
  return obj;
}
# 1823 "./vm_method.c"
static VALUE top_public(int argc, VALUE *argv) {
  return rb_mod_public(argc, argv, rb_cObject);
}
# 1841 "./vm_method.c"
static VALUE top_private(int argc, VALUE *argv) {
  return rb_mod_private(argc, argv, rb_cObject);
}
# 1885 "./vm_method.c"
static VALUE rb_mod_modfunc(int argc, VALUE *argv, VALUE module) {
  int i;
  ID id;
  const rb_method_entry_t *me;

  if (!(((RUBY_T_MODULE) == RUBY_T_FIXNUM)
            ? (((int)(long)(module)) & RUBY_FIXNUM_FLAG)
            : ((RUBY_T_MODULE) == RUBY_T_TRUE)
                  ? ((module) == ((VALUE)RUBY_Qtrue))
                  : ((RUBY_T_MODULE) == RUBY_T_FALSE)
                        ? ((module) == ((VALUE)RUBY_Qfalse))
                        : ((RUBY_T_MODULE) == RUBY_T_NIL)
                              ? ((module) == ((VALUE)RUBY_Qnil))
                              : ((RUBY_T_MODULE) == RUBY_T_UNDEF)
                                    ? ((module) == ((VALUE)RUBY_Qundef))
                                    : ((RUBY_T_MODULE) == RUBY_T_SYMBOL)
                                          ? ((((VALUE)(module) &
                                               ~((~(VALUE)0)
                                                 << RUBY_SPECIAL_SHIFT)) ==
                                              RUBY_SYMBOL_FLAG) ||
                                             (!(((VALUE)(
                                                    module)&RUBY_IMMEDIATE_MASK) ||
                                                !!(((VALUE)(module) &
                                                    (VALUE) ~(
                                                        (VALUE)RUBY_Qnil)) ==
                                                   0)) &&
                                              (int)(((struct RBasic *)(module))
                                                        ->flags &
                                                    RUBY_T_MASK) ==
                                                  (RUBY_T_SYMBOL)))
                                          : ((RUBY_T_MODULE) == RUBY_T_FLOAT)
                                                ? (((((int)(long)(module)) &
                                                     RUBY_FLONUM_MASK) ==
                                                    RUBY_FLONUM_FLAG) ||
                                                   (!(((VALUE)(
                                                          module)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(module) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(module))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        RUBY_T_FLOAT))
                                                : (!(((VALUE)(
                                                         module)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(module) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(module))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_MODULE)))) {
    rb_raise(rb_eTypeError, "module_function must be called for modules");
  }

  if (argc == 0) {
    rb_scope_module_func_set();
    return module;
  }

  set_method_visibility(module, argc, argv, METHOD_VISI_PRIVATE);

  for (i = 0; i < argc; i++) {
    VALUE m = module;

    id = rb_to_id(argv[i]);
    for (;;) {
      me = search_method(m, id, 0);
      if (me == 0) {
        me = search_method(rb_cObject, id, 0);
      }
      if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF)) {
        rb_print_undef(module, id, METHOD_VISI_UNDEF);
      }
      if (me->def->type != VM_METHOD_TYPE_ZSUPER) {
        break;
      }
      m = RCLASS_SUPER(m);
      if (!m)
        break;
    }
    rb_method_entry_set(rb_singleton_class(module), id, me, METHOD_VISI_PUBLIC);
  }
  return module;
}

int rb_method_basic_definition_p(VALUE klass, ID id) {
  const rb_method_entry_t *me;
  if (!klass)
    return 1;
  me = rb_method_entry(klass, id);
  return (me && (int)(((me)->flags & (((VALUE)RUBY_FL_USER6))) >>
                      ((((VALUE)RUBY_FL_USHIFT) + 4) + 2)))
             ? 1
             : 0;
}

static VALUE call_method_entry(rb_execution_context_t *ec, VALUE defined_class,
                               VALUE obj, ID id, const rb_method_entry_t *me,
                               int argc, const VALUE *argv) {
  const rb_callable_method_entry_t *cme =
      prepare_callable_method_entry(defined_class, id, me);
  VALUE passed_block_handler = vm_passed_block_handler(ec);
  VALUE result = rb_vm_call0(ec, obj, id, argc, argv, cme);
  vm_passed_block_handler_set(ec, passed_block_handler);
  return result;
}

static VALUE basic_obj_respond_to_missing(rb_execution_context_t *ec,
                                          VALUE klass, VALUE obj, VALUE mid,
                                          VALUE priv) {
  VALUE defined_class, args[2];
  const ID rtmid = idRespond_to_missing;
  const rb_method_entry_t *const me =
      method_entry_get(klass, rtmid, &defined_class);

  if (!me || (int)(((me)->flags & (((VALUE)RUBY_FL_USER6))) >>
                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 2)))
    return ((VALUE)RUBY_Qundef);
  args[0] = mid;
  args[1] = priv;
  return call_method_entry(ec, defined_class, obj, rtmid, me, 2, args);
}

static inline int basic_obj_respond_to(rb_execution_context_t *ec, VALUE obj,
                                       ID id, int pub) {
  VALUE klass = rb_class_of((VALUE)(obj));
  VALUE ret;

  switch (rb_method_boundp(klass, id, pub | 0x02)) {
  case 2:
    return 0;
  case 0:
    ret = basic_obj_respond_to_missing(ec, klass, obj, (rb_id2sym(id)),
                                       pub ? ((VALUE)RUBY_Qfalse)
                                           : ((VALUE)RUBY_Qtrue));
    return !(((VALUE)(ret) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0) &&
           ret != ((VALUE)RUBY_Qundef);
  default:
    return 1;
  }
}

static int vm_respond_to(rb_execution_context_t *ec, VALUE klass, VALUE obj,
                         ID id, int priv) {
  VALUE defined_class;
  const ID resid = idRespond_to;
  const rb_method_entry_t *const me =
      method_entry_get(klass, resid, &defined_class);

  if (!me)
    return -1;
  if ((int)(((me)->flags & (((VALUE)RUBY_FL_USER6))) >>
            ((((VALUE)RUBY_FL_USHIFT) + 4) + 2))) {
    return -1;
  } else {
    int argc = 1;
    VALUE args[2];
    VALUE result;

    args[0] = (rb_id2sym(id));
    args[1] = ((VALUE)RUBY_Qtrue);
    if (priv) {
      argc = rb_method_entry_arity(me);
      if (argc > 2) {
        rb_raise(rb_eArgError,
                 "respond_to? must accept 1 or 2 arguments (requires %d)",
                 argc);
      }
      if (argc != 1) {
        argc = 2;
      } else if (!!((VALUE)((*rb_ruby_verbose_ptr())) != ((VALUE)RUBY_Qnil))) {
        VALUE location = rb_method_entry_location(me);
        rb_warn("%"
                "l"
                "i"
                "\v"
                "%c"
                "respond_to?(:%"
                "l"
                "i"
                "\v"
                ") uses"
                " the deprecated method signature, which takes one parameter",
                (((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
                     !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
                   (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) !=
                       RUBY_T_NODE)
                      ? (((struct RBasic *)((klass)))->flags &
                         ((((VALUE)RUBY_FL_SINGLETON))))
                      : 0)
                     ? obj
                     : klass),
                (((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
                     !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
                   (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) !=
                       RUBY_T_NODE)
                      ? (((struct RBasic *)((klass)))->flags &
                         ((((VALUE)RUBY_FL_SINGLETON))))
                      : 0)
                     ? '.'
                     : '#'),
                rb_id_quote_unprintable(id));
        if (!!((VALUE)(location) != ((VALUE)RUBY_Qnil))) {
          VALUE path = (rb_array_const_ptr_transient(location)[0]);
          VALUE line = (rb_array_const_ptr_transient(location)[1]);
          if (!!((VALUE)(path) != ((VALUE)RUBY_Qnil))) {
            rb_compile_warn(
                (!(((struct RBasic *)(path))->flags & RSTRING_NOEMBED)
                     ? ((struct RString *)(path))->as.ary
                     : ((struct RString *)(path))->as.heap.ptr),
                rb_num2int_inline(line), "respond_to? is defined here");
          }
        }
      }
    }
    result = call_method_entry(ec, defined_class, obj, resid, me, argc, args);
    return !(((VALUE)(result) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0);
  }
}

int rb_obj_respond_to(VALUE obj, ID id, int priv) {
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE klass = rb_class_of((VALUE)(obj));
  int ret = vm_respond_to(ec, klass, obj, id, priv);
  if (ret == -1)
    ret = basic_obj_respond_to(ec, obj, id, !priv);
  return ret;
}

int rb_respond_to(VALUE obj, ID id) { return rb_obj_respond_to(obj, id, 0); }
# 2069 "./vm_method.c"
static VALUE obj_respond_to(int argc, VALUE *argv, VALUE obj) {
  VALUE mid, priv;
  ID id;
  rb_execution_context_t *ec = rb_current_execution_context();

  __builtin_choose_expr(
      __builtin_constant_p("11"),
      rb_scan_args_set(argc, argv, rb_scan_args_n_lead("11"),
                       rb_scan_args_n_opt("11"), rb_scan_args_n_trail("11"),
                       rb_scan_args_f_var("11"), rb_scan_args_f_hash("11"),
                       rb_scan_args_f_block("11"),
                       (0, ((VALUE *[]){&mid, &priv})), (char *)"11",
                       (sizeof((VALUE *[]){&mid, &priv}) / sizeof(VALUE *))),
      rb_scan_args(argc, argv, "11", &mid, &priv));
  if (!(id = rb_check_id(&mid))) {
    VALUE ret = basic_obj_respond_to_missing(ec, rb_class_of((VALUE)(obj)), obj,
                                             rb_to_symbol(mid), priv);
    if (ret == ((VALUE)RUBY_Qundef))
      ret = ((VALUE)RUBY_Qfalse);
    return ret;
  }
  if (basic_obj_respond_to(
          ec, obj, id, !!(((VALUE)(priv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)))
    return ((VALUE)RUBY_Qtrue);
  return ((VALUE)RUBY_Qfalse);
}
# 2103 "./vm_method.c"
static VALUE obj_respond_to_missing(VALUE obj, VALUE mid, VALUE priv) {
  return ((VALUE)RUBY_Qfalse);
}

void Init_Method(void) {

  char *ptr = getenv("RUBY_GLOBAL_METHOD_CACHE_SIZE");
  int val;

  if (ptr != ((void *)0) && (val = atoi(ptr)) > 0) {
    if ((val & (val - 1)) == 0) {
      global_method_cache.size = val;
      global_method_cache.mask = val - 1;
    } else {
      fprintf(__stderrp,
              "RUBY_GLOBAL_METHOD_CACHE_SIZE was set to %d but ignored because "
              "the value is not a power of 2.\n",
              val);
    }
  }

  global_method_cache.entries = (struct cache_entry *)calloc(
      global_method_cache.size, sizeof(struct cache_entry));
  if (global_method_cache.entries == ((void *)0)) {
    fprintf(__stderrp, "[FATAL] failed to allocate memory\n");
    exit(1);
  }
}

void Init_eval_method(void) {

  rb_define_method(rb_mKernel, "respond_to?", obj_respond_to, -1);
  rb_define_method(rb_mKernel, "respond_to_missing?", obj_respond_to_missing,
                   2);

  rb_define_method(rb_cModule, "remove_method", rb_mod_remove_method, -1);
  rb_define_method(rb_cModule, "undef_method", rb_mod_undef_method, -1);
  rb_define_method(rb_cModule, "alias_method", rb_mod_alias_method, 2);
  rb_define_private_method(rb_cModule, "public", rb_mod_public, -1);
  rb_define_private_method(rb_cModule, "protected", rb_mod_protected, -1);
  rb_define_private_method(rb_cModule, "private", rb_mod_private, -1);
  rb_define_private_method(rb_cModule, "module_function", rb_mod_modfunc, -1);

  rb_define_method(rb_cModule, "method_defined?", rb_mod_method_defined, -1);
  rb_define_method(rb_cModule, "public_method_defined?",
                   rb_mod_public_method_defined, -1);
  rb_define_method(rb_cModule, "private_method_defined?",
                   rb_mod_private_method_defined, -1);
  rb_define_method(rb_cModule, "protected_method_defined?",
                   rb_mod_protected_method_defined, -1);
  rb_define_method(rb_cModule, "public_class_method", rb_mod_public_method, -1);
  rb_define_method(rb_cModule, "private_class_method", rb_mod_private_method,
                   -1);

  rb_define_private_method(rb_singleton_class(rb_vm_top_self()), "public",
                           top_public, -1);
  rb_define_private_method(rb_singleton_class(rb_vm_top_self()), "private",
                           top_private, -1);

  {

    do {
      const rb_method_entry_t *me =
          rb_method_entry((rb_eException), (idMethodMissing));
      rb_method_entry_set(
          (rb_eException), (idMethodMissing), me,
          (rb_method_visibility_t)(((me)->flags & (((VALUE)RUBY_FL_USER4) |
                                                   ((VALUE)RUBY_FL_USER5))) >>
                                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)));
    } while (0);
    do {
      const rb_method_entry_t *me =
          rb_method_entry((rb_eException), (idRespond_to));
      rb_method_entry_set(
          (rb_eException), (idRespond_to), me,
          (rb_method_visibility_t)(((me)->flags & (((VALUE)RUBY_FL_USER4) |
                                                   ((VALUE)RUBY_FL_USER5))) >>
                                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)));
    } while (0);
    do {
      const rb_method_entry_t *me =
          rb_method_entry((rb_eException), (idRespond_to_missing));
      rb_method_entry_set(
          (rb_eException), (idRespond_to_missing), me,
          (rb_method_visibility_t)(((me)->flags & (((VALUE)RUBY_FL_USER4) |
                                                   ((VALUE)RUBY_FL_USER5))) >>
                                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 0)));
    } while (0);
  }
}
# 319 "vm.c" 2

# 1 "./vm_eval.c" 1
# 14 "./vm_eval.c"
struct local_var_list {
  VALUE tbl;
};

static inline VALUE method_missing(VALUE obj, ID id, int argc,
                                   const VALUE *argv,
                                   enum method_missing_reason call_status);
static inline VALUE vm_yield_with_cref(rb_execution_context_t *ec, int argc,
                                       const VALUE *argv, const rb_cref_t *cref,
                                       int is_lambda);
static inline VALUE vm_yield(rb_execution_context_t *ec, int argc,
                             const VALUE *argv);
static inline VALUE vm_yield_with_block(rb_execution_context_t *ec, int argc,
                                        const VALUE *argv, VALUE block_handler);
static inline VALUE vm_yield_force_blockarg(rb_execution_context_t *ec,
                                            VALUE args);
VALUE rb_vm_exec(rb_execution_context_t *ec, int mjit_enable_p);
static void vm_set_eval_stack(rb_execution_context_t *th, const rb_iseq_t *iseq,
                              const rb_cref_t *cref,
                              const struct rb_block *base_block);
static int
vm_collect_local_variables_in_heap(const VALUE *dfp,
                                   const struct local_var_list *vars);

static VALUE rb_eUncaughtThrow;
static ID id_result, id_tag, id_value;

typedef enum call_type {
  CALL_PUBLIC,
  CALL_FCALL,
  CALL_VCALL,
  CALL_TYPE_MAX
} call_type;

static VALUE send_internal(int argc, const VALUE *argv, VALUE recv,
                           call_type scope);
static VALUE vm_call0_body(rb_execution_context_t *ec,
                           struct rb_calling_info *calling,
                           const struct rb_call_info *ci,
                           struct rb_call_cache *cc, const VALUE *argv);

__attribute__((__visibility__("default"))) extern VALUE
rb_vm_call0(rb_execution_context_t *ec, VALUE recv, ID id, int argc,
            const VALUE *argv, const rb_callable_method_entry_t *me) {
  struct rb_calling_info calling_entry, *calling;
  struct rb_call_info ci_entry;
  struct rb_call_cache cc_entry;

  calling = &calling_entry;

  ci_entry.flag = 0;
  ci_entry.mid = id;

  cc_entry.me = me;

  calling->recv = recv;
  calling->argc = argc;

  return vm_call0_body(ec, calling, &ci_entry, &cc_entry, argv);
}

static VALUE vm_call0_cfunc_with_frame(rb_execution_context_t *ec,
                                       struct rb_calling_info *calling,
                                       const struct rb_call_info *ci,
                                       struct rb_call_cache *cc,
                                       const VALUE *argv) {
  VALUE val;
  const rb_callable_method_entry_t *me = cc->me;
  const rb_method_cfunc_t *cfunc = &me->def->body.cfunc;
  int len = cfunc->argc;
  VALUE recv = calling->recv;
  int argc = calling->argc;
  ID mid = ci->mid;
  VALUE block_handler = calling->block_handler;

  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$cmethod__entry$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$cmethod__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);
  do {
    const rb_event_flag_t flag_arg_ = (0x0020);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, recv, me->def->original_id, mid,
                              me->owner, ((VALUE)RUBY_Qnil), 0);
    }
  } while (0);
  {
    rb_control_frame_t *reg_cfp = ec->cfp;

    vm_push_frame(
        ec, 0, VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL,
        recv, block_handler, (VALUE)me, 0, reg_cfp->sp, 0, 0);

    if (len >= 0)
      rb_check_arity(argc, len, len);

    val = (*cfunc->invoker)(cfunc->func, recv, argc, argv);

    ((__builtin_expect(!!(vm_cfp_consistent_p(ec, reg_cfp)), 1))
         ? (void)0
         : rb_bug("vm_call0_cfunc_with_frame"
                  ": cfp consistency error (%p, %p)",
                  (void *)reg_cfp, (void *)(ec->cfp + 1)));
    rb_vm_pop_frame(ec);
  }
  do {
    const rb_event_flag_t flag_arg_ = (0x0040);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, recv, me->def->original_id, mid,
                              me->owner, val, 0);
    }
  } while (0);
  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);

  return val;
}

static VALUE vm_call0_cfunc(rb_execution_context_t *ec,
                            struct rb_calling_info *calling,
                            const struct rb_call_info *ci,
                            struct rb_call_cache *cc, const VALUE *argv) {
  return vm_call0_cfunc_with_frame(ec, calling, ci, cc, argv);
}

static VALUE vm_call0_body(rb_execution_context_t *ec,
                           struct rb_calling_info *calling,
                           const struct rb_call_info *ci,
                           struct rb_call_cache *cc, const VALUE *argv) {
  VALUE ret;

  calling->block_handler = vm_passed_block_handler(ec);

again:
  switch (cc->me->def->type) {
  case VM_METHOD_TYPE_ISEQ: {
    rb_control_frame_t *reg_cfp = ec->cfp;
    int i;

    if ((__builtin_expect(
            !!(!(
                !(1 / !!(sizeof(*((reg_cfp)->sp)) == sizeof(VALUE))) ||
                !(1 / !!(sizeof(*(reg_cfp)) == sizeof(rb_control_frame_t))) ||
                ((rb_control_frame_t *)(((reg_cfp)->sp) + (calling->argc + 1)) +
                 1) >= (reg_cfp))),
            1))) {
      (void)0;
    } else
      vm_stackoverflow();

    *reg_cfp->sp++ = calling->recv;
    for (i = 0; i < calling->argc; i++) {
      *reg_cfp->sp++ = argv[i];
    }

    vm_call_iseq_setup(ec, reg_cfp, calling, ci, cc);
    VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);
    return rb_vm_exec(ec, 1);
  }
  case VM_METHOD_TYPE_NOTIMPLEMENTED:
  case VM_METHOD_TYPE_CFUNC:
    ret = vm_call0_cfunc(ec, calling, ci, cc, argv);
    goto success;
  case VM_METHOD_TYPE_ATTRSET:
    rb_check_arity(calling->argc, 1, 1);
    ret = rb_ivar_set(calling->recv, cc->me->def->body.attr.id, argv[0]);
    goto success;
  case VM_METHOD_TYPE_IVAR:
    rb_check_arity(calling->argc, 0, 0);
    ret = rb_attr_get(calling->recv, cc->me->def->body.attr.id);
    goto success;
  case VM_METHOD_TYPE_BMETHOD:
    ret = vm_call_bmethod_body(ec, calling, ci, cc, argv);
    goto success;
  case VM_METHOD_TYPE_ZSUPER:
  case VM_METHOD_TYPE_REFINED: {
    const rb_method_type_t type = cc->me->def->type;
    VALUE super_class = cc->me->defined_class;

    if (type == VM_METHOD_TYPE_ZSUPER) {
      super_class = ((((struct RClass *)(super_class))->ptr)->origin_);
    } else if (cc->me->def->body.refined.orig_me) {
      cc->me = refined_method_callable_without_refinement(cc->me);
      goto again;
    }

    super_class = RCLASS_SUPER(super_class);

    if (!super_class ||
        !(cc->me = rb_callable_method_entry(super_class, ci->mid))) {
      enum method_missing_reason ex =
          (type == VM_METHOD_TYPE_ZSUPER) ? MISSING_SUPER : 0;
      ret = method_missing(calling->recv, ci->mid, calling->argc, argv, ex);
      goto success;
    }
    rb_vm_check_ints(ec);
    goto again;
  }
  case VM_METHOD_TYPE_ALIAS:
    cc->me = aliased_callable_method_entry(cc->me);
    goto again;
  case VM_METHOD_TYPE_MISSING: {
    vm_passed_block_handler_set(ec, calling->block_handler);
    return method_missing(calling->recv, ci->mid, calling->argc, argv,
                          MISSING_NOENTRY);
  }
  case VM_METHOD_TYPE_OPTIMIZED:
    switch (cc->me->def->body.optimize_type) {
    case OPTIMIZED_METHOD_TYPE_SEND:
      ret = send_internal(calling->argc, argv, calling->recv, CALL_FCALL);
      goto success;
    case OPTIMIZED_METHOD_TYPE_CALL: {
      rb_proc_t *proc;
      (((proc)) = (rb_proc_t *)(((struct RData *)(((calling->recv))))->data));
      ret = rb_vm_invoke_proc(ec, proc, calling->argc, argv,
                              calling->block_handler);
      goto success;
    }
    default:
      rb_bug("vm_call0: unsupported optimized method type (%d)",
             cc->me->def->body.optimize_type);
    }
    break;
  case VM_METHOD_TYPE_UNDEF:
    break;
  }
  rb_bug("vm_call0: unsupported method type (%d)", cc->me->def->type);
  return ((VALUE)RUBY_Qundef);

success:
  rb_vm_check_ints(ec);
  return ret;
}

VALUE
rb_vm_call(rb_execution_context_t *ec, VALUE recv, VALUE id, int argc,
           const VALUE *argv, const rb_callable_method_entry_t *me) {
  return rb_vm_call0(ec, recv, id, argc, argv, me);
}

static inline VALUE vm_call_super(rb_execution_context_t *ec, int argc,
                                  const VALUE *argv) {
  VALUE recv = ec->cfp->self;
  VALUE klass;
  ID id;
  rb_control_frame_t *cfp = ec->cfp;
  const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(cfp);

  if (VM_FRAME_RUBYFRAME_P(cfp)) {
    rb_bug("vm_call_super: should not be reached");
  }

  klass = ((((struct RClass *)(me->defined_class))->ptr)->origin_);
  klass = RCLASS_SUPER(klass);
  id = me->def->original_id;
  me = rb_callable_method_entry(klass, id);

  if (!me) {
    return method_missing(recv, id, argc, argv, MISSING_SUPER);
  } else {
    return rb_vm_call0(ec, recv, id, argc, argv, me);
  }
}

VALUE
rb_call_super(int argc, const VALUE *argv) {
  rb_execution_context_t *ec = rb_current_execution_context();
  pass_passed_block_handler(ec);
  return vm_call_super(ec, argc, argv);
}

VALUE
rb_current_receiver(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp;
  if (!ec || !(cfp = ec->cfp)) {
    rb_raise(rb_eRuntimeError, "no self, no life");
  }
  return cfp->self;
}

static inline void stack_check(rb_execution_context_t *ec) {
  if (!(((ec)->raised_flag & (RAISED_STACKOVERFLOW)) != 0) &&
      rb_ec_stack_check(ec)) {
    ((ec)->raised_flag |= (RAISED_STACKOVERFLOW));
    rb_ec_stack_overflow(ec, 0);
  }
}

static inline const rb_callable_method_entry_t *
rb_search_method_entry(VALUE recv, ID mid);
static inline enum method_missing_reason
rb_method_call_status(rb_execution_context_t *ec,
                      const rb_callable_method_entry_t *me, call_type scope,
                      VALUE self);
# 288 "./vm_eval.c"
static inline VALUE rb_call0(rb_execution_context_t *ec, VALUE recv, ID mid,
                             int argc, const VALUE *argv, call_type scope,
                             VALUE self) {
  const rb_callable_method_entry_t *me = rb_search_method_entry(recv, mid);
  enum method_missing_reason call_status =
      rb_method_call_status(ec, me, scope, self);

  if (call_status != MISSING_NONE) {
    return method_missing(recv, mid, argc, argv, call_status);
  }
  stack_check(ec);
  return rb_vm_call0(ec, recv, mid, argc, argv, me);
}

struct rescue_funcall_args {
  VALUE defined_class;
  VALUE recv;
  ID mid;
  rb_execution_context_t *ec;
  const rb_method_entry_t *me;
  unsigned int respond : 1;
  unsigned int respond_to_missing : 1;
  int argc;
  const VALUE *argv;
};

static VALUE check_funcall_exec(struct rescue_funcall_args *args) {
  return call_method_entry(args->ec, args->defined_class, args->recv,
                           idMethodMissing, args->me, args->argc, args->argv);
}

static VALUE check_funcall_failed(struct rescue_funcall_args *args, VALUE e) {
  int ret = args->respond;
  if (!ret) {
    switch (rb_method_boundp(args->defined_class, args->mid, 0x01 | 0x02)) {
    case 2:
      ret = 1;
      break;
    case 0:
      ret = args->respond_to_missing;
      break;
    default:
      ret = 0;
      break;
    }
  }
  if (ret) {
    rb_exc_raise(e);
  }
  return ((VALUE)RUBY_Qundef);
}

static int check_funcall_respond_to(rb_execution_context_t *ec, VALUE klass,
                                    VALUE recv, ID mid) {
  return vm_respond_to(ec, klass, recv, mid, 1);
}

static int check_funcall_callable(rb_execution_context_t *ec,
                                  const rb_callable_method_entry_t *me) {
  return rb_method_call_status(ec, me, CALL_FCALL, ec->cfp->self) ==
         MISSING_NONE;
}

static VALUE check_funcall_missing(rb_execution_context_t *ec, VALUE klass,
                                   VALUE recv, ID mid, int argc,
                                   const VALUE *argv, int respond, VALUE def) {
  struct rescue_funcall_args args;
  const rb_method_entry_t *me;
  VALUE ret = ((VALUE)RUBY_Qundef);

  ret = basic_obj_respond_to_missing(ec, klass, recv, (rb_id2sym(mid)),
                                     ((VALUE)RUBY_Qtrue));
  if (!!(((VALUE)(ret) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))
    return def;
  args.respond = respond > 0;
  args.respond_to_missing = (ret != ((VALUE)RUBY_Qundef));
  ret = def;
  me = method_entry_get(klass, idMethodMissing, &args.defined_class);
  if (me && !(int)(((me)->flags & (((VALUE)RUBY_FL_USER6))) >>
                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 2))) {
    VALUE argbuf,
        *new_args =
            ((VALUE *)(((size_t)(argc + 1) < 1024 / sizeof(VALUE))
                           ? ((*__extension__({
                                volatile VALUE *rb_gc_guarded_ptr = &(argbuf);
                                __asm__("" : : "m"(rb_gc_guarded_ptr));
                                rb_gc_guarded_ptr;
                              })) = 0,
                              __builtin_alloca((size_t)(argc + 1) *
                                               sizeof(VALUE)))
                           : rb_alloc_tmp_buffer2(&(argbuf), (long)(argc + 1),
                                                  sizeof(VALUE))));

    new_args[0] = (rb_id2sym(mid));
    __builtin___memcpy_chk((new_args + 1), (argv),
                           sizeof(VALUE) * (size_t)(argc),
                           __builtin_object_size((new_args + 1), 0));
    ec->method_missing_reason = MISSING_NOENTRY;
    args.ec = ec;
    args.recv = recv;
    args.me = me;
    args.mid = mid;
    args.argc = argc + 1;
    args.argv = new_args;
    ret = rb_rescue2(check_funcall_exec, (VALUE)&args, check_funcall_failed,
                     (VALUE)&args, rb_eNoMethodError, (VALUE)0);
    rb_free_tmp_buffer(&(argbuf));
  }
  return ret;
}

VALUE
rb_check_funcall(VALUE recv, ID mid, int argc, const VALUE *argv) {
  return rb_check_funcall_default(recv, mid, argc, argv, ((VALUE)RUBY_Qundef));
}

VALUE
rb_check_funcall_default(VALUE recv, ID mid, int argc, const VALUE *argv,
                         VALUE def) {
  VALUE klass = rb_class_of((VALUE)(recv));
  const rb_callable_method_entry_t *me;
  rb_execution_context_t *ec = rb_current_execution_context();
  int respond = check_funcall_respond_to(ec, klass, recv, mid);

  if (!respond)
    return def;

  me = rb_search_method_entry(recv, mid);
  if (!check_funcall_callable(ec, me)) {
    VALUE ret =
        check_funcall_missing(ec, klass, recv, mid, argc, argv, respond, def);
    if (ret == ((VALUE)RUBY_Qundef))
      ret = def;
    return ret;
  }
  stack_check(ec);
  return rb_vm_call0(ec, recv, mid, argc, argv, me);
}

VALUE
rb_check_funcall_with_hook(VALUE recv, ID mid, int argc, const VALUE *argv,
                           rb_check_funcall_hook *hook, VALUE arg) {
  VALUE klass = rb_class_of((VALUE)(recv));
  const rb_callable_method_entry_t *me;
  rb_execution_context_t *ec = rb_current_execution_context();
  int respond = check_funcall_respond_to(ec, klass, recv, mid);

  if (!respond) {
    (*hook)(0, recv, mid, argc, argv, arg);
    return ((VALUE)RUBY_Qundef);
  }

  me = rb_search_method_entry(recv, mid);
  if (!check_funcall_callable(ec, me)) {
    VALUE ret = check_funcall_missing(ec, klass, recv, mid, argc, argv, respond,
                                      ((VALUE)RUBY_Qundef));
    (*hook)(ret != ((VALUE)RUBY_Qundef), recv, mid, argc, argv, arg);
    return ret;
  }
  stack_check(ec);
  (*hook)(1, recv, mid, argc, argv, arg);
  return rb_vm_call0(ec, recv, mid, argc, argv, me);
}

const char *rb_type_str(enum ruby_value_type type) {

  switch (type) {
  case RUBY_T_NONE:
    return "T_NONE";
  case RUBY_T_OBJECT:
    return "T_OBJECT";
  case RUBY_T_CLASS:
    return "T_CLASS";
  case RUBY_T_MODULE:
    return "T_MODULE";
  case RUBY_T_FLOAT:
    return "T_FLOAT";
  case RUBY_T_STRING:
    return "T_STRING";
  case RUBY_T_REGEXP:
    return "T_REGEXP";
  case RUBY_T_ARRAY:
    return "T_ARRAY";
  case RUBY_T_HASH:
    return "T_HASH";
  case RUBY_T_STRUCT:
    return "T_STRUCT";
  case RUBY_T_BIGNUM:
    return "T_BIGNUM";
  case RUBY_T_FILE:
    return "T_FILE";
  case RUBY_T_DATA:
    return "T_DATA";
  case RUBY_T_MATCH:
    return "T_MATCH";
  case RUBY_T_COMPLEX:
    return "T_COMPLEX";
  case RUBY_T_RATIONAL:
    return "T_RATIONAL";
  case RUBY_T_NIL:
    return "T_NIL";
  case RUBY_T_TRUE:
    return "T_TRUE";
  case RUBY_T_FALSE:
    return "T_FALSE";
  case RUBY_T_SYMBOL:
    return "T_SYMBOL";
  case RUBY_T_FIXNUM:
    return "T_FIXNUM";
  case RUBY_T_IMEMO:
    return "T_IMEMO";
  case RUBY_T_UNDEF:
    return "T_UNDEF";
  case RUBY_T_NODE:
    return "T_NODE";
  case RUBY_T_ICLASS:
    return "T_ICLASS";
  case RUBY_T_ZOMBIE:
    return "T_ZOMBIE";
  case RUBY_T_MASK:
    break;
  }

  return ((void *)0);
}

__attribute__((__noreturn__)) static void uncallable_object(VALUE recv, ID mid);
static void uncallable_object(VALUE recv, ID mid) {
  VALUE flags;
  int type;
  const char *typestr;
  VALUE mname = rb_id2str(mid);

  if ((((VALUE)(recv)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(recv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    rb_raise(rb_eNotImpError,
             "method `%"
             "l"
             "i"
             "\v"
             "' called on unexpected immediate object (%p)",
             mname, (void *)recv);
  } else if ((flags = ((struct RBasic *)(recv))->flags) == 0) {
    rb_raise(rb_eNotImpError,
             "method `%"
             "l"
             "i"
             "\v"
             "' called on terminated object (%p)",
             mname, (void *)recv);
  } else if (!(typestr =
                   rb_type_str(type = (int)(((struct RBasic *)(recv))->flags &
                                            RUBY_T_MASK)))) {
    rb_raise(rb_eNotImpError,
             "method `%"
             "l"
             "i"
             "\v"
             "' called on broken T_?"
             "?"
             "?(0x%02x) object"
             " (%p flags=0x%"
             "l"
             "x"
             ")",
             mname, type, (void *)recv, flags);
  } else if (RUBY_T_OBJECT <= type && type < RUBY_T_NIL) {
    rb_raise(rb_eNotImpError,
             "method `%"
             "l"
             "i"
             "\v"
             "' called on hidden %s object"
             " (%p flags=0x%"
             "l"
             "x"
             ")",
             mname, typestr, (void *)recv, flags);
  } else {
    rb_raise(rb_eNotImpError,
             "method `%"
             "l"
             "i"
             "\v"
             "' called on unexpected %s object"
             " (%p flags=0x%"
             "l"
             "x"
             ")",
             mname, typestr, (void *)recv, flags);
  }
}

static inline const rb_callable_method_entry_t *
rb_search_method_entry(VALUE recv, ID mid) {
  VALUE klass = rb_class_of((VALUE)(recv));

  if (!klass)
    uncallable_object(recv, mid);
  return rb_callable_method_entry(klass, mid);
}

static inline enum method_missing_reason
rb_method_call_status(rb_execution_context_t *ec,
                      const rb_callable_method_entry_t *me, call_type scope,
                      VALUE self) {
  VALUE klass;
  ID oid;
  rb_method_visibility_t visi;

  if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF)) {
  idMethod_undefined:
    return scope == CALL_VCALL ? MISSING_VCALL : MISSING_NOENTRY;
  }
  if (me->def->type == VM_METHOD_TYPE_REFINED) {
    me = rb_resolve_refined_method_callable(((VALUE)RUBY_Qnil), me);
    if ((!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF))
      goto idMethod_undefined;
  }

  klass = me->owner;
  oid = me->def->original_id;
  visi = (rb_method_visibility_t)(
      ((me)->flags & (((VALUE)RUBY_FL_USER4) | ((VALUE)RUBY_FL_USER5))) >>
      ((((VALUE)RUBY_FL_USHIFT) + 4) + 0));

  if (oid != idMethodMissing) {

    if ((__builtin_expect(!!(visi != METHOD_VISI_PUBLIC), 0))) {
      if (visi == METHOD_VISI_PRIVATE && scope == CALL_PUBLIC) {
        return MISSING_PRIVATE;
      }

      if (visi == METHOD_VISI_PROTECTED && scope == CALL_PUBLIC) {
        VALUE defined_class = klass;

        if ((((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
                 ? (((int)(long)(defined_class)) & RUBY_FIXNUM_FLAG)
                 : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                       ? ((defined_class) == ((VALUE)RUBY_Qtrue))
                       : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                             ? ((defined_class) == ((VALUE)RUBY_Qfalse))
                             : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                                   ? ((defined_class) == ((VALUE)RUBY_Qnil))
                                   : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                         ? ((defined_class) ==
                                            ((VALUE)RUBY_Qundef))
                                         : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                               ? ((((VALUE)(defined_class) &
                                                    ~((~(VALUE)0)
                                                      << RUBY_SPECIAL_SHIFT)) ==
                                                   RUBY_SYMBOL_FLAG) ||
                                                  (!(((VALUE)(
                                                         defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(
                                                             defined_class) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(defined_class))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       (RUBY_T_SYMBOL)))
                                               : ((RUBY_T_ICLASS) ==
                                                  RUBY_T_FLOAT)
                                                     ? (((((int)(long)(defined_class)) &
                                                          RUBY_FLONUM_MASK) ==
                                                         RUBY_FLONUM_FLAG) ||
                                                        (!(((VALUE)(
                                                               defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                           !!(((VALUE)(
                                                                   defined_class) &
                                                               (VALUE) ~(
                                                                   (VALUE)
                                                                       RUBY_Qnil)) ==
                                                              0)) &&
                                                         (int)(((struct RBasic
                                                                     *)(defined_class))
                                                                   ->flags &
                                                               RUBY_T_MASK) ==
                                                             RUBY_T_FLOAT))
                                                     : (!(((VALUE)(
                                                              defined_class)&RUBY_IMMEDIATE_MASK) ||
                                                          !!(((VALUE)(
                                                                  defined_class) &
                                                              (VALUE) ~(
                                                                  (VALUE)
                                                                      RUBY_Qnil)) ==
                                                             0)) &&
                                                        (int)(((struct RBasic
                                                                    *)(defined_class))
                                                                  ->flags &
                                                              RUBY_T_MASK) ==
                                                            (RUBY_T_ICLASS)))) {
          defined_class = ((struct RBasic *)(defined_class))->klass;
        }

        if (self == ((VALUE)RUBY_Qundef) ||
            !rb_obj_is_kind_of(self, defined_class)) {
          return MISSING_PROTECTED;
        }
      }
    }
  }

  return MISSING_NONE;
}
# 589 "./vm_eval.c"
static inline VALUE rb_call(VALUE recv, ID mid, int argc, const VALUE *argv,
                            call_type scope) {
  rb_execution_context_t *ec = rb_current_execution_context();
  return rb_call0(ec, recv, mid, argc, argv, scope, ec->cfp->self);
}

__attribute__((__noreturn__)) static void
raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv,
                     VALUE obj, enum method_missing_reason call_status);
# 632 "./vm_eval.c"
static VALUE rb_method_missing(int argc, const VALUE *argv, VALUE obj) {
  rb_execution_context_t *ec = rb_current_execution_context();
  raise_method_missing(ec, argc, argv, obj, ec->method_missing_reason);
  __builtin_unreachable();
}

__attribute__((__visibility__("default"))) extern VALUE
rb_make_no_method_exception(VALUE exc, VALUE format, VALUE obj, int argc,
                            const VALUE *argv, int priv) {
  VALUE name = argv[0];

  if (!format) {
    format = rb_fstring_new(("undefined method `%s' for %s%s%s"),
                            (sizeof("undefined method `%s' for %s%s%s"
                                    "") -
                             1));
  }
  if (exc == rb_eNoMethodError) {
    VALUE args = rb_ary_new_from_values(argc - 1, argv + 1);
    return rb_nomethod_err_new(format, obj, name, args, priv);
  } else {
    return rb_name_err_new(format, obj, name);
  }
}

static void raise_method_missing(rb_execution_context_t *ec, int argc,
                                 const VALUE *argv, VALUE obj,
                                 enum method_missing_reason last_call_status) {
  VALUE exc = rb_eNoMethodError;
  VALUE format = 0;

  if ((__builtin_expect(!!(argc == 0), 0))) {
    rb_raise(rb_eArgError, "no method name given");
  } else if ((__builtin_expect(
                 !!(!((((VALUE)(argv[0]) &
                        ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
                       RUBY_SYMBOL_FLAG) ||
                      (!(((VALUE)(argv[0]) & RUBY_IMMEDIATE_MASK) ||
                         !!(((VALUE)(argv[0]) & (VALUE) ~((VALUE)RUBY_Qnil)) ==
                            0)) &&
                       (int)(((struct RBasic *)(argv[0]))->flags &
                             RUBY_T_MASK) == (RUBY_T_SYMBOL)))),
                 0))) {
    const VALUE e = rb_eArgError;
    rb_raise(e,
             "method name must be a Symbol but %"
             "l"
             "i"
             "\v"
             " is given",
             rb_obj_class(argv[0]));
  }

  stack_check(ec);

  if (last_call_status & MISSING_PRIVATE) {
    format = rb_fstring_new(("private method `%s' called for %s%s%s"),
                            (sizeof("private method `%s' called for %s%s%s"
                                    "") -
                             1));
  } else if (last_call_status & MISSING_PROTECTED) {
    format = rb_fstring_new(("protected method `%s' called for %s%s%s"),
                            (sizeof("protected method `%s' called for %s%s%s"
                                    "") -
                             1));
  } else if (last_call_status & MISSING_VCALL) {
    format = rb_fstring_new(
        ("undefined local variable or method `%s' for %s%s%s"),
        (sizeof("undefined local variable or method `%s' for %s%s%s"
                "") -
         1));
    exc = rb_eNameError;
  } else if (last_call_status & MISSING_SUPER) {
    format =
        rb_fstring_new(("super: no superclass method `%s' for %s%s%s"),
                       (sizeof("super: no superclass method `%s' for %s%s%s"
                               "") -
                        1));
  }

  {
    exc = rb_make_no_method_exception(exc, format, obj, argc, argv,
                                      last_call_status &
                                          (MISSING_FCALL | MISSING_VCALL));
    if (!(last_call_status & MISSING_MISSING)) {
      rb_vm_pop_cfunc_frame();
    }
    rb_exc_raise(exc);
  }
}

static void vm_raise_method_missing(rb_execution_context_t *ec, int argc,
                                    const VALUE *argv, VALUE obj,
                                    int call_status) {
  vm_passed_block_handler_set(ec, 0);
  raise_method_missing(ec, argc, argv, obj, call_status | MISSING_MISSING);
}

static inline VALUE method_missing(VALUE obj, ID id, int argc,
                                   const VALUE *argv,
                                   enum method_missing_reason call_status) {
  VALUE *nargv, result, work, klass;
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE block_handler = vm_passed_block_handler(ec);
  const rb_callable_method_entry_t *me;

  ec->method_missing_reason = call_status;

  if (id == idMethodMissing) {
  missing:
    raise_method_missing(ec, argc, argv, obj, call_status | MISSING_MISSING);
  }

  nargv =
      ((VALUE *)(((size_t)(argc + 1) < 1024 / sizeof(VALUE))
                     ? ((*__extension__({
                          volatile VALUE *rb_gc_guarded_ptr = &(work);
                          __asm__("" : : "m"(rb_gc_guarded_ptr));
                          rb_gc_guarded_ptr;
                        })) = 0,
                        __builtin_alloca((size_t)(argc + 1) * sizeof(VALUE)))
                     : rb_alloc_tmp_buffer2(&(work), (long)(argc + 1),
                                            sizeof(VALUE))));
  nargv[0] = (rb_id2sym(id));
  __builtin___memcpy_chk((nargv + 1), (argv), sizeof(VALUE) * (size_t)(argc),
                         __builtin_object_size((nargv + 1), 0));
  ++argc;
  argv = nargv;

  klass = rb_class_of((VALUE)(obj));
  if (!klass)
    goto missing;
  me = rb_callable_method_entry(klass, idMethodMissing);
  if (!me || (int)(((me)->flags & (((VALUE)RUBY_FL_USER6))) >>
                   ((((VALUE)RUBY_FL_USHIFT) + 4) + 2)))
    goto missing;
  vm_passed_block_handler_set(ec, block_handler);
  result = rb_vm_call0(ec, obj, idMethodMissing, argc, argv, me);
  if (work)
    rb_free_tmp_buffer(&(work));
  return result;
}
# 751 "./vm_eval.c"
VALUE
rb_apply(VALUE recv, ID mid, VALUE args) {
  int argc;
  VALUE *argv, ret;

  argc = rb_long2int_inline(rb_array_len(args));
  if (argc >= 0x100) {
    args = rb_ary_subseq(args, 0, argc);
    __builtin___memset_chk(
        &(((struct RBasicRaw *)((VALUE)(args)))->klass), 0, sizeof(VALUE),
        __builtin_object_size(&(((struct RBasicRaw *)((VALUE)(args)))->klass),
                              0));
    rb_obj_freeze_inline((VALUE)args);
    ret = rb_call(recv, mid, argc, rb_array_const_ptr(args), CALL_FCALL);
    (*__extension__({
      volatile VALUE *rb_gc_guarded_ptr = &(args);
      __asm__("" : : "m"(rb_gc_guarded_ptr));
      rb_gc_guarded_ptr;
    }));
    return ret;
  }
  argv = (VALUE *)__builtin_alloca_with_align((sizeof(VALUE) * (argc)),
                                              _Alignof(VALUE) * 8);
  __builtin___memcpy_chk((argv), (rb_array_const_ptr_transient(args)),
                         sizeof(VALUE) * (size_t)(argc),
                         __builtin_object_size((argv), 0));
  return rb_call(recv, mid, argc, argv, CALL_FCALL);
}
# 781 "./vm_eval.c"
VALUE
rb_funcall(VALUE recv, ID mid, int n, ...) {
  VALUE *argv;
  va_list ar;

  if (n > 0) {
    long i;

    __builtin_va_start((ar), (n));

    argv = (VALUE *)__builtin_alloca_with_align((sizeof(VALUE) * (n)),
                                                _Alignof(VALUE) * 8);

    for (i = 0; i < n; i++) {
      argv[i] = __builtin_va_arg(ar, VALUE);
    }
    __builtin_va_end(ar);
  } else {
    argv = 0;
  }
  return rb_call(recv, mid, n, argv, CALL_FCALL);
}
# 812 "./vm_eval.c"
VALUE
rb_funcallv(VALUE recv, ID mid, int argc, const VALUE *argv) {
  return rb_call(recv, mid, argc, argv, CALL_FCALL);
}
# 827 "./vm_eval.c"
VALUE
rb_funcallv_public(VALUE recv, ID mid, int argc, const VALUE *argv) {
  return rb_call(recv, mid, argc, argv, CALL_PUBLIC);
}

VALUE
rb_funcall_passing_block(VALUE recv, ID mid, int argc, const VALUE *argv) {
  pass_passed_block_handler(rb_current_execution_context());
  return rb_call(recv, mid, argc, argv, CALL_PUBLIC);
}

VALUE
rb_funcall_with_block(VALUE recv, ID mid, int argc, const VALUE *argv,
                      VALUE passed_procval) {
  if (!!((VALUE)(passed_procval) != ((VALUE)RUBY_Qnil))) {
    vm_passed_block_handler_set(rb_current_execution_context(), passed_procval);
  }

  return rb_call(recv, mid, argc, argv, CALL_PUBLIC);
}

static VALUE *current_vm_stack_arg(const rb_execution_context_t *ec,
                                   const VALUE *argv) {
  rb_control_frame_t *prev_cfp = ((ec->cfp) + 1);
  if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, prev_cfp))
    return ((void *)0);
  if (prev_cfp->sp + 1 != argv)
    return ((void *)0);
  return prev_cfp->sp + 1;
}

static VALUE send_internal(int argc, const VALUE *argv, VALUE recv,
                           call_type scope) {
  ID id;
  VALUE vid;
  VALUE self;
  VALUE ret, vargv = 0;
  rb_execution_context_t *ec = rb_current_execution_context();

  if (scope == CALL_PUBLIC) {
    self = ((VALUE)RUBY_Qundef);
  } else {
    self = ((ec->cfp) + 1)->self;
  }

  if (argc == 0) {
    rb_raise(rb_eArgError, "no method name given");
  }

  vid = *argv;

  id = rb_check_id(&vid);
  if (!id) {
    if (rb_method_basic_definition_p(rb_class_of((VALUE)(recv)),
                                     idMethodMissing)) {
      VALUE exc = rb_make_no_method_exception(rb_eNoMethodError, 0, recv, argc,
                                              argv, scope != CALL_PUBLIC);
      rb_exc_raise(exc);
    }
    if (!((((VALUE)(*argv) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
           RUBY_SYMBOL_FLAG) ||
          (!(((VALUE)(*argv) & RUBY_IMMEDIATE_MASK) ||
             !!(((VALUE)(*argv) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
           (int)(((struct RBasic *)(*argv))->flags & RUBY_T_MASK) ==
               (RUBY_T_SYMBOL)))) {
      VALUE *tmp_argv = current_vm_stack_arg(ec, argv);
      vid = rb_str_intern(vid);
      if (tmp_argv) {
        tmp_argv[0] = vid;
      } else if (argc > 1) {
        tmp_argv =
            ((VALUE *)(((size_t)(argc) < 1024 / sizeof(VALUE))
                           ? ((*__extension__({
                                volatile VALUE *rb_gc_guarded_ptr = &(vargv);
                                __asm__("" : : "m"(rb_gc_guarded_ptr));
                                rb_gc_guarded_ptr;
                              })) = 0,
                              __builtin_alloca((size_t)(argc) * sizeof(VALUE)))
                           : rb_alloc_tmp_buffer2(&(vargv), (long)(argc),
                                                  sizeof(VALUE))));
        tmp_argv[0] = vid;
        __builtin___memcpy_chk((tmp_argv + 1), (argv + 1),
                               sizeof(VALUE) * (size_t)(argc - 1),
                               __builtin_object_size((tmp_argv + 1), 0));
        argv = tmp_argv;
      } else {
        argv = &vid;
      }
    }
    id = idMethodMissing;
    ec->method_missing_reason = MISSING_NOENTRY;
  } else {
    argv++;
    argc--;
  }
  pass_passed_block_handler(ec);
  ret = rb_call0(ec, recv, id, argc, argv, scope, self);
  rb_free_tmp_buffer(&(vargv));
  return ret;
}
# 939 "./vm_eval.c"
VALUE
rb_f_send(int argc, VALUE *argv, VALUE recv) {
  return send_internal(argc, argv, recv, CALL_FCALL);
}
# 959 "./vm_eval.c"
static VALUE rb_f_public_send(int argc, VALUE *argv, VALUE recv) {
  return send_internal(argc, argv, recv, CALL_PUBLIC);
}

static inline VALUE rb_yield_0(int argc, const VALUE *argv) {
  return vm_yield(rb_current_execution_context(), argc, argv);
}

VALUE
rb_yield_1(VALUE val) { return rb_yield_0(1, &val); }

VALUE
rb_yield(VALUE val) {
  if (val == ((VALUE)RUBY_Qundef)) {
    return rb_yield_0(0, 0);
  } else {
    return rb_yield_1(val);
  }
}

VALUE
rb_yield_values(int n, ...) {
  if (n == 0) {
    return rb_yield_0(0, 0);
  } else {
    int i;
    VALUE *argv;
    va_list args;
    argv = (VALUE *)__builtin_alloca_with_align((sizeof(VALUE) * (n)),
                                                _Alignof(VALUE) * 8);

    __builtin_va_start((args), (n));
    for (i = 0; i < n; i++) {
      argv[i] = __builtin_va_arg(args, VALUE);
    }
    __builtin_va_end(args);

    return rb_yield_0(n, argv);
  }
}

VALUE
rb_yield_values2(int argc, const VALUE *argv) { return rb_yield_0(argc, argv); }

VALUE
rb_yield_splat(VALUE values) {
  VALUE tmp = rb_check_array_type(values);
  VALUE v;
  if (!((VALUE)(tmp) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eArgError, "not an array");
  }
  v = rb_yield_0(rb_long2int_inline(rb_array_len(tmp)),
                 rb_array_const_ptr(tmp));
  (*__extension__({
    volatile VALUE *rb_gc_guarded_ptr = &(tmp);
    __asm__("" : : "m"(rb_gc_guarded_ptr));
    rb_gc_guarded_ptr;
  }));
  return v;
}

VALUE
rb_yield_force_blockarg(VALUE values) {
  return vm_yield_force_blockarg(rb_current_execution_context(), values);
}

VALUE
rb_yield_block(VALUE val, VALUE arg, int argc, const VALUE *argv,
               VALUE blockarg) {
  return vm_yield_with_block(
      rb_current_execution_context(), argc, argv,
      !((VALUE)(blockarg) != ((VALUE)RUBY_Qnil)) ? 0 : blockarg);
}

static VALUE loop_i(void) {
  for (;;) {
    rb_yield_0(0, 0);
  }
  return ((VALUE)RUBY_Qnil);
}

static VALUE loop_stop(VALUE dummy, VALUE exc) {
  return rb_attr_get(exc, id_result);
}

static VALUE rb_f_loop_size(VALUE self, VALUE args, VALUE eobj) {
  return rb_float_new_inline(__builtin_huge_val());
}
# 1096 "./vm_eval.c"
static VALUE rb_f_loop(VALUE self) {
  do {
    if (!rb_block_given_p())
      return rb_enumeratorize_with_size((self),
                                        (rb_id2sym(rb_frame_this_func())), (0),
                                        (0), (rb_f_loop_size));
  } while (0);
  return rb_rescue2(loop_i, (VALUE)0, loop_stop, (VALUE)0, rb_eStopIteration,
                    (VALUE)0);
}

static VALUE rb_iterate0(VALUE (*it_proc)(VALUE), VALUE data1,
                         const struct vm_ifunc *const ifunc,
                         rb_execution_context_t *ec) {
  enum ruby_tag_type state;
  volatile VALUE retval = ((VALUE)RUBY_Qnil);
  rb_control_frame_t *const cfp = ec->cfp;

  do {
    rb_execution_context_t *const _ec = (ec);
    struct rb_vm_tag _tag;
    _tag.state = RUBY_TAG_NONE;
    _tag.tag = ((VALUE)RUBY_Qundef);
    _tag.prev = _ec->tag;
    ;
    state = (sigsetjmp((_tag.buf), 0) ? rb_ec_tag_state(__extension__(*(
                                            __typeof__(_ec) volatile *)&(_ec)))
                                      : ((void)(_ec->tag = &_tag), 0));
    if (state == 0) {
    iter_retry : {
      VALUE block_handler;

      if (ifunc) {
        struct rb_captured_block *captured = VM_CFP_TO_CAPTURED_BLOCK(cfp);
        captured->code.ifunc = ifunc;
        block_handler = VM_BH_FROM_IFUNC_BLOCK(captured);
      } else {
        block_handler = VM_CF_BLOCK_HANDLER(cfp);
      }
      vm_passed_block_handler_set(ec, block_handler);
    }
      retval = (*it_proc)(data1);
    } else if (state == RUBY_TAG_BREAK || state == RUBY_TAG_RETRY) {
      const struct vm_throw_data *const err =
          (struct vm_throw_data *)ec->errinfo;
      const rb_control_frame_t *const escape_cfp = THROW_DATA_CATCH_FRAME(err);

      if (cfp == escape_cfp) {
        rb_vm_rewind_cfp(ec, cfp);

        state = 0;
        ec->tag->state = RUBY_TAG_NONE;
        ec->errinfo = ((VALUE)RUBY_Qnil);

        if (state == RUBY_TAG_RETRY)
          goto iter_retry;
        retval = THROW_DATA_VAL(err);
      } else if (0) {
        rb_vmdebug_stack_dump_raw(rb_current_execution_context(),
                                  rb_current_execution_context()->cfp);
        fprintf(__stderrp, "%p, %p\n", (void *)cfp, (void *)escape_cfp);
      }
    }
    _ec->tag = _tag.prev;
  } while (0);

  if (state) {
    rb_ec_tag_jump(ec, state);
  }
  return retval;
}

VALUE
rb_iterate(VALUE (*it_proc)(VALUE), VALUE data1, VALUE (*bl_proc)(),
           VALUE data2) {
  return rb_iterate0(it_proc, data1,
                     bl_proc ? rb_vm_ifunc_proc_new(bl_proc, (void *)data2) : 0,
                     rb_current_execution_context());
}

struct iter_method_arg {
  VALUE obj;
  ID mid;
  int argc;
  const VALUE *argv;
};

static VALUE iterate_method(VALUE obj) {
  const struct iter_method_arg *arg = (struct iter_method_arg *)obj;

  return rb_call(arg->obj, arg->mid, arg->argc, arg->argv, CALL_FCALL);
}

VALUE
rb_block_call(VALUE obj, ID mid, int argc, const VALUE *argv,
              VALUE (*bl_proc)(), VALUE data2) {
  struct iter_method_arg arg;

  arg.obj = obj;
  arg.mid = mid;
  arg.argc = argc;
  arg.argv = argv;
  return rb_iterate(iterate_method, (VALUE)&arg, bl_proc, data2);
}

VALUE
rb_lambda_call(VALUE obj, ID mid, int argc, const VALUE *argv,
               rb_block_call_func_t bl_proc, int min_argc, int max_argc,
               VALUE data2) {
  struct iter_method_arg arg;
  struct vm_ifunc *block;

  if (!bl_proc)
    rb_raise(rb_eArgError, "NULL lambda function");
  arg.obj = obj;
  arg.mid = mid;
  arg.argc = argc;
  arg.argv = argv;
  block = rb_vm_ifunc_new(bl_proc, (void *)data2, min_argc, max_argc);
  return rb_iterate0(iterate_method, (VALUE)&arg, block,
                     rb_current_execution_context());
}

static VALUE iterate_check_method(VALUE obj) {
  const struct iter_method_arg *arg = (struct iter_method_arg *)obj;

  return rb_check_funcall(arg->obj, arg->mid, arg->argc, arg->argv);
}

VALUE
rb_check_block_call(VALUE obj, ID mid, int argc, const VALUE *argv,
                    VALUE (*bl_proc)(), VALUE data2) {
  struct iter_method_arg arg;

  arg.obj = obj;
  arg.mid = mid;
  arg.argc = argc;
  arg.argv = argv;
  return rb_iterate(iterate_check_method, (VALUE)&arg, bl_proc, data2);
}

VALUE
rb_each(VALUE obj) { return rb_call(obj, idEach, 0, 0, CALL_FCALL); }

void rb_parser_warn_location(VALUE, int);
static const rb_iseq_t *eval_make_iseq(VALUE src, VALUE fname, int line,
                                       const rb_binding_t *bind,
                                       const struct rb_block *base_block) {
  const VALUE parser = rb_parser_new();
  const rb_iseq_t *const parent = vm_block_iseq(base_block);
  VALUE realpath = ((VALUE)RUBY_Qnil);
  rb_iseq_t *iseq = 0;
  rb_ast_t *ast;

  if (!fname) {
    fname = rb_source_location(&line);
  }

  if (fname != ((VALUE)RUBY_Qundef)) {
    realpath = fname;
  } else if (bind) {
    fname = pathobj_path(bind->pathobj);
    realpath = pathobj_realpath(bind->pathobj);
    line = bind->first_lineno;
    rb_parser_warn_location(parser, 1);
  } else {
    fname = __extension__({
      (__builtin_constant_p("(eval)"))
          ? rb_usascii_str_new_static(("(eval)"), (long)strlen("(eval)"))
          : rb_usascii_str_new_cstr("(eval)");
    });
  }

  rb_parser_set_context(parser, base_block, 0);
  ast = rb_parser_compile_string_path(parser, fname, src, line);
  if (ast->body.root) {
    iseq = rb_iseq_new_with_opt(&ast->body, parent->body->location.label, fname,
                                realpath,
                                (((VALUE)(line)) << 1 | RUBY_FIXNUM_FLAG),
                                parent, ISEQ_TYPE_EVAL, ((void *)0));
  }
  rb_ast_dispose(ast);

  if (0 && iseq) {
    VALUE disasm = rb_iseq_disasm(iseq);
    printf("%s\n", rb_string_value_ptr(&(disasm)));
  }

  return iseq;
}

static VALUE eval_string_with_cref(VALUE self, VALUE src, rb_cref_t *cref,
                                   VALUE file, int line) {
  rb_execution_context_t *ec = rb_current_execution_context();
  struct rb_block block;
  const rb_iseq_t *iseq;
  rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);
  if (!cfp) {
    rb_raise(rb_eRuntimeError, "Can't eval on top of Fiber or Thread");
  }

  block.as.captured = *VM_CFP_TO_CAPTURED_BLOCK(cfp);
  block.as.captured.self = self;
  block.as.captured.code.iseq = cfp->iseq;
  block.type = block_type_iseq;

  iseq = eval_make_iseq(src, file, line, ((void *)0), &block);
  if (!iseq) {
    rb_exc_raise(ec->errinfo);
  }

  if (!cref && block.as.captured.code.val) {
    rb_cref_t *orig_cref = rb_vm_get_cref(vm_block_ep(&block));
    cref = vm_cref_dup(orig_cref);
  }
  vm_set_eval_stack(ec, iseq, cref, &block);

  return rb_vm_exec(ec, 1);
}

static VALUE eval_string_with_scope(VALUE scope, VALUE src, VALUE file,
                                    int line) {
  rb_execution_context_t *ec = rb_current_execution_context();
  rb_binding_t *bind =
      rb_check_typeddata((VALUE)(scope), (&ruby_binding_data_type));
  const rb_iseq_t *iseq = eval_make_iseq(src, file, line, bind, &bind->block);
  if (!iseq) {
    rb_exc_raise(ec->errinfo);
  }

  vm_set_eval_stack(ec, iseq, ((void *)0), &bind->block);

  if (iseq->body->local_table_size > 0) {
    vm_bind_update_env(scope, bind, vm_make_env_object(ec, ec->cfp));
  }

  return rb_vm_exec(ec, 1);
}
# 1362 "./vm_eval.c"
VALUE
rb_f_eval(int argc, const VALUE *argv, VALUE self) {
  VALUE src, scope, vfile, vline;
  VALUE file = ((VALUE)RUBY_Qundef);
  int line = 1;

  __builtin_choose_expr(
      __builtin_constant_p("13"),
      rb_scan_args_set(
          argc, argv, rb_scan_args_n_lead("13"), rb_scan_args_n_opt("13"),
          rb_scan_args_n_trail("13"), rb_scan_args_f_var("13"),
          rb_scan_args_f_hash("13"), rb_scan_args_f_block("13"),
          (0, ((VALUE *[]){&src, &scope, &vfile, &vline})), (char *)"13",
          (sizeof((VALUE *[]){&src, &scope, &vfile, &vline}) /
           sizeof(VALUE *))),
      rb_scan_args(argc, argv, "13", &src, &scope, &vfile, &vline));
  do {
    rb_string_value(&(src));
    rb_check_safe_obj(src);
  } while (0);
  if (argc >= 3) {
    rb_string_value(&(vfile));
  }
  if (argc >= 4) {
    line = rb_num2int_inline(vline);
  }

  if (!!((VALUE)(vfile) != ((VALUE)RUBY_Qnil)))
    file = vfile;

  if (!((VALUE)(scope) != ((VALUE)RUBY_Qnil)))
    return eval_string_with_cref(self, src, ((void *)0), file, line);
  else
    return eval_string_with_scope(scope, src, file, line);
}

VALUE
ruby_eval_string_from_file(const char *str, const char *filename) {
  VALUE file = filename ? __extension__({
    (__builtin_constant_p(filename))
        ? rb_str_new_static((filename), (long)strlen(filename))
        : rb_str_new_cstr(filename);
  })
                        : 0;
  return eval_string_with_cref(rb_vm_top_self(), __extension__({
                                 (__builtin_constant_p(str))
                                     ? rb_str_new_static((str),
                                                         (long)strlen(str))
                                     : rb_str_new_cstr(str);
                               }),
                               ((void *)0), file, 1);
}

struct eval_string_from_file_arg {
  VALUE str;
  VALUE filename;
};

static VALUE eval_string_from_file_helper(VALUE data) {
  const struct eval_string_from_file_arg *const arg =
      (struct eval_string_from_file_arg *)data;
  return eval_string_with_cref(rb_vm_top_self(), arg->str, ((void *)0),
                               arg->filename, 1);
}

VALUE
ruby_eval_string_from_file_protect(const char *str, const char *filename,
                                   int *state) {
  struct eval_string_from_file_arg arg;
  arg.str = __extension__({
    (__builtin_constant_p(str)) ? rb_str_new_static((str), (long)strlen(str))
                                : rb_str_new_cstr(str);
  });
  arg.filename = filename ? __extension__({
    (__builtin_constant_p(filename))
        ? rb_str_new_static((filename), (long)strlen(filename))
        : rb_str_new_cstr(filename);
  })
                          : 0;
  return rb_protect(eval_string_from_file_helper, (VALUE)&arg, state);
}
# 1428 "./vm_eval.c"
VALUE
rb_eval_string(const char *str) {
  return ruby_eval_string_from_file(str, "eval");
}

static VALUE eval_string_protect(VALUE str) {
  return rb_eval_string((char *)str);
}
# 1450 "./vm_eval.c"
VALUE
rb_eval_string_protect(const char *str, int *pstate) {
  return rb_protect(eval_string_protect, (VALUE)str, pstate);
}
# 1467 "./vm_eval.c"
VALUE
rb_eval_string_wrap(const char *str, int *pstate) {
  int state;
  rb_thread_t *th = rb_current_thread();
  VALUE self = th->top_self;
  VALUE wrapper = th->top_wrapper;
  VALUE val;

  th->top_wrapper = rb_module_new();
  th->top_self = rb_obj_clone(rb_vm_top_self());
  rb_extend_object(th->top_self, th->top_wrapper);

  val = rb_eval_string_protect(str, &state);

  th->top_self = self;
  th->top_wrapper = wrapper;

  if (pstate) {
    *pstate = state;
  } else if (state != RUBY_TAG_NONE) {
    rb_ec_tag_jump(th->ec, state);
  }
  return val;
}

VALUE
rb_eval_cmd(VALUE cmd, VALUE arg, int level) {
  enum ruby_tag_type state;
  volatile VALUE val = ((VALUE)RUBY_Qnil);
  const int volatile current_safe_level = rb_safe_level();
  rb_execution_context_t *volatile ec = rb_current_execution_context();

  if ((!!((!(((VALUE)((cmd)) & RUBY_IMMEDIATE_MASK) ||
             !!(((VALUE)((cmd)) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
           (int)(((struct RBasic *)((cmd)))->flags & RUBY_T_MASK) !=
               RUBY_T_NODE)
              ? (((struct RBasic *)(((cmd))))->flags & ((RUBY_FL_TAINT)))
              : 0))) {
    level = 1;
  }

  do {
    rb_execution_context_t *const _ec = (ec);
    struct rb_vm_tag _tag;
    _tag.state = RUBY_TAG_NONE;
    _tag.tag = ((VALUE)RUBY_Qundef);
    _tag.prev = _ec->tag;
    ;
    rb_set_safe_level_force(level);
    if ((state = (sigsetjmp((_tag.buf), 0)
                      ? rb_ec_tag_state(
                            __extension__(*(__typeof__(_ec) volatile *)&(_ec)))
                      : ((void)(_ec->tag = &_tag), 0))) == RUBY_TAG_NONE) {
      if (!(((RUBY_T_STRING) == RUBY_T_FIXNUM)
                ? (((int)(long)(cmd)) & RUBY_FIXNUM_FLAG)
                : ((RUBY_T_STRING) == RUBY_T_TRUE)
                      ? ((cmd) == ((VALUE)RUBY_Qtrue))
                      : ((RUBY_T_STRING) == RUBY_T_FALSE)
                            ? ((cmd) == ((VALUE)RUBY_Qfalse))
                            : ((RUBY_T_STRING) == RUBY_T_NIL)
                                  ? ((cmd) == ((VALUE)RUBY_Qnil))
                                  : ((RUBY_T_STRING) == RUBY_T_UNDEF)
                                        ? ((cmd) == ((VALUE)RUBY_Qundef))
                                        : ((RUBY_T_STRING) == RUBY_T_SYMBOL)
                                              ? ((((VALUE)(cmd) &
                                                   ~((~(VALUE)0)
                                                     << RUBY_SPECIAL_SHIFT)) ==
                                                  RUBY_SYMBOL_FLAG) ||
                                                 (!(((VALUE)(
                                                        cmd)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(cmd) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)(cmd))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_SYMBOL)))
                                              : ((RUBY_T_STRING) ==
                                                 RUBY_T_FLOAT)
                                                    ? (((((int)(long)(cmd)) &
                                                         RUBY_FLONUM_MASK) ==
                                                        RUBY_FLONUM_FLAG) ||
                                                       (!(((VALUE)(
                                                              cmd)&RUBY_IMMEDIATE_MASK) ||
                                                          !!(((VALUE)(cmd) &
                                                              (VALUE) ~(
                                                                  (VALUE)
                                                                      RUBY_Qnil)) ==
                                                             0)) &&
                                                        (int)(((struct RBasic
                                                                    *)(cmd))
                                                                  ->flags &
                                                              RUBY_T_MASK) ==
                                                            RUBY_T_FLOAT))
                                                    : (!(((VALUE)(
                                                             cmd)&RUBY_IMMEDIATE_MASK) ||
                                                         !!(((VALUE)(cmd) &
                                                             (VALUE) ~(
                                                                 (VALUE)
                                                                     RUBY_Qnil)) ==
                                                            0)) &&
                                                       (int)(((struct RBasic
                                                                   *)(cmd))
                                                                 ->flags &
                                                             RUBY_T_MASK) ==
                                                           (RUBY_T_STRING)))) {
        val = rb_funcallv(cmd, idCall, rb_long2int_inline(rb_array_len(arg)),
                          rb_array_const_ptr(arg));
      } else {
        val = eval_string_with_cref(rb_vm_top_self(), cmd, ((void *)0), 0, 0);
      }
    }
    _ec->tag = _tag.prev;
  } while (0);

  rb_set_safe_level_force(current_safe_level);
  if (state)
    rb_ec_tag_jump(ec, state);
  return val;
}

static VALUE yield_under(VALUE under, VALUE self, int argc, const VALUE *argv) {
  rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp = ec->cfp;
  VALUE block_handler = VM_CF_BLOCK_HANDLER(cfp);
  VALUE new_block_handler = 0;
  const struct rb_captured_block *captured = ((void *)0);
  struct rb_captured_block new_captured;
  const VALUE *ep = ((void *)0);
  rb_cref_t *cref;
  int is_lambda = 0;

  if (block_handler != 0) {
  again:
    switch (vm_block_handler_type(block_handler)) {
    case block_handler_type_iseq:
      captured = VM_BH_TO_CAPT_BLOCK(block_handler);
      new_captured = *captured;
      new_block_handler = VM_BH_FROM_ISEQ_BLOCK(&new_captured);
      break;
    case block_handler_type_ifunc:
      captured = VM_BH_TO_CAPT_BLOCK(block_handler);
      new_captured = *captured;
      new_block_handler = VM_BH_FROM_IFUNC_BLOCK(&new_captured);
      break;
    case block_handler_type_proc:
      is_lambda = rb_proc_lambda_p(block_handler) != ((VALUE)RUBY_Qfalse);
      block_handler = vm_proc_to_block_handler(VM_BH_TO_PROC(block_handler));
      goto again;
    case block_handler_type_symbol:
      return rb_sym_proc_call((rb_sym2id(VM_BH_TO_SYMBOL(block_handler))), argc,
                              argv, 0);
    }

    new_captured.self = self;
    ep = captured->ep;

    VM_FORCE_WRITE_SPECIAL_CONST(&VM_CF_LEP(ec->cfp)[(-1)], new_block_handler);
  }

  cref = vm_cref_push(ec, under, ep, 1);
  return vm_yield_with_cref(ec, argc, argv, cref, is_lambda);
}

VALUE
rb_yield_refine_block(VALUE refinement, VALUE refinements) {
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE block_handler = VM_CF_BLOCK_HANDLER(ec->cfp);

  if (vm_block_handler_type(block_handler) != block_handler_type_iseq) {
    rb_bug("rb_yield_refine_block: an iseq block is required");
  } else {
    const struct rb_captured_block *captured =
        VM_BH_TO_ISEQ_BLOCK(block_handler);
    struct rb_captured_block new_captured = *captured;
    VALUE new_block_handler = VM_BH_FROM_ISEQ_BLOCK(&new_captured);
    const VALUE *ep = captured->ep;
    rb_cref_t *cref = vm_cref_push(ec, refinement, ep, 1);
    CREF_REFINEMENTS_SET(cref, refinements);
    VM_FORCE_WRITE_SPECIAL_CONST(&VM_CF_LEP(ec->cfp)[(-1)], new_block_handler);
    new_captured.self = refinement;
    return vm_yield_with_cref(ec, 0, ((void *)0), cref, 0);
  }
}

static VALUE eval_under(VALUE under, VALUE self, VALUE src, VALUE file,
                        int line) {
  rb_cref_t *cref =
      vm_cref_push(rb_current_execution_context(), under, ((void *)0),
                   (((VALUE)(self)&RUBY_IMMEDIATE_MASK) ||
                    !!(((VALUE)(self) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
                       !!((VALUE)(under) != ((VALUE)RUBY_Qnil)));
  do {
    rb_string_value(&(src));
    rb_check_safe_obj(src);
  } while (0);
  return eval_string_with_cref(self, src, cref, file, line);
}

static VALUE specific_eval(int argc, const VALUE *argv, VALUE klass,
                           VALUE self) {
  if (rb_block_given_p()) {
    rb_check_arity(argc, 0, 0);
    return yield_under(klass, self, 1, &self);
  } else {
    VALUE file = ((VALUE)RUBY_Qundef);
    int line = 1;
    VALUE code;

    rb_check_arity(argc, 1, 3);
    code = argv[0];
    do {
      rb_string_value(&(code));
      rb_check_safe_obj(code);
    } while (0);
    if (argc > 2)
      line = rb_num2int_inline(argv[2]);
    if (argc > 1) {
      file = argv[1];
      if (!!((VALUE)(file) != ((VALUE)RUBY_Qnil)))
        rb_string_value(&(file));
    }
    return eval_under(klass, self, code, file, line);
  }
}

static VALUE singleton_class_for_eval(VALUE self) {
  if ((((VALUE)(self)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(self) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0))) {
    return rb_special_singleton_class(self);
  }
  switch ((int)(((struct RBasic *)(self))->flags & RUBY_T_MASK)) {
  case RUBY_T_FLOAT:
  case RUBY_T_BIGNUM:
  case RUBY_T_SYMBOL:
    return ((VALUE)RUBY_Qnil);
  case RUBY_T_STRING:
    if ((((struct RBasic *)(self))->flags & (RSTRING_FSTR)))
      return ((VALUE)RUBY_Qnil);
  default:
    return rb_singleton_class(self);
  }
}
# 1676 "./vm_eval.c"
VALUE
rb_obj_instance_eval(int argc, const VALUE *argv, VALUE self) {
  VALUE klass = singleton_class_for_eval(self);
  return specific_eval(argc, argv, klass, self);
}
# 1701 "./vm_eval.c"
VALUE
rb_obj_instance_exec(int argc, const VALUE *argv, VALUE self) {
  VALUE klass = singleton_class_for_eval(self);
  return yield_under(klass, self, argc, argv);
}
# 1735 "./vm_eval.c"
VALUE
rb_mod_module_eval(int argc, const VALUE *argv, VALUE mod) {
  return specific_eval(argc, argv, mod, mod);
}
# 1763 "./vm_eval.c"
VALUE
rb_mod_module_exec(int argc, const VALUE *argv, VALUE mod) {
  return yield_under(mod, mod, argc, argv);
}
# 1782 "./vm_eval.c"
static VALUE uncaught_throw_init(int argc, const VALUE *argv, VALUE exc) {
  rb_check_arity(argc, 2, (-1));
  rb_call_super(argc - 2, argv + 2);
  rb_ivar_set(exc, id_tag, argv[0]);
  rb_ivar_set(exc, id_value, argv[1]);
  return exc;
}
# 1799 "./vm_eval.c"
static VALUE uncaught_throw_tag(VALUE exc) { return rb_ivar_get(exc, id_tag); }
# 1812 "./vm_eval.c"
static VALUE uncaught_throw_value(VALUE exc) {
  return rb_ivar_get(exc, id_value);
}
# 1825 "./vm_eval.c"
static VALUE uncaught_throw_to_s(VALUE exc) {
  VALUE mesg = rb_attr_get(exc, idMesg);
  VALUE tag = uncaught_throw_tag(exc);
  return rb_str_format(1, &tag, mesg);
}
# 1845 "./vm_eval.c"
static VALUE rb_f_throw(int argc, VALUE *argv) {
  VALUE tag, value;

  __builtin_choose_expr(
      __builtin_constant_p("11"),
      rb_scan_args_set(argc, argv, rb_scan_args_n_lead("11"),
                       rb_scan_args_n_opt("11"), rb_scan_args_n_trail("11"),
                       rb_scan_args_f_var("11"), rb_scan_args_f_hash("11"),
                       rb_scan_args_f_block("11"),
                       (0, ((VALUE *[]){&tag, &value})), (char *)"11",
                       (sizeof((VALUE *[]){&tag, &value}) / sizeof(VALUE *))),
      rb_scan_args(argc, argv, "11", &tag, &value));
  rb_throw_obj(tag, value);
  __builtin_unreachable();
}

void rb_throw_obj(VALUE tag, VALUE value) {
  rb_execution_context_t *ec = rb_current_execution_context();
  struct rb_vm_tag *tt = ec->tag;

  while (tt) {
    if (tt->tag == tag) {
      tt->retval = value;
      break;
    }
    tt = tt->prev;
  }
  if (!tt) {
    VALUE desc[3];
    desc[0] = tag;
    desc[1] = value;
    desc[2] = __extension__({
      (__builtin_constant_p("uncaught throw %p"))
          ? rb_str_new_static(("uncaught throw %p"),
                              (long)strlen("uncaught throw %p"))
          : rb_str_new_cstr("uncaught throw %p");
    });
    rb_exc_raise(rb_class_new_instance(
        ((int)(sizeof(desc) / sizeof((desc)[0]))), desc, rb_eUncaughtThrow));
  }

  ec->errinfo = (VALUE)THROW_DATA_NEW(tag, ((void *)0), RUBY_TAG_THROW);
  rb_ec_tag_jump(ec, RUBY_TAG_THROW);
}

void rb_throw(const char *tag, VALUE val) {
  rb_throw_obj(__extension__({
                 (__builtin_constant_p(tag))
                     ? rb_sym_intern_ascii((tag), (long)strlen(tag))
                     : rb_sym_intern_ascii_cstr(tag);
               }),
               val);
}

static VALUE catch_i(VALUE tag, VALUE data) { return rb_yield_0(1, &tag); }
# 1943 "./vm_eval.c"
static VALUE rb_f_catch(int argc, VALUE *argv) {
  VALUE tag;

  if (argc == 0) {
    tag = rb_obj_alloc(rb_cObject);
  } else {
    __builtin_choose_expr(
        __builtin_constant_p("01"),
        rb_scan_args_set(argc, argv, rb_scan_args_n_lead("01"),
                         rb_scan_args_n_opt("01"), rb_scan_args_n_trail("01"),
                         rb_scan_args_f_var("01"), rb_scan_args_f_hash("01"),
                         rb_scan_args_f_block("01"), (0, ((VALUE *[]){&tag})),
                         (char *)"01",
                         (sizeof((VALUE *[]){&tag}) / sizeof(VALUE *))),
        rb_scan_args(argc, argv, "01", &tag));
  }
  return rb_catch_obj(tag, catch_i, 0);
}

VALUE
rb_catch(const char *tag, VALUE (*func)(), VALUE data) {
  VALUE vtag = tag ? __extension__({
    (__builtin_constant_p(tag)) ? rb_sym_intern_ascii((tag), (long)strlen(tag))
                                : rb_sym_intern_ascii_cstr(tag);
  })
                   : rb_obj_alloc(rb_cObject);
  return rb_catch_obj(vtag, func, data);
}

static VALUE vm_catch_protect(VALUE tag, rb_block_call_func *func, VALUE data,
                              enum ruby_tag_type *stateptr,
                              rb_execution_context_t *volatile ec) {
  enum ruby_tag_type state;
  VALUE val = ((VALUE)RUBY_Qnil);
  rb_control_frame_t *volatile saved_cfp = ec->cfp;

  do {
    rb_execution_context_t *const _ec = (ec);
    struct rb_vm_tag _tag;
    _tag.state = RUBY_TAG_NONE;
    _tag.tag = ((VALUE)RUBY_Qundef);
    _tag.prev = _ec->tag;
    ;

    _tag.tag = tag;

    if ((state = (sigsetjmp((_tag.buf), 0)
                      ? rb_ec_tag_state(
                            __extension__(*(__typeof__(_ec) volatile *)&(_ec)))
                      : ((void)(_ec->tag = &_tag), 0))) == RUBY_TAG_NONE) {

      val = (*func)(tag, data, 1, (const VALUE *)&tag, ((VALUE)RUBY_Qnil));
    } else if (state == RUBY_TAG_THROW &&
               THROW_DATA_VAL((struct vm_throw_data *)ec->errinfo) == tag) {
      rb_vm_rewind_cfp(ec, saved_cfp);
      val = ec->tag->retval;
      ec->errinfo = ((VALUE)RUBY_Qnil);
      state = 0;
    }
    _ec->tag = _tag.prev;
  } while (0);
  if (stateptr)
    *stateptr = state;

  return val;
}

VALUE
rb_catch_protect(VALUE t, rb_block_call_func *func, VALUE data,
                 enum ruby_tag_type *stateptr) {
  return vm_catch_protect(t, func, data, stateptr,
                          rb_current_execution_context());
}

VALUE
rb_catch_obj(VALUE t, VALUE (*func)(), VALUE data) {
  enum ruby_tag_type state;
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE val = vm_catch_protect(t, (rb_block_call_func *)func, data, &state, ec);
  if (state)
    rb_ec_tag_jump(ec, state);
  return val;
}

static void local_var_list_init(struct local_var_list *vars) {
  vars->tbl = rb_hash_new_compare_by_id();
  __builtin___memset_chk(
      &(((struct RBasicRaw *)((VALUE)(vars->tbl)))->klass), 0, sizeof(VALUE),
      __builtin_object_size(
          &(((struct RBasicRaw *)((VALUE)(vars->tbl)))->klass), 0));
}

static VALUE local_var_list_finish(struct local_var_list *vars) {

  VALUE ary = rb_hash_keys(vars->tbl);
  rb_hash_clear(vars->tbl);
  vars->tbl = 0;
  return ary;
}

static int local_var_list_update(st_data_t *key, st_data_t *value,
                                 st_data_t arg, int existing) {
  if (existing)
    return ST_STOP;
  *value = (st_data_t)((VALUE)RUBY_Qtrue);
  return ST_CONTINUE;
}

static void local_var_list_add(const struct local_var_list *vars, ID lid) {
  if (lid && rb_is_local_id(lid)) {

    st_data_t idx = 0;
    rb_hash_stlike_update(vars->tbl, (rb_id2sym(lid)), local_var_list_update,
                          idx);
  }
}
# 2057 "./vm_eval.c"
static VALUE rb_f_local_variables(void) {
  struct local_var_list vars;
  rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp = vm_get_ruby_level_caller_cfp(ec, ((ec->cfp) + 1));
  unsigned int i;

  local_var_list_init(&vars);
  while (cfp) {
    if (cfp->iseq) {
      for (i = 0; i < cfp->iseq->body->local_table_size; i++) {
        local_var_list_add(&vars, cfp->iseq->body->local_table[i]);
      }
    }
    if (!VM_ENV_LOCAL_P(cfp->ep)) {

      const VALUE *ep = VM_CF_PREV_EP(cfp);

      if (vm_collect_local_variables_in_heap(ep, &vars)) {
        break;
      } else {
        while (cfp->ep != ep) {
          cfp = ((cfp) + 1);
        }
      }
    } else {
      break;
    }
  }
  return local_var_list_finish(&vars);
}
# 2114 "./vm_eval.c"
static VALUE rb_f_block_given_p(void) {
  rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp = ec->cfp;
  cfp = vm_get_ruby_level_caller_cfp(ec, ((cfp) + 1));

  if (cfp != ((void *)0) && VM_CF_BLOCK_HANDLER(cfp) != 0) {
    return ((VALUE)RUBY_Qtrue);
  } else {
    return ((VALUE)RUBY_Qfalse);
  }
}

VALUE
rb_current_realfilepath(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp = ec->cfp;
  cfp = vm_get_ruby_level_caller_cfp(ec, ((cfp) + 1));
  if (cfp != 0)
    return rb_iseq_realpath(cfp->iseq);
  return ((VALUE)RUBY_Qnil);
}

void Init_vm_eval(void) {
  rb_define_global_function("eval", rb_f_eval, -1);
  rb_define_global_function("local_variables", rb_f_local_variables, 0);
  rb_define_global_function("iterator?", rb_f_block_given_p, 0);
  rb_define_global_function("block_given?", rb_f_block_given_p, 0);

  rb_define_global_function("catch", rb_f_catch, -1);
  rb_define_global_function("throw", rb_f_throw, -1);

  rb_define_global_function("loop", rb_f_loop, 0);

  rb_define_method(rb_cBasicObject, "instance_eval", rb_obj_instance_eval, -1);
  rb_define_method(rb_cBasicObject, "instance_exec", rb_obj_instance_exec, -1);
  rb_define_private_method(rb_cBasicObject, "method_missing", rb_method_missing,
                           -1);

  rb_add_method(rb_cBasicObject, id__send__, VM_METHOD_TYPE_OPTIMIZED,
                (void *)OPTIMIZED_METHOD_TYPE_SEND, METHOD_VISI_PUBLIC);
  rb_add_method(rb_mKernel, idSend, VM_METHOD_TYPE_OPTIMIZED,
                (void *)OPTIMIZED_METHOD_TYPE_SEND, METHOD_VISI_PUBLIC);

  rb_define_method(rb_mKernel, "public_send", rb_f_public_send, -1);

  rb_define_method(rb_cModule, "module_exec", rb_mod_module_exec, -1);
  rb_define_method(rb_cModule, "class_exec", rb_mod_module_exec, -1);
  rb_define_method(rb_cModule, "module_eval", rb_mod_module_eval, -1);
  rb_define_method(rb_cModule, "class_eval", rb_mod_module_eval, -1);

  rb_eUncaughtThrow = rb_define_class("UncaughtThrowError", rb_eArgError);
  rb_define_method(rb_eUncaughtThrow, "initialize", uncaught_throw_init, -1);
  rb_define_method(rb_eUncaughtThrow, "tag", uncaught_throw_tag, 0);
  rb_define_method(rb_eUncaughtThrow, "value", uncaught_throw_value, 0);
  rb_define_method(rb_eUncaughtThrow, "to_s", uncaught_throw_to_s, 0);

  id_result =
      (__builtin_constant_p("result")
           ? __extension__(rb_intern2(("result"), (long)strlen("result")))
           : (rb_intern)("result"));
  id_tag = (__builtin_constant_p("tag")
                ? __extension__(rb_intern2(("tag"), (long)strlen("tag")))
                : (rb_intern)("tag"));
  id_value = (__builtin_constant_p("value")
                  ? __extension__(rb_intern2(("value"), (long)strlen("value")))
                  : (rb_intern)("value"));
}
# 321 "vm.c" 2

rb_serial_t rb_next_class_serial(void) {
  rb_serial_t class_serial = (++ruby_vm_class_serial);
  mjit_add_class_serial(class_serial);
  return class_serial;
}

VALUE rb_cRubyVM;
VALUE rb_cThread;
VALUE rb_mRubyVMFrozenCore;

VALUE ruby_vm_const_missing_count = 0;
rb_vm_t *ruby_current_vm_ptr = ((void *)0);
rb_execution_context_t *ruby_current_execution_context_ptr = ((void *)0);
rb_event_flag_t ruby_vm_event_flags;
rb_event_flag_t ruby_vm_event_enabled_flags;
rb_serial_t ruby_vm_global_method_state = 1;
rb_serial_t ruby_vm_global_constant_state = 1;
rb_serial_t ruby_vm_class_serial = 1;

static void thread_free(void *ptr);

void rb_vm_inc_const_missing_count(void) { ruby_vm_const_missing_count += 1; }

VALUE rb_class_path_no_cache(VALUE _klass);

__attribute__((__visibility__("default"))) extern int
rb_dtrace_setup(rb_execution_context_t *ec, VALUE klass, ID id,
                struct ruby_dtrace_method_hook_args *args) {
  enum ruby_value_type type;
  if (!klass) {
    if (!ec)
      ec = rb_current_execution_context();
    if (!rb_ec_frame_method_id_and_class(ec, &id, 0, &klass) || !klass)
      return 0;
  }
  if ((((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_ICLASS)))) {
    klass = ((struct RBasic *)(klass))->klass;
  } else if (((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
                 !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
               (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) !=
                   RUBY_T_NODE)
                  ? (((struct RBasic *)((klass)))->flags &
                     ((((VALUE)RUBY_FL_SINGLETON))))
                  : 0)) {
    klass = rb_attr_get(klass, id__attached__);
    if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil)))
      return 0;
  }
  type = (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK);
  if (type == RUBY_T_CLASS || type == RUBY_T_ICLASS || type == RUBY_T_MODULE) {
    VALUE name = rb_class_path_no_cache(klass);
    const char *classname, *filename;
    const char *methodname = rb_id2name(id);
    if (methodname &&
        (filename = rb_source_location_cstr(&args->line_no)) != 0) {
      if (!((VALUE)(name) != ((VALUE)RUBY_Qnil)) ||
          !(classname = rb_string_value_ptr(&(name))))
        classname = "<unknown>";
      args->classname = classname;
      args->methodname = methodname;
      args->filename = filename;
      args->klass = klass;
      args->name = name;
      return 1;
    }
  }
  return 0;
}
# 415 "vm.c"
static VALUE vm_stat(int argc, VALUE *argv, VALUE self) {
  static VALUE sym_global_method_state, sym_global_constant_state,
      sym_class_serial;
  VALUE arg = ((VALUE)RUBY_Qnil);
  VALUE hash = ((VALUE)RUBY_Qnil), key = ((VALUE)RUBY_Qnil);

  if (__builtin_choose_expr(
          __builtin_constant_p("01"),
          rb_scan_args_set(argc, argv, rb_scan_args_n_lead("01"),
                           rb_scan_args_n_opt("01"), rb_scan_args_n_trail("01"),
                           rb_scan_args_f_var("01"), rb_scan_args_f_hash("01"),
                           rb_scan_args_f_block("01"), (0, ((VALUE *[]){&arg})),
                           (char *)"01",
                           (sizeof((VALUE *[]){&arg}) / sizeof(VALUE *))),
          rb_scan_args(argc, argv, "01", &arg)) == 1) {
    if (((((VALUE)(arg) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
          RUBY_SYMBOL_FLAG) ||
         (!(((VALUE)(arg)&RUBY_IMMEDIATE_MASK) ||
            !!(((VALUE)(arg) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
          (int)(((struct RBasic *)(arg))->flags & RUBY_T_MASK) ==
              (RUBY_T_SYMBOL))))
      key = arg;
    else if (
        (((RUBY_T_HASH) == RUBY_T_FIXNUM)
             ? (((int)(long)(arg)) & RUBY_FIXNUM_FLAG)
             : ((RUBY_T_HASH) == RUBY_T_TRUE)
                   ? ((arg) == ((VALUE)RUBY_Qtrue))
                   : ((RUBY_T_HASH) == RUBY_T_FALSE)
                         ? ((arg) == ((VALUE)RUBY_Qfalse))
                         : ((RUBY_T_HASH) == RUBY_T_NIL)
                               ? ((arg) == ((VALUE)RUBY_Qnil))
                               : ((RUBY_T_HASH) == RUBY_T_UNDEF)
                                     ? ((arg) == ((VALUE)RUBY_Qundef))
                                     : ((RUBY_T_HASH) == RUBY_T_SYMBOL)
                                           ? ((((VALUE)(arg) &
                                                ~((~(VALUE)0)
                                                  << RUBY_SPECIAL_SHIFT)) ==
                                               RUBY_SYMBOL_FLAG) ||
                                              (!(((VALUE)(
                                                     arg)&RUBY_IMMEDIATE_MASK) ||
                                                 !!(((VALUE)(arg) &
                                                     (VALUE) ~(
                                                         (VALUE)RUBY_Qnil)) ==
                                                    0)) &&
                                               (int)(((struct RBasic *)(arg))
                                                         ->flags &
                                                     RUBY_T_MASK) ==
                                                   (RUBY_T_SYMBOL)))
                                           : ((RUBY_T_HASH) == RUBY_T_FLOAT)
                                                 ? (((((int)(long)(arg)) &
                                                      RUBY_FLONUM_MASK) ==
                                                     RUBY_FLONUM_FLAG) ||
                                                    (!(((VALUE)(
                                                           arg)&RUBY_IMMEDIATE_MASK) ||
                                                       !!(((VALUE)(arg) &
                                                           (VALUE) ~(
                                                               (VALUE)
                                                                   RUBY_Qnil)) ==
                                                          0)) &&
                                                     (int)(((struct RBasic
                                                                 *)(arg))
                                                               ->flags &
                                                           RUBY_T_MASK) ==
                                                         RUBY_T_FLOAT))
                                                 : (!(((VALUE)(
                                                          arg)&RUBY_IMMEDIATE_MASK) ||
                                                      !!(((VALUE)(arg) &
                                                          (VALUE) ~(
                                                              (VALUE)
                                                                  RUBY_Qnil)) ==
                                                         0)) &&
                                                    (int)(((struct RBasic
                                                                *)(arg))
                                                              ->flags &
                                                          RUBY_T_MASK) ==
                                                        (RUBY_T_HASH))))
      hash = arg;
    else
      rb_raise(rb_eTypeError, "non-hash or symbol given");
  } else {
    hash = rb_hash_new();
  }

  if (sym_global_method_state == 0) {

    sym_global_method_state = (rb_id2sym(
        (__builtin_constant_p("global_method_state")
             ? __extension__(rb_intern2(("global_method_state"),
                                        (long)strlen("global_method_state")))
             : (rb_intern)("global_method_state"))));
    sym_global_constant_state = (rb_id2sym(
        (__builtin_constant_p("global_constant_state")
             ? __extension__(rb_intern2(("global_constant_state"),
                                        (long)strlen("global_constant_state")))
             : (rb_intern)("global_constant_state"))));
    sym_class_serial =
        (rb_id2sym((__builtin_constant_p("class_serial")
                        ? __extension__(rb_intern2(
                              ("class_serial"), (long)strlen("class_serial")))
                        : (rb_intern)("class_serial"))));
  }

  if (key == sym_global_method_state)
    return rb_ull2inum(ruby_vm_global_method_state);
  else if (hash != ((VALUE)RUBY_Qnil))
    rb_hash_aset(hash, sym_global_method_state,
                 rb_ull2inum(ruby_vm_global_method_state));
  ;
  if (key == sym_global_constant_state)
    return rb_ull2inum(ruby_vm_global_constant_state);
  else if (hash != ((VALUE)RUBY_Qnil))
    rb_hash_aset(hash, sym_global_constant_state,
                 rb_ull2inum(ruby_vm_global_constant_state));
  ;
  if (key == sym_class_serial)
    return rb_ull2inum(ruby_vm_class_serial);
  else if (hash != ((VALUE)RUBY_Qnil))
    rb_hash_aset(hash, sym_class_serial, rb_ull2inum(ruby_vm_class_serial));
  ;

  if (!!((VALUE)(key) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eArgError,
             "unknown key: %"
             "l"
             "i"
             "\v",
             rb_sym2str(key));
  }

  return hash;
}

static void vm_set_top_stack(rb_execution_context_t *ec,
                             const rb_iseq_t *iseq) {
  if (iseq->body->type != ISEQ_TYPE_TOP) {
    rb_raise(rb_eTypeError, "Not a toplevel InstructionSequence");
  }

  vm_push_frame(
      ec, iseq, VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH,
      rb_ec_thread_ptr(ec)->top_self, 0, (VALUE)vm_cref_new_toplevel(ec),
      iseq->body->iseq_encoded, ec->cfp->sp, iseq->body->local_table_size,
      iseq->body->stack_max);
}

static void vm_set_eval_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                              const rb_cref_t *cref,
                              const struct rb_block *base_block) {
  vm_push_frame(ec, iseq, VM_FRAME_MAGIC_EVAL | VM_FRAME_FLAG_FINISH,
                vm_block_self(base_block),
                ((VALUE)((vm_block_ep(base_block))) | (0x01)), (VALUE)cref,
                iseq->body->iseq_encoded, ec->cfp->sp,
                iseq->body->local_table_size, iseq->body->stack_max);
}

static void vm_set_main_stack(rb_execution_context_t *ec,
                              const rb_iseq_t *iseq) {
  VALUE toplevel_binding = rb_const_get(
      rb_cObject,
      (__builtin_constant_p("TOPLEVEL_BINDING")
           ? __extension__(rb_intern2(("TOPLEVEL_BINDING"),
                                      (long)strlen("TOPLEVEL_BINDING")))
           : (rb_intern)("TOPLEVEL_BINDING")));
  rb_binding_t *bind;

  (((bind)) = (rb_binding_t *)(((struct RData *)(((toplevel_binding))))->data));
  ((bind) ? (void)0
          : rb_assert_failure("vm.c", 495, __func__,
                              "TOPLEVEL_BINDING is not built"));

  vm_set_eval_stack(ec, iseq, 0, &bind->block);

  if (iseq->body->local_table_size > 0) {
    vm_bind_update_env(toplevel_binding, bind, vm_make_env_object(ec, ec->cfp));
  }
}

rb_control_frame_t *
rb_vm_get_binding_creatable_next_cfp(const rb_execution_context_t *ec,
                                     const rb_control_frame_t *cfp) {
  while (!RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp)) {
    if (cfp->iseq) {
      return (rb_control_frame_t *)cfp;
    }
    cfp = ((cfp) + 1);
  }
  return 0;
}

__attribute__((__visibility__("default"))) extern rb_control_frame_t *
rb_vm_get_ruby_level_next_cfp(const rb_execution_context_t *ec,
                              const rb_control_frame_t *cfp) {
  if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp))
    ruby_debug_breakpoint();
  while (!RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp)) {
    if (VM_FRAME_RUBYFRAME_P(cfp)) {
      return (rb_control_frame_t *)cfp;
    }
    cfp = ((cfp) + 1);
  }
  return 0;
}

static rb_control_frame_t *
vm_get_ruby_level_caller_cfp(const rb_execution_context_t *ec,
                             const rb_control_frame_t *cfp) {
  if (VM_FRAME_RUBYFRAME_P(cfp)) {
    return (rb_control_frame_t *)cfp;
  }

  cfp = ((cfp) + 1);

  while (!RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp)) {
    if (VM_FRAME_RUBYFRAME_P(cfp)) {
      return (rb_control_frame_t *)cfp;
    }

    if (VM_ENV_FLAGS(cfp->ep, VM_FRAME_FLAG_PASSED) == 0) {
      break;
    }
    cfp = ((cfp) + 1);
  }
  return 0;
}

void rb_vm_pop_cfunc_frame(void) {
  rb_execution_context_t *ec = rb_current_execution_context();
  rb_control_frame_t *cfp = ec->cfp;
  const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(cfp);

  do {
    const rb_event_flag_t flag_arg_ = (0x0040);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, cfp->self, me->def->original_id,
                              me->called_id, me->owner, ((VALUE)RUBY_Qnil), 0);
    }
  } while (0);
  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);
  vm_pop_frame(ec, cfp, cfp->ep);
}

void rb_vm_rewind_cfp(rb_execution_context_t *ec, rb_control_frame_t *cfp) {

  while (ec->cfp != cfp) {

    if (VM_FRAME_TYPE(ec->cfp) != VM_FRAME_MAGIC_CFUNC) {
      rb_vm_pop_frame(ec);
    } else {
      rb_vm_pop_cfunc_frame();
    }
  }
}

void ruby_vm_at_exit(void (*func)(rb_vm_t *)) {
  rb_vm_t *vm = rb_current_vm();
  rb_at_exit_list *nl =
      ((rb_at_exit_list *)ruby_xmalloc(sizeof(rb_at_exit_list)));
  nl->func = func;
  nl->next = vm->at_exit;
  vm->at_exit = nl;
}

static void ruby_vm_run_at_exit_hooks(rb_vm_t *vm) {
  rb_at_exit_list *l = vm->at_exit;

  while (l) {
    rb_at_exit_list *t = l->next;
    rb_vm_at_exit_func *func = l->func;
    ruby_xfree(l);
    l = t;
    (*func)(vm);
  }
}

static VALUE check_env_value(const rb_env_t *env);

static int check_env(const rb_env_t *env) {
  fprintf(__stderrp, "---\n");
  fprintf(__stderrp, "envptr: %p\n", (void *)&env->ep[0]);
  fprintf(__stderrp, "envval: %10p ", (void *)env->ep[1]);
  ruby_debug_print_value(-1, 0, "", (env->ep[1]));
  fprintf(__stderrp, "ep:    %10p\n", (void *)env->ep);
  if (rb_vm_env_prev_env(env)) {
    fprintf(__stderrp, ">>\n");
    check_env_value(rb_vm_env_prev_env(env));
    fprintf(__stderrp, "<<\n");
  }
  return 1;
}

static VALUE check_env_value(const rb_env_t *env) {
  if (check_env(env)) {
    return (VALUE)env;
  }
  rb_bug("invalid env");
  return ((VALUE)RUBY_Qnil);
}

static VALUE vm_block_handler_escape(const rb_execution_context_t *ec,
                                     VALUE block_handler) {
  switch (vm_block_handler_type(block_handler)) {
  case block_handler_type_ifunc:
  case block_handler_type_iseq:
    return rb_vm_make_proc(ec, VM_BH_TO_CAPT_BLOCK(block_handler), rb_cProc);

  case block_handler_type_symbol:
  case block_handler_type_proc:
    return block_handler;
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qnil);
}

static VALUE vm_make_env_each(const rb_execution_context_t *const ec,
                              rb_control_frame_t *const cfp) {
  const VALUE *const ep = cfp->ep;
  const rb_env_t *env;
  const rb_iseq_t *env_iseq;
  VALUE *env_body, *env_ep;
  int local_size, env_size;

  if (VM_ENV_ESCAPED_P(ep)) {
    return VM_ENV_ENVVAL(ep);
  }

  if (!VM_ENV_LOCAL_P(ep)) {
    const VALUE *prev_ep = VM_ENV_PREV_EP(ep);

    if (!VM_ENV_ESCAPED_P(prev_ep)) {
      rb_control_frame_t *prev_cfp = ((cfp) + 1);

      while (prev_cfp->ep != prev_ep) {
        prev_cfp = ((prev_cfp) + 1);
        ((void)0);
      }

      vm_make_env_each(ec, prev_cfp);
      VM_FORCE_WRITE_SPECIAL_CONST(&ep[(-1)],
                                   ((VALUE)((prev_cfp->ep)) | (0x01)));
    }
  } else {
    VALUE block_handler = VM_ENV_BLOCK_HANDLER(ep);

    if (block_handler != 0) {
      VALUE blockprocval = vm_block_handler_escape(ec, block_handler);
      VM_STACK_ENV_WRITE(ep, (-1), blockprocval);
    }
  }

  if (!VM_FRAME_RUBYFRAME_P(cfp)) {
    local_size = (3);
  } else {
    local_size = cfp->iseq->body->local_table_size + (3);
  }
# 713 "vm.c"
  env_size = local_size + 1;
  env_body = ((VALUE *)ruby_xmalloc2((size_t)(env_size), sizeof(VALUE)));
  __builtin___memcpy_chk((env_body), (ep - (local_size - 1)),
                         sizeof(VALUE) * (size_t)(local_size),
                         __builtin_object_size((env_body), 0));
# 727 "vm.c"
  env_iseq = VM_FRAME_RUBYFRAME_P(cfp) ? cfp->iseq : ((void *)0);
  env_ep = &env_body[local_size - 1];

  env = vm_env_new(env_ep, env_body, env_size, env_iseq);

  cfp->ep = env_ep;
  VM_ENV_FLAGS_SET(env_ep, VM_ENV_FLAG_ESCAPED | VM_ENV_FLAG_WB_REQUIRED);
  VM_STACK_ENV_WRITE(ep, 0, (VALUE)env);
  return (VALUE)env;
}

static VALUE vm_make_env_object(const rb_execution_context_t *ec,
                                rb_control_frame_t *cfp) {
  VALUE envval = vm_make_env_each(ec, cfp);

  if (0) {
    check_env_value((const rb_env_t *)envval);
  }

  return envval;
}

void rb_vm_stack_to_heap(rb_execution_context_t *ec) {
  rb_control_frame_t *cfp = ec->cfp;
  while ((cfp = rb_vm_get_binding_creatable_next_cfp(ec, cfp)) != 0) {
    vm_make_env_object(ec, cfp);
    cfp = ((cfp) + 1);
  }
}

const rb_env_t *rb_vm_env_prev_env(const rb_env_t *env) {
  const VALUE *ep = env->ep;

  if (VM_ENV_LOCAL_P(ep)) {
    return ((void *)0);
  } else {
    return VM_ENV_ENVVAL_PTR(VM_ENV_PREV_EP(ep));
  }
}

static int collect_local_variables_in_iseq(const rb_iseq_t *iseq,
                                           const struct local_var_list *vars) {
  unsigned int i;
  if (!iseq)
    return 0;
  for (i = 0; i < iseq->body->local_table_size; i++) {
    local_var_list_add(vars, iseq->body->local_table[i]);
  }
  return 1;
}

static void collect_local_variables_in_env(const rb_env_t *env,
                                           const struct local_var_list *vars) {
  do {
    collect_local_variables_in_iseq(env->iseq, vars);
  } while ((env = rb_vm_env_prev_env(env)) != ((void *)0));
}

static int
vm_collect_local_variables_in_heap(const VALUE *ep,
                                   const struct local_var_list *vars) {
  if (VM_ENV_ESCAPED_P(ep)) {
    collect_local_variables_in_env(VM_ENV_ENVVAL_PTR(ep), vars);
    return 1;
  } else {
    return 0;
  }
}

VALUE
rb_vm_env_local_variables(const rb_env_t *env) {
  struct local_var_list vars;
  local_var_list_init(&vars);
  collect_local_variables_in_env(env, &vars);
  return local_var_list_finish(&vars);
}

VALUE
rb_iseq_local_variables(const rb_iseq_t *iseq) {
  struct local_var_list vars;
  local_var_list_init(&vars);
  while (collect_local_variables_in_iseq(iseq, &vars)) {
    iseq = iseq->body->parent_iseq;
  }
  return local_var_list_finish(&vars);
}

static VALUE vm_proc_create_from_captured(
    VALUE klass, const struct rb_captured_block *captured,
    enum rb_block_type block_type, int8_t is_from_method, int8_t is_lambda) {
  VALUE procval = rb_proc_alloc(klass);
  rb_proc_t *proc = (((struct RTypedData *)(procval))->data);

  ((void)0);

  __extension__({
# 838 "vm.c"
#pragma clang diagnostic push
# 838 "vm.c"
    ;
# 838 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 838 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(procval),
                        (VALUE *)(&proc->block.as.captured.self),
                        (VALUE)(captured->self), "vm.c", 838))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(procval),
                          (VALUE *)(&proc->block.as.captured.self),
                          (VALUE)(captured->self), "vm.c", 838));
# 838 "vm.c"
#pragma clang diagnostic pop
# 838 "vm.c"
    ;
    unaligned_member_access_result;
  });
  __extension__({
# 839 "vm.c"
#pragma clang diagnostic push
# 839 "vm.c"
    ;
# 839 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 839 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(procval),
                        (VALUE *)(&proc->block.as.captured.code.val),
                        (VALUE)(captured->code.val), "vm.c", 839))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(procval),
                          (VALUE *)(&proc->block.as.captured.code.val),
                          (VALUE)(captured->code.val), "vm.c", 839));
# 839 "vm.c"
#pragma clang diagnostic pop
# 839 "vm.c"
    ;
    unaligned_member_access_result;
  });
  rb_vm_block_ep_update(procval, &proc->block, captured->ep);

  vm_block_type_set(&proc->block, block_type);
  proc->is_from_method = is_from_method;
  proc->is_lambda = is_lambda;

  return procval;
}

void rb_vm_block_copy(VALUE obj, const struct rb_block *dst,
                      const struct rb_block *src) {

  switch (vm_block_type(src)) {
  case block_type_iseq:
  case block_type_ifunc:
    __extension__({
# 856 "vm.c"
#pragma clang diagnostic push
# 856 "vm.c"
      ;
# 856 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 856 "vm.c"
      ;
      typeof(rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.captured.self),
                          (VALUE)(src->as.captured.self), "vm.c", 856))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.captured.self),
                            (VALUE)(src->as.captured.self), "vm.c", 856));
# 856 "vm.c"
#pragma clang diagnostic pop
# 856 "vm.c"
      ;
      unaligned_member_access_result;
    });
    __extension__({
# 857 "vm.c"
#pragma clang diagnostic push
# 857 "vm.c"
      ;
# 857 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 857 "vm.c"
      ;
      typeof(rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.captured.code.val),
                          (VALUE)(src->as.captured.code.val), "vm.c", 857))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.captured.code.val),
                            (VALUE)(src->as.captured.code.val), "vm.c", 857));
# 857 "vm.c"
#pragma clang diagnostic pop
# 857 "vm.c"
      ;
      unaligned_member_access_result;
    });
    rb_vm_block_ep_update(obj, dst, src->as.captured.ep);
    break;
  case block_type_symbol:
    __extension__({
# 861 "vm.c"
#pragma clang diagnostic push
# 861 "vm.c"
      ;
# 861 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 861 "vm.c"
      ;
      typeof(rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.symbol),
                          (VALUE)(src->as.symbol), "vm.c", 861))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.symbol),
                            (VALUE)(src->as.symbol), "vm.c", 861));
# 861 "vm.c"
#pragma clang diagnostic pop
# 861 "vm.c"
      ;
      unaligned_member_access_result;
    });
    break;
  case block_type_proc:
    __extension__({
# 864 "vm.c"
#pragma clang diagnostic push
# 864 "vm.c"
      ;
# 864 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 864 "vm.c"
      ;
      typeof(rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.proc),
                          (VALUE)(src->as.proc), "vm.c", 864))
          unaligned_member_access_result =
              (rb_obj_write((VALUE)(obj), (VALUE *)(&dst->as.proc),
                            (VALUE)(src->as.proc), "vm.c", 864));
# 864 "vm.c"
#pragma clang diagnostic pop
# 864 "vm.c"
      ;
      unaligned_member_access_result;
    });
    break;
  }
}

static VALUE proc_create(VALUE klass, const struct rb_block *block,
                         int8_t is_from_method, int8_t is_lambda) {
  VALUE procval = rb_proc_alloc(klass);
  rb_proc_t *proc = (((struct RTypedData *)(procval))->data);

  ((void)0);
  rb_vm_block_copy(procval, &proc->block, block);
  vm_block_type_set(&proc->block, block->type);
  proc->is_from_method = is_from_method;
  proc->is_lambda = is_lambda;

  return procval;
}

VALUE
rb_proc_dup(VALUE self) {
  VALUE procval;
  rb_proc_t *src;

  (((src)) = (rb_proc_t *)(((struct RData *)(((self))))->data));
  procval =
      proc_create(rb_cProc, &src->block, src->is_from_method, src->is_lambda);
  (*__extension__({
    volatile VALUE *rb_gc_guarded_ptr = &(self);
    __asm__("" : : "m"(rb_gc_guarded_ptr));
    rb_gc_guarded_ptr;
  }));
  return procval;
}

__attribute__((__visibility__("default"))) extern VALUE
rb_vm_make_proc_lambda(const rb_execution_context_t *ec,
                       const struct rb_captured_block *captured, VALUE klass,
                       int8_t is_lambda) {
  VALUE procval;

  if (!VM_ENV_ESCAPED_P(captured->ep)) {
    rb_control_frame_t *cfp = VM_CAPTURED_BLOCK_TO_CFP(captured);
    vm_make_env_object(ec, cfp);
  }
  ((void)0);
  ((void)0);

  procval = vm_proc_create_from_captured(
      klass, captured,
      imemo_type(captured->code.val) == imemo_iseq ? block_type_iseq
                                                   : block_type_ifunc,
      0, is_lambda);
  return procval;
}

VALUE
rb_vm_make_binding(const rb_execution_context_t *ec,
                   const rb_control_frame_t *src_cfp) {
  rb_control_frame_t *cfp = rb_vm_get_binding_creatable_next_cfp(ec, src_cfp);
  rb_control_frame_t *ruby_level_cfp =
      rb_vm_get_ruby_level_next_cfp(ec, src_cfp);
  VALUE bindval, envval;
  rb_binding_t *bind;

  if (cfp == 0 || ruby_level_cfp == 0) {
    rb_raise(rb_eRuntimeError, "Can't create Binding Object on top of Fiber.");
  }

  while (1) {
    envval = vm_make_env_object(ec, cfp);
    if (cfp == ruby_level_cfp) {
      break;
    }
    cfp = rb_vm_get_binding_creatable_next_cfp(ec, ((cfp) + 1));
  }

  bindval = rb_binding_alloc(rb_cBinding);
  (((bind)) = (rb_binding_t *)(((struct RData *)(((bindval))))->data));
  vm_bind_update_env(bindval, bind, envval);
  __extension__({
# 940 "vm.c"
#pragma clang diagnostic push
# 940 "vm.c"
    ;
# 940 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 940 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(bindval),
                        (VALUE *)(&bind->block.as.captured.self),
                        (VALUE)(cfp->self), "vm.c", 940))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(bindval),
                          (VALUE *)(&bind->block.as.captured.self),
                          (VALUE)(cfp->self), "vm.c", 940));
# 940 "vm.c"
#pragma clang diagnostic pop
# 940 "vm.c"
    ;
    unaligned_member_access_result;
  });
  __extension__({
# 941 "vm.c"
#pragma clang diagnostic push
# 941 "vm.c"
    ;
# 941 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 941 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(bindval),
                        (VALUE *)(&bind->block.as.captured.code.iseq),
                        (VALUE)(cfp->iseq), "vm.c", 941))
        unaligned_member_access_result =
            (rb_obj_write((VALUE)(bindval),
                          (VALUE *)(&bind->block.as.captured.code.iseq),
                          (VALUE)(cfp->iseq), "vm.c", 941));
# 941 "vm.c"
#pragma clang diagnostic pop
# 941 "vm.c"
    ;
    unaligned_member_access_result;
  });
  __extension__({
# 942 "vm.c"
#pragma clang diagnostic push
# 942 "vm.c"
    ;
# 942 "vm.c"
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
# 942 "vm.c"
    ;
    typeof(rb_obj_write((VALUE)(bindval), (VALUE *)(&bind->pathobj),
                        (VALUE)(ruby_level_cfp->iseq->body->location.pathobj),
                        "vm.c", 942)) unaligned_member_access_result =
        (rb_obj_write((VALUE)(bindval), (VALUE *)(&bind->pathobj),
                      (VALUE)(ruby_level_cfp->iseq->body->location.pathobj),
                      "vm.c", 942));
# 942 "vm.c"
#pragma clang diagnostic pop
# 942 "vm.c"
    ;
    unaligned_member_access_result;
  });
  bind->first_lineno = rb_vm_get_sourceline(ruby_level_cfp);

  return bindval;
}

const VALUE *rb_binding_add_dynavars(VALUE bindval, rb_binding_t *bind,
                                     int dyncount, const ID *dynvars) {
  VALUE envval, pathobj = bind->pathobj;
  VALUE path = pathobj_path(pathobj);
  VALUE realpath = pathobj_realpath(pathobj);
  const struct rb_block *base_block;
  const rb_env_t *env;
  rb_execution_context_t *ec = rb_current_execution_context();
  const rb_iseq_t *base_iseq, *iseq;
  rb_ast_body_t ast;
  NODE tmp_node;
  ID minibuf[4], *dyns = minibuf;
  VALUE idtmp = 0;

  if (dyncount < 0)
    return 0;

  base_block = &bind->block;
  base_iseq = vm_block_iseq(base_block);

  if (dyncount >= ((int)(sizeof(minibuf) / sizeof((minibuf)[0]))))
    dyns = ((ID *)(((size_t)(dyncount + 1) < 1024 / sizeof(ID))
                       ? ((*__extension__({
                            volatile VALUE *rb_gc_guarded_ptr = &(idtmp);
                            __asm__("" : : "m"(rb_gc_guarded_ptr));
                            rb_gc_guarded_ptr;
                          })) = 0,
                          __builtin_alloca((size_t)(dyncount + 1) * sizeof(ID)))
                       : rb_alloc_tmp_buffer2(&(idtmp), (long)(dyncount + 1),
                                              sizeof(ID))));

  dyns[0] = dyncount;
  __builtin___memcpy_chk((dyns + 1), (dynvars), sizeof(ID) * (size_t)(dyncount),
                         __builtin_object_size((dyns + 1), 0));
  rb_node_init(&tmp_node, NODE_SCOPE, (VALUE)dyns, 0, 0);
  ast.root = &tmp_node;
  ast.compile_option = 0;
  ast.line_count = -1;

  if (base_iseq) {
    iseq = rb_iseq_new(&ast, base_iseq->body->location.label, path, realpath,
                       base_iseq, ISEQ_TYPE_EVAL);
  } else {
    VALUE tempstr = rb_fstring_new(("<temp>"), (sizeof("<temp>"
                                                       "") -
                                                1));
    iseq = rb_iseq_new_top(&ast, tempstr, tempstr, tempstr, ((void *)0));
  }
  tmp_node.u1.tbl = 0;
  rb_free_tmp_buffer(&(idtmp));

  vm_set_eval_stack(ec, iseq, 0, base_block);
  vm_bind_update_env(bindval, bind, envval = vm_make_env_object(ec, ec->cfp));
  rb_vm_pop_frame(ec);

  env = (const rb_env_t *)envval;
  return env->env;
}

static inline VALUE invoke_block(rb_execution_context_t *ec,
                                 const rb_iseq_t *iseq, VALUE self,
                                 const struct rb_captured_block *captured,
                                 const rb_cref_t *cref, VALUE type,
                                 int opt_pc) {
  int arg_size = iseq->body->param.size;

  vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_FINISH, self,
                ((VALUE)((captured->ep)) | (0x01)), (VALUE)cref,
                iseq->body->iseq_encoded + opt_pc, ec->cfp->sp + arg_size,
                iseq->body->local_table_size - arg_size, iseq->body->stack_max);
  return rb_vm_exec(ec, 1);
}

static VALUE invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq,
                            VALUE self,
                            const struct rb_captured_block *captured,
                            const rb_callable_method_entry_t *me, VALUE type,
                            int opt_pc) {

  int arg_size = iseq->body->param.size;
  VALUE ret;

  vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_BMETHOD, self,
                ((VALUE)((captured->ep)) | (0x01)), (VALUE)me,
                iseq->body->iseq_encoded + opt_pc, ec->cfp->sp + arg_size,
                iseq->body->local_table_size - arg_size, iseq->body->stack_max);

  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$method__entry$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$method__entry$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);
  do {
    const rb_event_flag_t flag_arg_ = (0x0008);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, self, me->def->original_id,
                              me->called_id, me->owner, ((VALUE)RUBY_Qnil), 0);
    }
  } while (0);
  VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);
  ret = rb_vm_exec(ec, 1);
  do {
    const rb_event_flag_t flag_arg_ = (0x0010);
    if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
      rb_exec_event_hook_orig(ec, flag_arg_, self, me->def->original_id,
                              me->called_id, me->owner, ret, 0);
    }
  } while (0);
  do {
    if ((__builtin_expect(!!(({
          int _r = __dtrace_isenabled$ruby$method__return$v1();
          __asm__ volatile("");
          _r;
        })),
                          0))) {
      struct ruby_dtrace_method_hook_args args;
      if (rb_dtrace_setup(ec, me->owner, me->def->original_id, &args)) {
        do {
          __asm__ volatile(".reference "
                           "___dtrace_typedefs$ruby$v2");
          __dtrace_probe$ruby$method__return$v1$63686172202a$63686172202a$63686172202a$696e74(
              args.classname, args.methodname, args.filename, args.line_no);
          __asm__ volatile(
              ".reference "
              "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
        } while (0);
      }
    }
  } while (0);
  return ret;
}

__attribute__((__always_inline__)) static inline VALUE invoke_iseq_block_from_c(
    rb_execution_context_t *ec, const struct rb_captured_block *captured,
    VALUE self, int argc, const VALUE *argv, VALUE passed_block_handler,
    const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me);

static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec,
                         const struct rb_captured_block *captured, VALUE self,
                         int argc, const VALUE *argv,
                         VALUE passed_block_handler, const rb_cref_t *cref,
                         int is_lambda, const rb_callable_method_entry_t *me) {
  const rb_iseq_t *iseq = rb_iseq_check(captured->code.iseq);
  int i, opt_pc;
  VALUE type = VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0);
  rb_control_frame_t *cfp = ec->cfp;
  VALUE *sp = cfp->sp;

  stack_check(ec);

  if ((__builtin_expect(
          !!(!(!(1 / !!(sizeof(*((cfp)->sp)) == sizeof(VALUE))) ||
               !(1 / !!(sizeof(*(cfp)) == sizeof(rb_control_frame_t))) ||
               ((rb_control_frame_t *)(((cfp)->sp) + (argc)) + 1) >= (cfp))),
          1))) {
    (void)0;
  } else
    vm_stackoverflow();
  cfp->sp = sp + argc;
  for (i = 0; i < argc; i++) {
    sp[i] = argv[i];
  }

  opt_pc =
      vm_yield_setup_args(ec, iseq, argc, sp, passed_block_handler,
                          (is_lambda ? arg_setup_method : arg_setup_block));
  cfp->sp = sp;

  if (me == ((void *)0)) {
    return invoke_block(ec, iseq, self, captured, cref, type, opt_pc);
  } else {
    return invoke_bmethod(ec, iseq, self, captured, me, type, opt_pc);
  }
}

static inline VALUE invoke_block_from_c_bh(rb_execution_context_t *ec,
                                           VALUE block_handler, int argc,
                                           const VALUE *argv,
                                           VALUE passed_block_handler,
                                           const rb_cref_t *cref, int is_lambda,
                                           int force_blockarg) {
again:
  switch (vm_block_handler_type(block_handler)) {
  case block_handler_type_iseq: {
    const struct rb_captured_block *captured =
        VM_BH_TO_ISEQ_BLOCK(block_handler);
    return invoke_iseq_block_from_c(ec, captured, captured->self, argc, argv,
                                    passed_block_handler, cref, is_lambda,
                                    ((void *)0));
  }
  case block_handler_type_ifunc:
    return vm_yield_with_cfunc(ec, VM_BH_TO_IFUNC_BLOCK(block_handler),
                               VM_BH_TO_IFUNC_BLOCK(block_handler)->self, argc,
                               argv, passed_block_handler, ((void *)0));
  case block_handler_type_symbol:
    return vm_yield_with_symbol(ec, VM_BH_TO_SYMBOL(block_handler), argc, argv,
                                passed_block_handler);
  case block_handler_type_proc:
    if (force_blockarg == 0) {
      is_lambda = block_proc_is_lambda(VM_BH_TO_PROC(block_handler));
    }
    block_handler = vm_proc_to_block_handler(VM_BH_TO_PROC(block_handler));
    goto again;
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qundef);
}

static inline VALUE check_block_handler(rb_execution_context_t *ec) {
  VALUE block_handler = VM_CF_BLOCK_HANDLER(ec->cfp);
  vm_block_handler_verify(block_handler);
  if ((__builtin_expect(!!(block_handler == 0), 0))) {
    rb_vm_localjump_error("no block given", ((VALUE)RUBY_Qnil), 0);
  }

  return block_handler;
}

static VALUE vm_yield_with_cref(rb_execution_context_t *ec, int argc,
                                const VALUE *argv, const rb_cref_t *cref,
                                int is_lambda) {
  return invoke_block_from_c_bh(ec, check_block_handler(ec), argc, argv, 0,
                                cref, is_lambda, 0);
}

static VALUE vm_yield(rb_execution_context_t *ec, int argc, const VALUE *argv) {
  return invoke_block_from_c_bh(ec, check_block_handler(ec), argc, argv, 0,
                                ((void *)0), 0, 0);
}

static VALUE vm_yield_with_block(rb_execution_context_t *ec, int argc,
                                 const VALUE *argv, VALUE block_handler) {
  return invoke_block_from_c_bh(ec, check_block_handler(ec), argc, argv,
                                block_handler, ((void *)0), 0, 0);
}

static VALUE vm_yield_force_blockarg(rb_execution_context_t *ec, VALUE args) {
  return invoke_block_from_c_bh(ec, check_block_handler(ec), 1, &args, 0,
                                ((void *)0), 0, 1);
}

__attribute__((__always_inline__)) static inline VALUE
invoke_block_from_c_proc(rb_execution_context_t *ec, const rb_proc_t *proc,
                         VALUE self, int argc, const VALUE *argv,
                         VALUE passed_block_handler, int is_lambda,
                         const rb_callable_method_entry_t *me);

static inline VALUE
invoke_block_from_c_proc(rb_execution_context_t *ec, const rb_proc_t *proc,
                         VALUE self, int argc, const VALUE *argv,
                         VALUE passed_block_handler, int is_lambda,
                         const rb_callable_method_entry_t *me) {
  const struct rb_block *block = &proc->block;

again:
  switch (vm_block_type(block)) {
  case block_type_iseq:
    return invoke_iseq_block_from_c(ec, &block->as.captured, self, argc, argv,
                                    passed_block_handler, ((void *)0),
                                    is_lambda, me);
  case block_type_ifunc:
    return vm_yield_with_cfunc(ec, &block->as.captured, self, argc, argv,
                               passed_block_handler, me);
  case block_type_symbol:
    return vm_yield_with_symbol(ec, block->as.symbol, argc, argv,
                                passed_block_handler);
  case block_type_proc:
    is_lambda = block_proc_is_lambda(block->as.proc);
    block = vm_proc_block(block->as.proc);
    goto again;
  }
  __builtin_unreachable();
  return ((VALUE)RUBY_Qundef);
}

static VALUE vm_invoke_proc(rb_execution_context_t *ec, rb_proc_t *proc,
                            VALUE self, int argc, const VALUE *argv,
                            VALUE passed_block_handler) {
  return invoke_block_from_c_proc(ec, proc, self, argc, argv,
                                  passed_block_handler, proc->is_lambda,
                                  ((void *)0));
}

__attribute__((__visibility__("default"))) extern VALUE
rb_vm_invoke_bmethod(rb_execution_context_t *ec, rb_proc_t *proc, VALUE self,
                     int argc, const VALUE *argv, VALUE block_handler,
                     const rb_callable_method_entry_t *me) {
  return invoke_block_from_c_proc(ec, proc, self, argc, argv, block_handler, 1,
                                  me);
}

__attribute__((__visibility__("default"))) extern VALUE
rb_vm_invoke_proc(rb_execution_context_t *ec, rb_proc_t *proc, int argc,
                  const VALUE *argv, VALUE passed_block_handler) {
  VALUE self = vm_block_self(&proc->block);
  vm_block_handler_verify(passed_block_handler);

  if (proc->is_from_method) {
    return rb_vm_invoke_bmethod(ec, proc, self, argc, argv,
                                passed_block_handler, ((void *)0));
  } else {
    return vm_invoke_proc(ec, proc, self, argc, argv, passed_block_handler);
  }
}

static rb_control_frame_t *vm_normal_frame(const rb_execution_context_t *ec,
                                           rb_control_frame_t *cfp) {
  while (cfp->pc == 0) {
    cfp = ((cfp) + 1);
    if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, cfp)) {
      return 0;
    }
  }
  return cfp;
}

static VALUE vm_cfp_svar_get(const rb_execution_context_t *ec,
                             rb_control_frame_t *cfp, VALUE key) {
  cfp = vm_normal_frame(ec, cfp);
  return lep_svar_get(ec, cfp ? VM_CF_LEP(cfp) : 0, key);
}

static void vm_cfp_svar_set(const rb_execution_context_t *ec,
                            rb_control_frame_t *cfp, VALUE key,
                            const VALUE val) {
  cfp = vm_normal_frame(ec, cfp);
  lep_svar_set(ec, cfp ? VM_CF_LEP(cfp) : 0, key, val);
}

static VALUE vm_svar_get(const rb_execution_context_t *ec, VALUE key) {
  return vm_cfp_svar_get(ec, ec->cfp, key);
}

static void vm_svar_set(const rb_execution_context_t *ec, VALUE key,
                        VALUE val) {
  vm_cfp_svar_set(ec, ec->cfp, key, val);
}

VALUE
rb_backref_get(void) {
  return vm_svar_get(rb_current_execution_context(), VM_SVAR_BACKREF);
}

void rb_backref_set(VALUE val) {
  vm_svar_set(rb_current_execution_context(), VM_SVAR_BACKREF, val);
}

VALUE
rb_lastline_get(void) {
  return vm_svar_get(rb_current_execution_context(), VM_SVAR_LASTLINE);
}

void rb_lastline_set(VALUE val) {
  vm_svar_set(rb_current_execution_context(), VM_SVAR_LASTLINE, val);
}

const char *rb_sourcefile(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (cfp) {
    return (
        !(((struct RBasic *)(rb_iseq_path(cfp->iseq)))->flags & RSTRING_NOEMBED)
            ? ((struct RString *)(rb_iseq_path(cfp->iseq)))->as.ary
            : ((struct RString *)(rb_iseq_path(cfp->iseq)))->as.heap.ptr);
  } else {
    return 0;
  }
}

int rb_sourceline(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (cfp) {
    return rb_vm_get_sourceline(cfp);
  } else {
    return 0;
  }
}

VALUE
rb_source_location(int *pline) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (cfp && cfp->iseq) {
    if (pline)
      *pline = rb_vm_get_sourceline(cfp);
    return rb_iseq_path(cfp->iseq);
  } else {
    if (pline)
      *pline = 0;
    return ((VALUE)RUBY_Qnil);
  }
}

__attribute__((__visibility__("default"))) extern const char *
rb_source_location_cstr(int *pline) {
  VALUE path = rb_source_location(pline);
  if (!((VALUE)(path) != ((VALUE)RUBY_Qnil)))
    return ((void *)0);
  return (!(((struct RBasic *)(path))->flags & RSTRING_NOEMBED)
              ? ((struct RString *)(path))->as.ary
              : ((struct RString *)(path))->as.heap.ptr);
}

rb_cref_t *rb_vm_cref(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (cfp == ((void *)0)) {
    return ((void *)0);
  }
  return rb_vm_get_cref(cfp->ep);
}

rb_cref_t *rb_vm_cref_replace_with_duplicated_cref(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);
  rb_cref_t *cref = vm_cref_replace_with_duplicated_cref(cfp->ep);
  return cref;
}

const rb_cref_t *rb_vm_cref_in_context(VALUE self, VALUE cbase) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);
  const rb_cref_t *cref;
  if (cfp->self != self)
    return ((void *)0);
  if (!vm_env_cref_by_cref(cfp->ep))
    return ((void *)0);
  cref = rb_vm_get_cref(cfp->ep);
  if (CREF_CLASS(cref) != cbase)
    return ((void *)0);
  return cref;
}
# 1374 "vm.c"
VALUE
rb_vm_cbase(void) {
  const rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec->cfp);

  if (cfp == 0) {
    rb_raise(rb_eRuntimeError, "Can't call on top of Fiber or Thread");
  }
  return vm_get_cbase(cfp->ep);
}

static VALUE make_localjump_error(const char *mesg, VALUE value, int reason) {
  extern VALUE rb_eLocalJumpError;
  VALUE exc = __extension__({
    (__builtin_constant_p(mesg))
        ? rb_exc_new((rb_eLocalJumpError), (mesg), (long)strlen(mesg))
        : rb_exc_new_cstr((rb_eLocalJumpError), (mesg));
  });
  ID id;

  switch (reason) {
  case RUBY_TAG_BREAK:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache = rb_intern2((("break")), (long)strlen(("break")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  case RUBY_TAG_REDO:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache = rb_intern2((("redo")), (long)strlen(("redo")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  case RUBY_TAG_RETRY:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache = rb_intern2((("retry")), (long)strlen(("retry")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  case RUBY_TAG_NEXT:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache = rb_intern2((("next")), (long)strlen(("next")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  case RUBY_TAG_RETURN:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache = rb_intern2((("return")), (long)strlen(("return")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  default:
    do {
      static ID rb_intern_id_cache;
      if (!rb_intern_id_cache)
        rb_intern_id_cache =
            rb_intern2((("noreason")), (long)strlen(("noreason")));
      (id) = rb_intern_id_cache;
    } while (0);
    break;
  }
  rb_iv_set(exc, "@exit_value", value);
  rb_iv_set(exc, "@reason", (rb_id2sym(id)));
  return exc;
}

__attribute__((__visibility__("default"))) extern void
rb_vm_localjump_error(const char *mesg, VALUE value, int reason) {
  VALUE exc = make_localjump_error(mesg, value, reason);
  rb_exc_raise(exc);
}

VALUE
rb_vm_make_jump_tag_but_local_jump(int state, VALUE val) {
  const char *mesg;

  switch (state) {
  case RUBY_TAG_RETURN:
    mesg = "unexpected return";
    break;
  case RUBY_TAG_BREAK:
    mesg = "unexpected break";
    break;
  case RUBY_TAG_NEXT:
    mesg = "unexpected next";
    break;
  case RUBY_TAG_REDO:
    mesg = "unexpected redo";
    val = ((VALUE)RUBY_Qnil);
    break;
  case RUBY_TAG_RETRY:
    mesg = "retry outside of rescue clause";
    val = ((VALUE)RUBY_Qnil);
    break;
  default:
    return ((VALUE)RUBY_Qnil);
  }
  if (val == ((VALUE)RUBY_Qundef)) {
    val = rb_current_execution_context()->tag->retval;
  }
  return make_localjump_error(mesg, val, state);
}
# 1469 "vm.c"
static rb_control_frame_t *next_not_local_frame(rb_control_frame_t *cfp) {
  while (VM_ENV_LOCAL_P(cfp->ep)) {
    cfp = ((cfp) + 1);
  }
  return cfp;
}

__attribute__((__noreturn__)) static void
vm_iter_break(rb_execution_context_t *ec, VALUE val);

static void vm_iter_break(rb_execution_context_t *ec, VALUE val) {
  rb_control_frame_t *cfp = next_not_local_frame(ec->cfp);
  const VALUE *ep = VM_CF_PREV_EP(cfp);
  const rb_control_frame_t *target_cfp = rb_vm_search_cf_from_ep(ec, cfp, ep);

  ec->errinfo = (VALUE)THROW_DATA_NEW(val, target_cfp, RUBY_TAG_BREAK);
  rb_ec_tag_jump(ec, RUBY_TAG_BREAK);
}

void rb_iter_break(void) {
  vm_iter_break(rb_current_execution_context(), ((VALUE)RUBY_Qnil));
}

void rb_iter_break_value(VALUE val) {
  vm_iter_break(rb_current_execution_context(), val);
}

static st_table *vm_opt_method_table = 0;

static int vm_redefinition_check_flag(VALUE klass) {
  if (klass == rb_cInteger)
    return (1 << 0);
  if (klass == rb_cFloat)
    return (1 << 1);
  if (klass == rb_cString)
    return (1 << 2);
  if (klass == rb_cArray)
    return (1 << 3);
  if (klass == rb_cHash)
    return (1 << 4);
  if (klass == rb_cSymbol)
    return (1 << 6);
  if (klass == rb_cTime)
    return (1 << 7);
  if (klass == rb_cRegexp)
    return (1 << 8);
  if (klass == rb_cNilClass)
    return (1 << 9);
  if (klass == rb_cTrueClass)
    return (1 << 10);
  if (klass == rb_cFalseClass)
    return (1 << 11);
  if (klass == rb_cProc)
    return (1 << 12);
  return 0;
}

static int
vm_redefinition_check_method_type(const rb_method_definition_t *def) {
  switch (def->type) {
  case VM_METHOD_TYPE_CFUNC:
  case VM_METHOD_TYPE_OPTIMIZED:
    return 1;
  default:
    return 0;
  }
}

static void rb_vm_check_redefinition_opt_method(const rb_method_entry_t *me,
                                                VALUE klass) {
  st_data_t bop;
  if ((((RUBY_T_ICLASS) == RUBY_T_FIXNUM)
           ? (((int)(long)(klass)) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_ICLASS) == RUBY_T_TRUE)
                 ? ((klass) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_ICLASS) == RUBY_T_FALSE)
                       ? ((klass) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_ICLASS) == RUBY_T_NIL)
                             ? ((klass) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_ICLASS) == RUBY_T_UNDEF)
                                   ? ((klass) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_ICLASS) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)(klass) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)(
                                                   klass)&RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)(klass) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)(klass))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_ICLASS) == RUBY_T_FLOAT)
                                               ? (((((int)(long)(klass)) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)(
                                                         klass)&RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)(klass) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic
                                                               *)(klass))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)(
                                                        klass)&RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)(klass) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic
                                                              *)(klass))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_ICLASS))) &&
      ((!(((VALUE)(klass)&RUBY_IMMEDIATE_MASK) ||
          !!(((VALUE)(klass) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
        (int)(((struct RBasic *)(klass))->flags & RUBY_T_MASK) != RUBY_T_NODE)
           ? (((struct RBasic *)((klass)))->flags & ((((VALUE)RUBY_FL_USER5))))
           : 0)) {
    klass = (((struct RBasic *)(klass))->klass);
  }
  if (vm_redefinition_check_method_type(me->def)) {
    if (st_lookup(vm_opt_method_table, (st_data_t)me, &bop)) {
      int flag = vm_redefinition_check_flag(klass);

      rb_current_vm()->redefined_flag[bop] |= flag;
    }
  }
}

static enum rb_id_table_iterator_result
check_redefined_method(ID mid, VALUE value, void *data) {
  VALUE klass = (VALUE)data;
  const rb_method_entry_t *me = (rb_method_entry_t *)value;
  const rb_method_entry_t *newme = rb_method_entry(klass, mid);

  if (newme != me)
    rb_vm_check_redefinition_opt_method(me, me->owner);

  return ID_TABLE_CONTINUE;
}

void rb_vm_check_redefinition_by_prepend(VALUE klass) {
  if (!vm_redefinition_check_flag(klass))
    return;
  rb_id_table_foreach(
      (((struct RClass *)(((((struct RClass *)(klass))->ptr)->origin_)))
           ->m_tbl),
      check_redefined_method, (void *)klass);
}

static void add_opt_method(VALUE klass, ID mid, VALUE bop) {
  const rb_method_entry_t *me = rb_method_entry_at(klass, mid);

  if (me && vm_redefinition_check_method_type(me->def)) {
    st_insert(vm_opt_method_table, (st_data_t)me, (st_data_t)bop);
  } else {
    rb_bug("undefined optimized method: %s", rb_id2name(mid));
  }
}

static void vm_init_redefined_flag(void) {
  ID mid;
  VALUE bop;

  vm_opt_method_table = st_init_numtable();

  (mid = idPLUS, bop = BOP_PLUS, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cArray, mid, bop));
  (mid = idMINUS, bop = BOP_MINUS, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idMULT, bop = BOP_MULT, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idDIV, bop = BOP_DIV, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idMOD, bop = BOP_MOD, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idEq, bop = BOP_EQ, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cSymbol, mid, bop));
  (mid = idEqq, bop = BOP_EQQ, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop),
       add_opt_method(rb_cSymbol, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cNilClass, mid, bop),
       add_opt_method(rb_cTrueClass, mid, bop),
       add_opt_method(rb_cFalseClass, mid, bop));
  (mid = idLT, bop = BOP_LT, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idLE, bop = BOP_LE, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idGT, bop = BOP_GT, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idGE, bop = BOP_GE, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cFloat, mid, bop));
  (mid = idLTLT, bop = BOP_LTLT, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cArray, mid, bop));
  (mid = idAREF, bop = BOP_AREF, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop), add_opt_method(rb_cHash, mid, bop));
  (mid = idASET, bop = BOP_ASET, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop), add_opt_method(rb_cHash, mid, bop));
  (mid = idLength, bop = BOP_LENGTH, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cHash, mid, bop));
  (mid = idSize, bop = BOP_SIZE, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cHash, mid, bop));
  (mid = idEmptyP, bop = BOP_EMPTY_P, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cHash, mid, bop));
  (mid = idSucc, bop = BOP_SUCC, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop),
       add_opt_method(rb_cString, mid, bop),
       add_opt_method(rb_cTime, mid, bop));
  (mid = idEqTilde, bop = BOP_MATCH, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cRegexp, mid, bop),
       add_opt_method(rb_cString, mid, bop));
  (mid = idFreeze, bop = BOP_FREEZE, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cString, mid, bop));
  (mid = idUMinus, bop = BOP_UMINUS, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cString, mid, bop));
  (mid = idMax, bop = BOP_MAX, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop));
  (mid = idMin, bop = BOP_MIN, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cArray, mid, bop));
  (mid = idCall, bop = BOP_CALL, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cProc, mid, bop));
  (mid = idAnd, bop = BOP_AND, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop));
  (mid = idOr, bop = BOP_OR, rb_current_vm()->redefined_flag[bop] = 0),
      (add_opt_method(rb_cInteger, mid, bop));
}
# 1653 "vm.c"
static VALUE frame_return_value(const struct vm_throw_data *err) {
  if ((((RUBY_T_IMEMO) == RUBY_T_FIXNUM)
           ? (((int)(long)((VALUE)(err))) & RUBY_FIXNUM_FLAG)
           : ((RUBY_T_IMEMO) == RUBY_T_TRUE)
                 ? (((VALUE)(err)) == ((VALUE)RUBY_Qtrue))
                 : ((RUBY_T_IMEMO) == RUBY_T_FALSE)
                       ? (((VALUE)(err)) == ((VALUE)RUBY_Qfalse))
                       : ((RUBY_T_IMEMO) == RUBY_T_NIL)
                             ? (((VALUE)(err)) == ((VALUE)RUBY_Qnil))
                             : ((RUBY_T_IMEMO) == RUBY_T_UNDEF)
                                   ? (((VALUE)(err)) == ((VALUE)RUBY_Qundef))
                                   : ((RUBY_T_IMEMO) == RUBY_T_SYMBOL)
                                         ? ((((VALUE)((VALUE)(err)) &
                                              ~((~(VALUE)0)
                                                << RUBY_SPECIAL_SHIFT)) ==
                                             RUBY_SYMBOL_FLAG) ||
                                            (!(((VALUE)((VALUE)(err)) &
                                                RUBY_IMMEDIATE_MASK) ||
                                               !!(((VALUE)((VALUE)(err)) &
                                                   (VALUE) ~(
                                                       (VALUE)RUBY_Qnil)) ==
                                                  0)) &&
                                             (int)(((struct RBasic *)((VALUE)(
                                                        err)))
                                                       ->flags &
                                                   RUBY_T_MASK) ==
                                                 (RUBY_T_SYMBOL)))
                                         : ((RUBY_T_IMEMO) == RUBY_T_FLOAT)
                                               ? (((((int)(long)((VALUE)(
                                                        err))) &
                                                    RUBY_FLONUM_MASK) ==
                                                   RUBY_FLONUM_FLAG) ||
                                                  (!(((VALUE)((VALUE)(err)) &
                                                      RUBY_IMMEDIATE_MASK) ||
                                                     !!(((VALUE)((VALUE)(err)) &
                                                         (VALUE) ~(
                                                             (VALUE)
                                                                 RUBY_Qnil)) ==
                                                        0)) &&
                                                   (int)(((struct RBasic *)((
                                                              VALUE)(err)))
                                                             ->flags &
                                                         RUBY_T_MASK) ==
                                                       RUBY_T_FLOAT))
                                               : (!(((VALUE)((VALUE)(err)) &
                                                     RUBY_IMMEDIATE_MASK) ||
                                                    !!(((VALUE)((VALUE)(err)) &
                                                        (VALUE) ~((
                                                            VALUE)RUBY_Qnil)) ==
                                                       0)) &&
                                                  (int)(((struct RBasic *)((
                                                             VALUE)(err)))
                                                            ->flags &
                                                        RUBY_T_MASK) ==
                                                      (RUBY_T_IMEMO))) &&
      THROW_DATA_STATE(err) == RUBY_TAG_BREAK &&
      THROW_DATA_CONSUMED_P(err) == 0) {
    return THROW_DATA_VAL(err);
  } else {
    return ((VALUE)RUBY_Qnil);
  }
}
# 1689 "vm.c"
static void hook_before_rewind(rb_execution_context_t *ec,
                               const rb_control_frame_t *cfp,
                               int will_finish_vm_exec, int state,
                               struct vm_throw_data *err) {
  if (state == RUBY_TAG_RAISE &&
      (((struct RBasic *)(err))->klass) == rb_eSysStackError) {
    return;
  }
  switch (VM_FRAME_TYPE(ec->cfp)) {
  case VM_FRAME_MAGIC_METHOD:
    do {
      if ((__builtin_expect(!!(({
            int _r = __dtrace_isenabled$ruby$method__return$v1();
            __asm__ volatile("");
            _r;
          })),
                            0))) {
        struct ruby_dtrace_method_hook_args args;
        if (rb_dtrace_setup(ec, 0, 0, &args)) {
          do {
            __asm__ volatile(".reference "
                             "___dtrace_typedefs$ruby$v2");
            __dtrace_probe$ruby$method__return$v1$63686172202a$63686172202a$63686172202a$696e74(
                args.classname, args.methodname, args.filename, args.line_no);
            __asm__ volatile(
                ".reference "
                "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_5_5_5_5_5_5_5");
          } while (0);
        }
      }
    } while (0);
    do {
      const rb_event_flag_t flag_arg_ = (0x0010);
      if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
        rb_exec_event_hook_orig(ec, flag_arg_, ec->cfp->self, 0, 0, 0,
                                frame_return_value(err), 1);
      }
    } while (0);
    THROW_DATA_CONSUMED_SET(err);
    break;
  case VM_FRAME_MAGIC_BLOCK:
    if (VM_FRAME_BMETHOD_P(ec->cfp)) {
      do {
        const rb_event_flag_t flag_arg_ = (0x0200);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, ec->cfp->self, 0, 0, 0,
                                  frame_return_value(err), 0);
        }
      } while (0);

      if (!will_finish_vm_exec) {

        do {
          const rb_event_flag_t flag_arg_ = (0x0010);
          if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
            rb_exec_event_hook_orig(
                ec, flag_arg_, ec->cfp->self,
                rb_vm_frame_method_entry(ec->cfp)->def->original_id,
                rb_vm_frame_method_entry(ec->cfp)->called_id,
                rb_vm_frame_method_entry(ec->cfp)->owner,
                frame_return_value(err), 1);
          }
        } while (0);
      }
      THROW_DATA_CONSUMED_SET(err);
    } else {
      do {
        const rb_event_flag_t flag_arg_ = (0x0200);
        if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
          rb_exec_event_hook_orig(ec, flag_arg_, ec->cfp->self, 0, 0, 0,
                                  frame_return_value(err), 1);
        }
      } while (0);
      THROW_DATA_CONSUMED_SET(err);
    }
    break;
  case VM_FRAME_MAGIC_CLASS:
    do {
      const rb_event_flag_t flag_arg_ = (0x0004);
      if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
        rb_exec_event_hook_orig(ec, flag_arg_, ec->cfp->self, 0, 0, 0,
                                ((VALUE)RUBY_Qnil), 1);
      }
    } while (0);
    break;
  }
}
# 1809 "vm.c"
static inline VALUE vm_exec_handle_exception(rb_execution_context_t *ec,
                                             enum ruby_tag_type state,
                                             VALUE errinfo, VALUE *initial);

__attribute__((__visibility__("default"))) extern VALUE
rb_vm_exec(rb_execution_context_t *ec, int mjit_enable_p) {
  enum ruby_tag_type state;
  VALUE result = ((VALUE)RUBY_Qundef);
  VALUE initial = 0;

  do {
    rb_execution_context_t *const _ec = (ec);
    struct rb_vm_tag _tag;
    _tag.state = RUBY_TAG_NONE;
    _tag.tag = ((VALUE)RUBY_Qundef);
    _tag.prev = _ec->tag;
    ;

    _tag.retval = ((VALUE)RUBY_Qnil);
    if ((state = (sigsetjmp((_tag.buf), 0)
                      ? rb_ec_tag_state(
                            __extension__(*(__typeof__(_ec) volatile *)&(_ec)))
                      : ((void)(_ec->tag = &_tag), 0))) == RUBY_TAG_NONE) {
      if (!mjit_enable_p || (result = mjit_exec(ec)) == ((VALUE)RUBY_Qundef)) {
        result = vm_exec_core(ec, initial);
      }
      goto vm_loop_start;
    } else {
      result = ec->errinfo;
      ((ec)->raised_flag &= ~(RAISED_STACKOVERFLOW));
      while ((result = vm_exec_handle_exception(ec, state, result, &initial)) ==
             ((VALUE)RUBY_Qundef)) {

        result = vm_exec_core(ec, initial);
      vm_loop_start:
        ((void)0);

        if ((state = _tag.state) == RUBY_TAG_NONE)
          break;
        _tag.state = RUBY_TAG_NONE;
      }
    }
    _ec->tag = _tag.prev;
  } while (0);
  return result;
}

static inline VALUE vm_exec_handle_exception(rb_execution_context_t *ec,
                                             enum ruby_tag_type state,
                                             VALUE errinfo, VALUE *initial) {
  struct vm_throw_data *err = (struct vm_throw_data *)errinfo;

  for (;;) {
    unsigned int i;
    const struct iseq_catch_table_entry *entry;
    const struct iseq_catch_table *ct;
    unsigned long epc, cont_pc, cont_sp;
    const rb_iseq_t *catch_iseq;
    rb_control_frame_t *cfp;
    VALUE type;
    const rb_control_frame_t *escape_cfp;

    cont_pc = cont_sp = 0;
    catch_iseq = ((void *)0);

    while (ec->cfp->pc == 0 || ec->cfp->iseq == 0) {
      if ((__builtin_expect(!!(VM_FRAME_TYPE(ec->cfp) == VM_FRAME_MAGIC_CFUNC),
                            0))) {
        do {
          const rb_event_flag_t flag_arg_ = (0x0040);
          if ((__builtin_expect(!!(ruby_vm_event_flags & (flag_arg_)), 0))) {
            rb_exec_event_hook_orig(
                ec, flag_arg_, ec->cfp->self,
                rb_vm_frame_method_entry(ec->cfp)->def->original_id,
                rb_vm_frame_method_entry(ec->cfp)->called_id,
                rb_vm_frame_method_entry(ec->cfp)->owner, ((VALUE)RUBY_Qnil),
                1);
          }
        } while (0);

        do {
          if ((__builtin_expect(!!(({
                int _r = __dtrace_isenabled$ruby$cmethod__return$v1();
                __asm__ volatile("");
                _r;
              })),
                                0))) {
            struct ruby_dtrace_method_hook_args args;
            if (rb_dtrace_setup(
                    ec, rb_vm_frame_method_entry(ec->cfp)->owner,
                    rb_vm_frame_method_entry(ec->cfp)->def->original_id,
                    &args)) {
              do {
                __asm__ volatile(".reference "
                                 "___dtrace_typedefs$ruby$v2");
                __dtrace_probe$ruby$cmethod__return$v1$63686172202a$63686172202a$63686172202a$696e74(
                    args.classname, args.methodname, args.filename,
                    args.line_no);
                __asm__ volatile(".reference "
                                 "___dtrace_stability$ruby$v1$6_5_5_6_5_5_6_5_"
                                 "5_5_5_5_5_5_5");
              } while (0);
            }
          }
        } while (0);
      }
      rb_vm_pop_frame(ec);
    }

    cfp = ec->cfp;
    epc = cfp->pc - cfp->iseq->body->iseq_encoded;

    escape_cfp = ((void *)0);
    if (state == RUBY_TAG_BREAK || state == RUBY_TAG_RETURN) {
      escape_cfp = THROW_DATA_CATCH_FRAME(err);

      if (cfp == escape_cfp) {
        if (state == RUBY_TAG_RETURN) {
          if (!VM_FRAME_FINISHED_P(cfp)) {
            THROW_DATA_CATCH_FRAME_SET(err, cfp + 1);
            THROW_DATA_STATE_SET(err, state = RUBY_TAG_BREAK);
          } else {
            ct = cfp->iseq->body->catch_table;
            if (ct)
              for (i = 0; i < ct->size; i++) {
                entry = &ct->entries[i];
                if (entry->start < epc && entry->end >= epc) {
                  if (entry->type == CATCH_TYPE_ENSURE) {
                    catch_iseq = entry->iseq;
                    cont_pc = entry->cont;
                    cont_sp = entry->sp;
                    break;
                  }
                }
              }
            if (catch_iseq == ((void *)0)) {
              ec->errinfo = ((VALUE)RUBY_Qnil);
              THROW_DATA_CATCH_FRAME_SET(err, cfp + 1);
              hook_before_rewind(ec, ec->cfp, 1, state, err);
              rb_vm_pop_frame(ec);
              return THROW_DATA_VAL(err);
            }
          }

        } else {

          *ec->cfp->sp++ = THROW_DATA_VAL(err);

          ec->errinfo = ((VALUE)RUBY_Qnil);
          return ((VALUE)RUBY_Qundef);
        }
      }
    }

    if (state == RUBY_TAG_RAISE) {
      ct = cfp->iseq->body->catch_table;
      if (ct)
        for (i = 0; i < ct->size; i++) {
          entry = &ct->entries[i];
          if (entry->start < epc && entry->end >= epc) {

            if (entry->type == CATCH_TYPE_RESCUE ||
                entry->type == CATCH_TYPE_ENSURE) {
              catch_iseq = entry->iseq;
              cont_pc = entry->cont;
              cont_sp = entry->sp;
              break;
            }
          }
        }
    } else if (state == RUBY_TAG_RETRY) {
      ct = cfp->iseq->body->catch_table;
      if (ct)
        for (i = 0; i < ct->size; i++) {
          entry = &ct->entries[i];
          if (entry->start < epc && entry->end >= epc) {

            if (entry->type == CATCH_TYPE_ENSURE) {
              catch_iseq = entry->iseq;
              cont_pc = entry->cont;
              cont_sp = entry->sp;
              break;
            } else if (entry->type == CATCH_TYPE_RETRY) {
              const rb_control_frame_t *escape_cfp;
              escape_cfp = THROW_DATA_CATCH_FRAME(err);
              if (cfp == escape_cfp) {
                cfp->pc = cfp->iseq->body->iseq_encoded + entry->cont;
                ec->errinfo = ((VALUE)RUBY_Qnil);
                return ((VALUE)RUBY_Qundef);
              }
            }
          }
        }
    } else if (state == RUBY_TAG_BREAK && !escape_cfp) {
      type = CATCH_TYPE_BREAK;

    search_restart_point:
      ct = cfp->iseq->body->catch_table;
      if (ct)
        for (i = 0; i < ct->size; i++) {
          entry = &ct->entries[i];

          if (entry->start < epc && entry->end >= epc) {
            if (entry->type == CATCH_TYPE_ENSURE) {
              catch_iseq = entry->iseq;
              cont_pc = entry->cont;
              cont_sp = entry->sp;
              break;
            } else if (entry->type == type) {
              cfp->pc = cfp->iseq->body->iseq_encoded + entry->cont;
              cfp->sp = vm_base_ptr(cfp) + entry->sp;

              if (state != RUBY_TAG_REDO) {

                *ec->cfp->sp++ = THROW_DATA_VAL(err);
              }
              ec->errinfo = ((VALUE)RUBY_Qnil);
              ((void)0);
              return ((VALUE)RUBY_Qundef);
            }
          }
        }
    } else if (state == RUBY_TAG_REDO) {
      type = CATCH_TYPE_REDO;
      goto search_restart_point;
    } else if (state == RUBY_TAG_NEXT) {
      type = CATCH_TYPE_NEXT;
      goto search_restart_point;
    } else {
      ct = cfp->iseq->body->catch_table;
      if (ct)
        for (i = 0; i < ct->size; i++) {
          entry = &ct->entries[i];
          if (entry->start < epc && entry->end >= epc) {

            if (entry->type == CATCH_TYPE_ENSURE) {
              catch_iseq = entry->iseq;
              cont_pc = entry->cont;
              cont_sp = entry->sp;
              break;
            }
          }
        }
    }

    if (catch_iseq != ((void *)0)) {

      const int arg_size = 1;

      rb_iseq_check(catch_iseq);
      cfp->sp = vm_base_ptr(cfp) + cont_sp;
      cfp->pc = cfp->iseq->body->iseq_encoded + cont_pc;

      cfp->sp[0] = (VALUE)err;
      vm_push_frame(ec, catch_iseq, VM_FRAME_MAGIC_RESCUE, cfp->self,
                    ((VALUE)((cfp->ep)) | (0x01)), 0,
                    catch_iseq->body->iseq_encoded, cfp->sp + arg_size,
                    catch_iseq->body->local_table_size - arg_size,
                    catch_iseq->body->stack_max);

      state = 0;
      ec->tag->state = RUBY_TAG_NONE;
      ec->errinfo = ((VALUE)RUBY_Qnil);

      return ((VALUE)RUBY_Qundef);
    } else {
      hook_before_rewind(ec, ec->cfp, 0, state, err);

      if (VM_FRAME_FINISHED_P(ec->cfp)) {
        rb_vm_pop_frame(ec);
        ec->errinfo = (VALUE)err;
        ec->tag = ec->tag->prev;
        rb_ec_tag_jump(ec, state);
      } else {
        rb_vm_pop_frame(ec);
      }
    }
  }
}

VALUE
rb_iseq_eval(const rb_iseq_t *iseq) {
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE val;
  vm_set_top_stack(ec, iseq);
  val = rb_vm_exec(ec, 1);
  return val;
}

VALUE
rb_iseq_eval_main(const rb_iseq_t *iseq) {
  rb_execution_context_t *ec = rb_current_execution_context();
  VALUE val;

  vm_set_main_stack(ec, iseq);
  val = rb_vm_exec(ec, 1);
  return val;
}

int rb_vm_control_frame_id_and_class(const rb_control_frame_t *cfp, ID *idp,
                                     ID *called_idp, VALUE *klassp) {
  const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(cfp);

  if (me) {
    if (idp)
      *idp = me->def->original_id;
    if (called_idp)
      *called_idp = me->called_id;
    if (klassp)
      *klassp = me->owner;
    return 1;
  } else {
    return 0;
  }
}

int rb_ec_frame_method_id_and_class(const rb_execution_context_t *ec, ID *idp,
                                    ID *called_idp, VALUE *klassp) {
  return rb_vm_control_frame_id_and_class(ec->cfp, idp, called_idp, klassp);
}

__attribute__((__visibility__("default"))) extern int
rb_frame_method_id_and_class(ID *idp, VALUE *klassp) {
  return rb_ec_frame_method_id_and_class(rb_current_execution_context(), idp, 0,
                                         klassp);
}

VALUE
rb_vm_call_cfunc(VALUE recv, VALUE (*func)(VALUE), VALUE arg,
                 VALUE block_handler, VALUE filename) {
  rb_execution_context_t *ec = rb_current_execution_context();
  const rb_control_frame_t *reg_cfp = ec->cfp;
  const rb_iseq_t *iseq =
      rb_iseq_new(0, filename, filename, ((VALUE)RUBY_Qnil), 0, ISEQ_TYPE_TOP);
  VALUE val;

  vm_push_frame(ec, iseq,
                VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH,
                recv, block_handler, (VALUE)vm_cref_new_toplevel(ec), 0,
                reg_cfp->sp, 0, 0);

  val = (*func)(arg);

  rb_vm_pop_frame(ec);
  return val;
}

void rb_vm_trace_mark_event_hooks(rb_hook_list_t *hooks);

void rb_vm_mark(void *ptr) {
  ;
  if (0)
    printf("-------------------------------------------------\n");
  if (ptr) {
    rb_vm_t *vm = ptr;
    rb_thread_t *th = 0;

    for ((th) = list_node_to_off_(
             ((void)"vm.c"
                    ":"
                    "2149",
              (&vm->living_threads))
                 ->n.next,
             (((__builtin_offsetof(typeof(*th), vmlt_node) +
                ((typeof(th->vmlt_node) *)0 != (struct list_node *)0)))));
         list_node_from_off_(
             (void *)(th),
             (((__builtin_offsetof(typeof(*th), vmlt_node) +
                ((typeof(th->vmlt_node) *)0 != (struct list_node *)0))))) !=
         &((&vm->living_threads))->n;
         (th) = list_node_to_off_(
             list_node_from_off_(
                 (void *)(th),
                 (((__builtin_offsetof(typeof(*th), vmlt_node) +
                    ((typeof(th->vmlt_node) *)0 != (struct list_node *)0)))))
                 ->next,
             (((__builtin_offsetof(typeof(*th), vmlt_node) +
                ((typeof(th->vmlt_node) *)0 != (struct list_node *)0)))))) {
      rb_gc_mark(th->self);
    }
    rb_gc_mark(vm->thgroup_default);
    rb_gc_mark(vm->mark_object_ary);
    rb_gc_mark(vm->load_path);
    rb_gc_mark(vm->load_path_snapshot);
    do {
      VALUE markobj = (vm->load_path_check_cache);
      if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
        rb_gc_mark(markobj);
      }
    } while (0);
    rb_gc_mark(vm->expanded_load_path);
    rb_gc_mark(vm->loaded_features);
    rb_gc_mark(vm->loaded_features_snapshot);
    rb_gc_mark(vm->top_self);
    do {
      VALUE markobj = (vm->coverages);
      if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
        rb_gc_mark(markobj);
      }
    } while (0);
    rb_gc_mark(vm->defined_module_hash);

    if (vm->loading_table) {
      rb_mark_tbl(vm->loading_table);
    }

    rb_vm_trace_mark_event_hooks(&vm->event_hooks);

    rb_gc_mark_values(32, vm->trap_list.cmd);

    mjit_mark();
  }

  ;
}

void rb_vm_register_special_exception_str(enum ruby_special_exceptions sp,
                                          VALUE cls, VALUE mesg) {
  rb_vm_t *vm = rb_current_vm();
  VALUE exc = rb_exc_new_str(cls, rb_obj_freeze(mesg));
  (((!(((VALUE)(exc)&RUBY_IMMEDIATE_MASK) ||
       !!(((VALUE)(exc) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
     (int)(((struct RBasic *)(exc))->flags & RUBY_T_MASK) != RUBY_T_NODE) &&
    (int)(((struct RBasic *)(exc))->flags & RUBY_T_MASK) != RUBY_T_BIGNUM &&
    (int)(((struct RBasic *)(exc))->flags & RUBY_T_MASK) != RUBY_T_FLOAT)
       ? (void)(((struct RBasic *)(exc))->flags |= (RUBY_FL_TAINT))
       : (void)0);
  rb_obj_freeze_inline((VALUE)exc);
  ((VALUE *)vm->special_exceptions)[sp] = exc;
  rb_gc_register_mark_object(exc);
}

int rb_vm_add_root_module(ID id, VALUE module) {
  rb_vm_t *vm = rb_current_vm();

  rb_hash_aset(vm->defined_module_hash, (rb_id2sym(id)), module);

  return 1;
}

static int free_loading_table_entry(st_data_t key, st_data_t value,
                                    st_data_t arg) {
  ruby_xfree((char *)key);
  return ST_DELETE;
}

int ruby_vm_destruct(rb_vm_t *vm) {
  ;

  if (vm) {
    rb_thread_t *th = vm->main_thread;
    struct rb_objspace *objspace = vm->objspace;
    vm->main_thread = 0;
    if (th) {
      rb_fiber_reset_root_local_storage(th);
      thread_free(th);
    }
    rb_vm_living_threads_init(vm);
    ruby_vm_run_at_exit_hooks(vm);
    if (vm->loading_table) {
      st_foreach(vm->loading_table, free_loading_table_entry, 0);
      st_free_table(vm->loading_table);
      vm->loading_table = 0;
    }
    if (vm->frozen_strings) {
      st_free_table(vm->frozen_strings);
      vm->frozen_strings = 0;
    }
    rb_vm_gvl_destroy(vm);
    ruby_xfree(vm->main_altstack);
    if (objspace) {
      rb_objspace_free(objspace);
    }

    ruby_mimfree(vm);
    ruby_current_vm_ptr = ((void *)0);
  };
  return 0;
}

static size_t vm_memsize(const void *ptr) {
  const rb_vm_t *vmobj = ptr;
  size_t size = sizeof(rb_vm_t);

  size += vmobj->living_thread_num * sizeof(rb_thread_t);

  if (vmobj->defined_strings) {
    size += DEFINED_EXPR * sizeof(VALUE);
  }
  return size;
}

static const rb_data_type_t vm_data_type = {"VM",
                                            {
                                                ((void *)0),
                                                ((void *)0),
                                                vm_memsize,
                                            },
                                            0,
                                            0,
                                            1};

static VALUE vm_default_params(void) {
  rb_vm_t *vm = rb_current_vm();
  VALUE result = rb_hash_new();

  rb_hash_aset(result,
               (rb_id2sym((__builtin_constant_p("thread_vm_stack_size")
                               ? __extension__(rb_intern2(
                                     ("thread_vm_stack_size"),
                                     (long)strlen("thread_vm_stack_size")))
                               : (rb_intern)("thread_vm_stack_size")))),
               rb_ulong2num_inline(vm->default_params.thread_vm_stack_size));
  ;
  rb_hash_aset(
      result,
      (rb_id2sym((__builtin_constant_p("thread_machine_stack_size")
                      ? __extension__(rb_intern2(
                            ("thread_machine_stack_size"),
                            (long)strlen("thread_machine_stack_size")))
                      : (rb_intern)("thread_machine_stack_size")))),
      rb_ulong2num_inline(vm->default_params.thread_machine_stack_size));
  ;
  rb_hash_aset(result,
               (rb_id2sym((__builtin_constant_p("fiber_vm_stack_size")
                               ? __extension__(rb_intern2(
                                     ("fiber_vm_stack_size"),
                                     (long)strlen("fiber_vm_stack_size")))
                               : (rb_intern)("fiber_vm_stack_size")))),
               rb_ulong2num_inline(vm->default_params.fiber_vm_stack_size));
  ;
  rb_hash_aset(
      result,
      (rb_id2sym((__builtin_constant_p("fiber_machine_stack_size")
                      ? __extension__(rb_intern2(
                            ("fiber_machine_stack_size"),
                            (long)strlen("fiber_machine_stack_size")))
                      : (rb_intern)("fiber_machine_stack_size")))),
      rb_ulong2num_inline(vm->default_params.fiber_machine_stack_size));
  ;

  rb_obj_freeze(result);
  return result;
}

static size_t get_param(const char *name, size_t default_value,
                        size_t min_value) {
  const char *envval;
  size_t result = default_value;
  if ((envval = getenv(name)) != 0) {
    long val = atol(envval);
    if (val < (long)min_value) {
      val = (long)min_value;
    }
    result = (size_t)(((val - 1 + 4096) / 4096) * 4096);
  }
  if (0)
    fprintf(__stderrp,
            "%s: %"
            "z"
            "u"
            "\n",
            name, result);

  return result;
}

static void check_machine_stack_size(size_t *sizep) {

  size_t size = *sizep;

  if (size < 8192) {
    *sizep = 8192 * 2;
  }
}

static void vm_default_params_setup(rb_vm_t *vm) {
  vm->default_params.thread_vm_stack_size =
      get_param("RUBY_THREAD_VM_STACK_SIZE", (128 * 1024 * sizeof(VALUE)),
                (2 * 1024 * sizeof(VALUE)));

  vm->default_params.thread_machine_stack_size =
      get_param("RUBY_THREAD_MACHINE_STACK_SIZE", (128 * 1024 * sizeof(VALUE)),
                (16 * 1024 * sizeof(VALUE)));

  vm->default_params.fiber_vm_stack_size =
      get_param("RUBY_FIBER_VM_STACK_SIZE", (16 * 1024 * sizeof(VALUE)),
                (2 * 1024 * sizeof(VALUE)));

  vm->default_params.fiber_machine_stack_size =
      get_param("RUBY_FIBER_MACHINE_STACK_SIZE", (64 * 1024 * sizeof(VALUE)),
                (16 * 1024 * sizeof(VALUE)));

  check_machine_stack_size(&vm->default_params.thread_machine_stack_size);
  check_machine_stack_size(&vm->default_params.fiber_machine_stack_size);
}

static void vm_init2(rb_vm_t *vm) {
  __builtin___memset_chk((vm), 0, sizeof(rb_vm_t) * (size_t)(1),
                         __builtin_object_size((vm), 0));
  rb_vm_living_threads_init(vm);
  vm->thread_report_on_exception = 1;
  vm->src_encoding_index = -1;

  vm_default_params_setup(vm);
}

static VALUE *thread_recycle_stack_slot[64];
static int thread_recycle_stack_count = 0;

VALUE *rb_thread_recycle_stack(size_t size) {

  if (thread_recycle_stack_count > 0) {

    return thread_recycle_stack_slot[--thread_recycle_stack_count];
  }

  return ((VALUE *)ruby_xmalloc2((size_t)(size), sizeof(VALUE)));
}

void rb_thread_recycle_stack_release(VALUE *stack) {
  ((void)0);

  if (thread_recycle_stack_count < 64) {
    thread_recycle_stack_slot[thread_recycle_stack_count++] = stack;
    return;
  }

  ruby_xfree(stack);
}

void rb_execution_context_mark(const rb_execution_context_t *ec) {

  if (ec->vm_stack) {
    VALUE *p = ec->vm_stack;
    VALUE *sp = ec->cfp->sp;
    rb_control_frame_t *cfp = ec->cfp;
    rb_control_frame_t *limit_cfp = (void *)(ec->vm_stack + ec->vm_stack_size);

    rb_gc_mark_values((long)(sp - p), p);

    while (cfp != limit_cfp) {
      const VALUE *ep = cfp->ep;
      ((void)0);
      rb_gc_mark(cfp->self);
      rb_gc_mark((VALUE)cfp->iseq);
      rb_gc_mark((VALUE)cfp->block_code);

      if (!VM_ENV_LOCAL_P(ep)) {
        const VALUE *prev_ep = VM_ENV_PREV_EP(ep);
        if (VM_ENV_FLAGS(prev_ep, VM_ENV_FLAG_ESCAPED)) {
          rb_gc_mark(prev_ep[(1)]);
        }
      }

      cfp = ((cfp) + 1);
    }
  }

  if (ec->machine.stack_start && ec->machine.stack_end &&
      ec != rb_current_execution_context()) {
    rb_gc_mark_machine_stack(ec);
    rb_gc_mark_locations((VALUE *)&ec->machine.regs,
                         (VALUE *)(&ec->machine.regs) +
                             sizeof(ec->machine.regs) / sizeof(VALUE));
  }

  do {
    VALUE markobj = (ec->errinfo);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (ec->root_svar);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  rb_mark_tbl(ec->local_storage);
  do {
    VALUE markobj = (ec->local_storage_recursive_hash);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (ec->local_storage_recursive_hash_for_trace);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (ec->private_const_reference);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
}

void rb_fiber_mark_self(rb_fiber_t *fib);
void rb_threadptr_root_fiber_setup(rb_thread_t *th);
void rb_threadptr_root_fiber_release(rb_thread_t *th);

static void thread_mark(void *ptr) {
  rb_thread_t *th = ptr;
  ;
  rb_fiber_mark_self(th->ec->fiber_ptr);

  switch (th->invoke_type) {
  case thread_invoke_type_proc:
    do {
      VALUE markobj = (th->invoke_arg.proc.proc);
      if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
        rb_gc_mark(markobj);
      }
    } while (0);
    do {
      VALUE markobj = (th->invoke_arg.proc.args);
      if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
        rb_gc_mark(markobj);
      }
    } while (0);
    break;
  case thread_invoke_type_func:
    rb_gc_mark_maybe((VALUE)th->invoke_arg.func.arg);
    break;
  default:
    break;
  }

  do {
    VALUE markobj = (th->thgroup);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->value);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->pending_interrupt_queue);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->pending_interrupt_mask_stack);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->top_self);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->top_wrapper);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  if (th->root_fiber)
    rb_fiber_mark_self(th->root_fiber);
  do {
    VALUE markobj = (th->stat_insn_usage);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->last_status);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->locking_mutex);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);
  do {
    VALUE markobj = (th->name);
    if (!(((VALUE)(markobj) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) {
      rb_gc_mark(markobj);
    }
  } while (0);

  ;
}

static void thread_free(void *ptr) {
  rb_thread_t *th = ptr;
  ;

  if (th->locking_mutex != ((VALUE)RUBY_Qfalse)) {
    rb_bug("thread_free: locking_mutex must be NULL (%p:%p)", (void *)th,
           (void *)th->locking_mutex);
  }
  if (th->keeping_mutexes != ((void *)0)) {
    rb_bug("thread_free: keeping_mutexes must be NULL (%p:%p)", (void *)th,
           (void *)th->keeping_mutexes);
  }

  rb_threadptr_root_fiber_release(th);

  if (th->vm && th->vm->main_thread == th) {
    if (0)
      printf("main thread\n");
  } else {
    ruby_xfree(ptr);
  }

  ;
}

static size_t thread_memsize(const void *ptr) {
  const rb_thread_t *th = ptr;
  size_t size = sizeof(rb_thread_t);

  if (!th->root_fiber) {
    size += th->ec->vm_stack_size * sizeof(VALUE);
  }
  if (th->ec->local_storage) {
    size += st_memsize(th->ec->local_storage);
  }
  return size;
}

const rb_data_type_t ruby_threadptr_data_type = {"VM/thread",
                                                 {
                                                     thread_mark,
                                                     thread_free,
                                                     thread_memsize,
                                                 },
                                                 0,
                                                 0,
                                                 1};

VALUE
rb_obj_is_thread(VALUE obj) {
  if (rb_typeddata_is_kind_of(obj, &ruby_threadptr_data_type)) {
    return ((VALUE)RUBY_Qtrue);
  } else {
    return ((VALUE)RUBY_Qfalse);
  }
}

static VALUE thread_alloc(VALUE klass) {
  VALUE obj;
  rb_thread_t *th;
  obj = __extension__({
    VALUE data_struct_obj = rb_data_typed_object_zalloc(
        klass, sizeof(rb_thread_t), &ruby_threadptr_data_type);
    (void)((th) = (rb_thread_t *)(((struct RData *)(data_struct_obj))->data));
    ;
    data_struct_obj;
  });

  return obj;
}

static void th_init(rb_thread_t *th, VALUE self) {
  th->self = self;
  rb_threadptr_root_fiber_setup(th);

  {

    size_t size = th->vm->default_params.thread_vm_stack_size / sizeof(VALUE);
    ec_set_vm_stack(th->ec, rb_thread_recycle_stack(size), size);
  }

  th->ec->cfp = (void *)(th->ec->vm_stack + th->ec->vm_stack_size);

  vm_push_frame(th->ec, 0,
                VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL |
                    VM_FRAME_FLAG_FINISH | VM_FRAME_FLAG_CFRAME,
                ((VALUE)RUBY_Qnil), 0, 0, 0, th->ec->vm_stack, 0, 0);

  th->status = THREAD_RUNNABLE;
  th->last_status = ((VALUE)RUBY_Qnil);
  th->ec->errinfo = ((VALUE)RUBY_Qnil);
  th->ec->root_svar = ((VALUE)RUBY_Qfalse);
  th->ec->local_storage_recursive_hash = ((VALUE)RUBY_Qnil);
  th->ec->local_storage_recursive_hash_for_trace = ((VALUE)RUBY_Qnil);

  th->name = ((VALUE)RUBY_Qnil);
  th->report_on_exception = th->vm->thread_report_on_exception;
}

static VALUE ruby_thread_init(VALUE self) {
  rb_thread_t *th = rb_thread_ptr(self);
  rb_vm_t *vm = rb_current_thread()->vm;

  th->vm = vm;
  th_init(th, self);
  rb_ivar_set(
      self,
      (__builtin_constant_p("locals")
           ? __extension__(rb_intern2(("locals"), (long)strlen("locals")))
           : (rb_intern)("locals")),
      rb_hash_new());

  th->top_wrapper = 0;
  th->top_self = rb_vm_top_self();
  th->ec->root_svar = ((VALUE)RUBY_Qfalse);
  return self;
}

VALUE
rb_thread_alloc(VALUE klass) {
  VALUE self = thread_alloc(klass);
  ruby_thread_init(self);
  return self;
}

static void vm_define_method(VALUE obj, ID id, VALUE iseqval,
                             int is_singleton) {
  VALUE klass;
  rb_method_visibility_t visi;
  rb_cref_t *cref = rb_vm_cref();

  if (!is_singleton) {
    klass = CREF_CLASS(cref);
    visi = rb_scope_visibility_get();
  } else {
    klass = rb_singleton_class(obj);
    visi = METHOD_VISI_PUBLIC;
  }

  if (!((VALUE)(klass) != ((VALUE)RUBY_Qnil))) {
    rb_raise(rb_eTypeError, "no class/module to add method");
  }

  rb_add_method_iseq(klass, id, (const rb_iseq_t *)iseqval, cref, visi);

  if (!is_singleton && rb_scope_module_func_check()) {
    klass = rb_singleton_class(klass);
    rb_add_method_iseq(klass, id, (const rb_iseq_t *)iseqval, cref,
                       METHOD_VISI_PUBLIC);
  }
}
# 2648 "vm.c"
static VALUE m_core_define_method(VALUE self, VALUE sym, VALUE iseqval) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    { vm_define_method(((VALUE)RUBY_Qnil), (rb_sym2id(sym)), iseqval, 0); };
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return sym;
}

static VALUE m_core_define_singleton_method(VALUE self, VALUE cbase, VALUE sym,
                                            VALUE iseqval) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    { vm_define_method(cbase, (rb_sym2id(sym)), iseqval, 1); };
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return sym;
}

static VALUE m_core_set_method_alias(VALUE self, VALUE cbase, VALUE sym1,
                                     VALUE sym2) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    { rb_alias(cbase, (rb_sym2id(sym1)), (rb_sym2id(sym2))); };
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return ((VALUE)RUBY_Qnil);
}

static VALUE m_core_set_variable_alias(VALUE self, VALUE sym1, VALUE sym2) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    { rb_alias_variable((rb_sym2id(sym1)), (rb_sym2id(sym2))); };
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return ((VALUE)RUBY_Qnil);
}

static VALUE m_core_undef_method(VALUE self, VALUE cbase, VALUE sym) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    {
      rb_undef(cbase, (rb_sym2id(sym)));
      rb_clear_method_cache_by_class(self);
    };
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return ((VALUE)RUBY_Qnil);
}

static VALUE m_core_set_postexe(VALUE self) {
  rb_set_end_proc(rb_call_end_proc, rb_block_proc());
  return ((VALUE)RUBY_Qnil);
}

static VALUE core_hash_merge_kwd(VALUE hash, VALUE kw);

static VALUE core_hash_merge(VALUE hash, long argc, const VALUE *argv) {
  (!((((RUBY_T_HASH)) == RUBY_T_FIXNUM)
         ? (((int)(long)((VALUE)(hash))) & RUBY_FIXNUM_FLAG)
         : (((RUBY_T_HASH)) == RUBY_T_TRUE)
               ? (((VALUE)(hash)) == ((VALUE)RUBY_Qtrue))
               : (((RUBY_T_HASH)) == RUBY_T_FALSE)
                     ? (((VALUE)(hash)) == ((VALUE)RUBY_Qfalse))
                     : (((RUBY_T_HASH)) == RUBY_T_NIL)
                           ? (((VALUE)(hash)) == ((VALUE)RUBY_Qnil))
                           : (((RUBY_T_HASH)) == RUBY_T_UNDEF)
                                 ? (((VALUE)(hash)) == ((VALUE)RUBY_Qundef))
                                 : (((RUBY_T_HASH)) == RUBY_T_SYMBOL)
                                       ? ((((VALUE)((VALUE)(hash)) &
                                            ~((~(VALUE)0)
                                              << RUBY_SPECIAL_SHIFT)) ==
                                           RUBY_SYMBOL_FLAG) ||
                                          (!(((VALUE)((VALUE)(hash)) &
                                              RUBY_IMMEDIATE_MASK) ||
                                             !!(((VALUE)((VALUE)(hash)) &
                                                 (VALUE) ~((VALUE)RUBY_Qnil)) ==
                                                0)) &&
                                           (int)(((struct RBasic *)((VALUE)(
                                                      hash)))
                                                     ->flags &
                                                 RUBY_T_MASK) ==
                                               (RUBY_T_SYMBOL)))
                                       : (((RUBY_T_HASH)) == RUBY_T_FLOAT)
                                             ? (((((int)(long)((VALUE)(hash))) &
                                                  RUBY_FLONUM_MASK) ==
                                                 RUBY_FLONUM_FLAG) ||
                                                (!(((VALUE)((VALUE)(hash)) &
                                                    RUBY_IMMEDIATE_MASK) ||
                                                   !!(((VALUE)((VALUE)(hash)) &
                                                       (VALUE) ~(
                                                           (VALUE)RUBY_Qnil)) ==
                                                      0)) &&
                                                 (int)(((struct RBasic *)((
                                                            VALUE)(hash)))
                                                           ->flags &
                                                       RUBY_T_MASK) ==
                                                     RUBY_T_FLOAT))
                                             : (!(((VALUE)((VALUE)(hash)) &
                                                   RUBY_IMMEDIATE_MASK) ||
                                                  !!(((VALUE)((VALUE)(hash)) &
                                                      (VALUE) ~(
                                                          (VALUE)RUBY_Qnil)) ==
                                                     0)) &&
                                                (int)(((struct RBasic *)((
                                                           VALUE)(hash)))
                                                          ->flags &
                                                      RUBY_T_MASK) ==
                                                    ((RUBY_T_HASH)))) ||
           ((RUBY_T_HASH) == RUBY_T_DATA &&
            (((struct RTypedData *)(hash))->typed_flag == 1))
       ? rb_unexpected_type((VALUE)(hash), (RUBY_T_HASH))
       : (void)0);
  ((void)0);
  rb_hash_bulk_insert(argc, argv, hash);
  return hash;
}

static VALUE m_core_hash_merge_ptr(int argc, VALUE *argv, VALUE recv) {
  VALUE hash = argv[0];

  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    core_hash_merge(hash, argc - 1, argv + 1);
    (ec__->cfp--)->sp = saved_sp;
  } while (0);

  return hash;
}

static void kw_check_symbol(VALUE key) {
  if (!((((VALUE)(key) & ~((~(VALUE)0) << RUBY_SPECIAL_SHIFT)) ==
         RUBY_SYMBOL_FLAG) ||
        (!(((VALUE)(key)&RUBY_IMMEDIATE_MASK) ||
           !!(((VALUE)(key) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0)) &&
         (int)(((struct RBasic *)(key))->flags & RUBY_T_MASK) ==
             (RUBY_T_SYMBOL)))) {
    rb_raise(rb_eTypeError,
             "hash key %+"
             "l"
             "i"
             "\v"
             " is not a Symbol",
             key);
  }
}
static int kwmerge_i(VALUE key, VALUE value, VALUE hash) {
  kw_check_symbol(key);
  rb_hash_aset(hash, key, value);
  return ST_CONTINUE;
}

static VALUE m_core_hash_merge_kwd(VALUE recv, VALUE hash, VALUE kw) {
  do {
    rb_execution_context_t *ec__ = rb_current_execution_context();
    VALUE *const curr_sp = (ec__->cfp++)->sp;
    VALUE *const saved_sp = ec__->cfp->sp;
    ec__->cfp->sp = curr_sp;
    hash = core_hash_merge_kwd(hash, kw);
    (ec__->cfp--)->sp = saved_sp;
  } while (0);
  return hash;
}

static VALUE core_hash_merge_kwd(VALUE hash, VALUE kw) {
  rb_hash_foreach(rb_to_hash_type(kw), kwmerge_i, hash);
  return hash;
}

static VALUE mjit_enabled_p(void) {
  return mjit_enabled ? ((VALUE)RUBY_Qtrue) : ((VALUE)RUBY_Qfalse);
}

static VALUE mjit_pause_m(int argc, VALUE *argv,
                          VALUE self __attribute__((unused))) {
  VALUE options = ((VALUE)RUBY_Qnil);
  VALUE wait = ((VALUE)RUBY_Qtrue);
  __builtin_choose_expr(
      __builtin_constant_p("0:"),
      rb_scan_args_set(
          argc, argv, rb_scan_args_n_lead("0:"), rb_scan_args_n_opt("0:"),
          rb_scan_args_n_trail("0:"), rb_scan_args_f_var("0:"),
          rb_scan_args_f_hash("0:"), rb_scan_args_f_block("0:"),
          (0, ((VALUE *[]){&options})),
          (char *)"0:", (sizeof((VALUE *[]){&options}) / sizeof(VALUE *))),
      rb_scan_args(argc, argv, "0:", &options));

  if (!!((VALUE)(options) != ((VALUE)RUBY_Qnil))) {
    static ID keyword_ids[1];
    if (!keyword_ids[0])
      keyword_ids[0] =
          (__builtin_constant_p("wait")
               ? __extension__(rb_intern2(("wait"), (long)strlen("wait")))
               : (rb_intern)("wait"));
    rb_get_kwargs(options, keyword_ids, 0, 1, &wait);
  }

  return mjit_pause(!(((VALUE)(wait) & (VALUE) ~((VALUE)RUBY_Qnil)) == 0));
}

extern VALUE *rb_gc_stack_start;
extern size_t rb_gc_stack_maxsize;

static VALUE sdr(void) {
  rb_vm_bugreport(((void *)0));
  return ((VALUE)RUBY_Qnil);
}

static VALUE nsdr(void) {
  VALUE ary = rb_ary_new();

# 1 "/usr/include/execinfo.h" 1 3 4
# 31 "/usr/include/execinfo.h" 3 4
  int backtrace(void **, int)
      __attribute__((availability(macosx, introduced = 10.5)));
  char **backtrace_symbols(void *const *, int)
      __attribute__((availability(macosx, introduced = 10.5)));
  void backtrace_symbols_fd(void *const *, int, int)
      __attribute__((availability(macosx, introduced = 10.5)));
# 2799 "vm.c" 2

  static void *trace[1024];
  int n = (int)backtrace(trace, 1024);
  char **syms = backtrace_symbols(trace, n);
  int i;

  if (syms == 0) {
    rb_memerror();
  }

  for (i = 0; i < n; i++) {
    rb_ary_push(ary, __extension__({
                  (__builtin_constant_p(syms[i]))
                      ? rb_str_new_static((syms[i]), (long)strlen(syms[i]))
                      : rb_str_new_cstr(syms[i]);
                }));
  }
  free(syms);

  return ary;
}

void Init_VM(void) {
  VALUE opts;
  VALUE klass;
  VALUE fcore;
  VALUE mjit;
# 2838 "vm.c"
  rb_cRubyVM = rb_define_class("RubyVM", rb_cObject);
  rb_undef_alloc_func(rb_cRubyVM);
  rb_undef_method(rb_class_of((VALUE)(rb_cRubyVM)), "new");
  rb_define_singleton_method(rb_cRubyVM, "stat", vm_stat, -1);

  fcore = rb_class_new(rb_cBasicObject);
  ((struct RBasic *)(fcore))->flags = RUBY_T_ICLASS;
  klass = rb_singleton_class(fcore);
  rb_define_method_id(klass, id_core_set_method_alias, m_core_set_method_alias,
                      3);
  rb_define_method_id(klass, id_core_set_variable_alias,
                      m_core_set_variable_alias, 2);
  rb_define_method_id(klass, id_core_undef_method, m_core_undef_method, 2);
  rb_define_method_id(klass, id_core_define_method, m_core_define_method, 2);
  rb_define_method_id(klass, id_core_define_singleton_method,
                      m_core_define_singleton_method, 3);
  rb_define_method_id(klass, id_core_set_postexe, m_core_set_postexe, 0);
  rb_define_method_id(klass, id_core_hash_merge_ptr, m_core_hash_merge_ptr, -1);
  rb_define_method_id(klass, id_core_hash_merge_kwd, m_core_hash_merge_kwd, 2);
  rb_define_method_id(klass, idProc, rb_block_proc, 0);
  rb_define_method_id(klass, idLambda, rb_block_lambda, 0);
  rb_obj_freeze(fcore);
  __builtin___memset_chk(
      &(((struct RBasicRaw *)((VALUE)(klass)))->klass), 0, sizeof(VALUE),
      __builtin_object_size(&(((struct RBasicRaw *)((VALUE)(klass)))->klass),
                            0));
  rb_obj_freeze(klass);
  rb_gc_register_mark_object(fcore);
  rb_mRubyVMFrozenCore = fcore;

  mjit = rb_define_module_under(rb_cRubyVM, "MJIT");
  rb_define_singleton_method(mjit, "enabled?", mjit_enabled_p, 0);
  rb_define_singleton_method(mjit, "pause", mjit_pause_m, -1);
  rb_define_singleton_method(mjit, "resume", mjit_resume, 0);
# 3016 "vm.c"
  rb_cThread = rb_define_class("Thread", rb_cObject);
  rb_undef_alloc_func(rb_cThread);
# 3033 "vm.c"
  rb_define_const(rb_cRubyVM, "OPTS", opts = rb_ary_new());

  rb_ary_push(opts, __extension__({
                (__builtin_constant_p("direct threaded code"))
                    ? rb_str_new_static(("direct threaded code"),
                                        (long)strlen("direct threaded code"))
                    : rb_str_new_cstr("direct threaded code");
              }));
# 3047 "vm.c"
  rb_ary_push(opts, __extension__({
                (__builtin_constant_p("operands unification"))
                    ? rb_str_new_static(("operands unification"),
                                        (long)strlen("operands unification"))
                    : rb_str_new_cstr("operands unification");
              }));

  rb_ary_push(opts, __extension__({
                (__builtin_constant_p("inline method cache"))
                    ? rb_str_new_static(("inline method cache"),
                                        (long)strlen("inline method cache"))
                    : rb_str_new_cstr("inline method cache");
              }));

  rb_define_const(rb_cRubyVM, "INSTRUCTION_NAMES", rb_insns_name_array());

  rb_define_const(rb_cRubyVM, "DEFAULT_PARAMS", vm_default_params());

  (void)sdr;
  (void)nsdr;

  {
    rb_vm_t *vm = ruby_current_vm_ptr;
    rb_thread_t *th = rb_current_thread();
    VALUE filename = rb_fstring_new(("<main>"), (sizeof("<main>"
                                                        "") -
                                                 1));
    const rb_iseq_t *iseq = rb_iseq_new(0, filename, filename,
                                        ((VALUE)RUBY_Qnil), 0, ISEQ_TYPE_TOP);
    volatile VALUE th_self;

    vm->self = rb_data_typed_object_wrap((rb_cRubyVM), (vm), (&vm_data_type));

    th_self = th->self = rb_data_typed_object_wrap((rb_cThread), (th),
                                                   (&ruby_threadptr_data_type));
    rb_iv_set(th_self, "locals", rb_hash_new());
    vm->main_thread = th;
    vm->running_thread = th;
    th->vm = vm;
    th->top_wrapper = 0;
    th->top_self = rb_vm_top_self();
    do {
      if ((th)->vm->running_thread != (th)) {
        (th)->running_time_us = 0;
      }
      (void)(ruby_current_execution_context_ptr = (th)->ec);
      (th)->vm->running_thread = (th);
    } while (0);

    rb_vm_living_threads_insert(vm, th);

    rb_gc_register_mark_object((VALUE)iseq);
    th->ec->cfp->iseq = iseq;
    th->ec->cfp->pc = iseq->body->iseq_encoded;
    th->ec->cfp->self = th->top_self;

    VM_ENV_FLAGS_UNSET(th->ec->cfp->ep, VM_FRAME_FLAG_CFRAME);
    VM_STACK_ENV_WRITE(
        th->ec->cfp->ep, (-2),
        (VALUE)vm_cref_new(rb_cObject, METHOD_VISI_PRIVATE, 0, ((void *)0), 0));

    rb_define_global_const("TOPLEVEL_BINDING", rb_binding_new());
  }
  vm_init_redefined_flag();

  rb_block_param_proxy = rb_obj_alloc(rb_cObject);
  rb_add_method(rb_singleton_class(rb_block_param_proxy), idCall,
                VM_METHOD_TYPE_OPTIMIZED,
                (void *)OPTIMIZED_METHOD_TYPE_BLOCK_CALL, METHOD_VISI_PUBLIC);
  rb_obj_freeze(rb_block_param_proxy);
  rb_gc_register_mark_object(rb_block_param_proxy);

  Init_vm_backtrace();
}

void rb_vm_set_progname(VALUE filename) {
  rb_thread_t *th = rb_current_vm()->main_thread;
  rb_control_frame_t *cfp = (void *)(th->ec->vm_stack + th->ec->vm_stack_size);
  --cfp;

  rb_iseq_pathobj_set(cfp->iseq, rb_str_dup(filename),
                      rb_iseq_realpath(cfp->iseq));
}

extern const struct st_hash_type rb_fstring_hash_type;

void Init_BareVM(void) {

  rb_vm_t *vm = ruby_mimmalloc(sizeof(*vm));
  rb_thread_t *th = ruby_mimmalloc(sizeof(*th));
  if (!vm || !th) {
    fprintf(__stderrp, "[FATAL] failed to allocate memory\n");
    exit(1);
  }
  __builtin___memset_chk((th), 0, sizeof(rb_thread_t) * (size_t)(1),
                         __builtin_object_size((th), 0));
  vm_init2(vm);

  vm->objspace = rb_objspace_alloc();
  ruby_current_vm_ptr = vm;

  Init_native_thread(th);
  th->vm = vm;
  th_init(th, 0);
  (void)(ruby_current_execution_context_ptr = (th)->ec);
  ruby_thread_init_stack(th);
}

void Init_vm_objects(void) {
  rb_vm_t *vm = rb_current_vm();

  vm->defined_module_hash = rb_hash_new();

  vm->mark_object_ary = rb_ary_tmp_new(128);
  vm->loading_table = st_init_strtable();
  vm->frozen_strings = st_init_table_with_size(&rb_fstring_hash_type, 1000);
}

static VALUE main_to_s(VALUE obj) {
  return __extension__({
    (__builtin_constant_p("main"))
        ? rb_str_new_static(("main"), (long)strlen("main"))
        : rb_str_new_cstr("main");
  });
}

VALUE
rb_vm_top_self(void) { return rb_current_vm()->top_self; }

void Init_top_self(void) {
  rb_vm_t *vm = rb_current_vm();

  vm->top_self = rb_obj_alloc(rb_cObject);
  rb_define_singleton_method(rb_vm_top_self(), "to_s", main_to_s, 0);
  rb_define_alias(rb_singleton_class(rb_vm_top_self()), "inspect", "to_s");
}

static VALUE *ruby_vm_verbose_ptr(rb_vm_t *vm) { return &vm->verbose; }

static VALUE *ruby_vm_debug_ptr(rb_vm_t *vm) { return &vm->debug; }

VALUE *rb_ruby_verbose_ptr(void) {
  return ruby_vm_verbose_ptr(rb_current_vm());
}

VALUE *rb_ruby_debug_ptr(void) { return ruby_vm_debug_ptr(rb_current_vm()); }

VALUE rb_insn_operand_intern(const rb_iseq_t *iseq, VALUE insn, int op_no,
                             VALUE op, int len, size_t pos, VALUE *pnop,
                             VALUE child);

st_table *rb_vm_fstring_table(void) { return rb_current_vm()->frozen_strings; }
# 3399 "vm.c"
__attribute__((__unused__)) static void (*ruby_vm_collect_usage_func_insn)(
    int insn) = ((void *)0);
__attribute__((__unused__)) static void (*ruby_vm_collect_usage_func_operand)(
    int insn, int n, VALUE op) = ((void *)0);
__attribute__((__unused__)) static void (*ruby_vm_collect_usage_func_register)(
    int reg, int isset) = ((void *)0);
# 3448 "vm.c"
# 1 "./vm_call_iseq_optimized.inc" 1

static VALUE vm_call_iseq_setup_normal_0start_0params_0locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 0);
}

static VALUE vm_call_iseq_setup_normal_0start_0params_1locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 1);
}

static VALUE vm_call_iseq_setup_normal_0start_0params_2locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 2);
}

static VALUE vm_call_iseq_setup_normal_0start_0params_3locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 3);
}

static VALUE vm_call_iseq_setup_normal_0start_0params_4locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 4);
}

static VALUE vm_call_iseq_setup_normal_0start_0params_5locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 0, 5);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_0locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 0);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_1locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 1);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_2locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 2);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_3locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 3);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_4locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 4);
}

static VALUE vm_call_iseq_setup_normal_0start_1params_5locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 1, 5);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_0locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 0);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_1locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 1);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_2locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 2);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_3locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 3);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_4locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 4);
}

static VALUE vm_call_iseq_setup_normal_0start_2params_5locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 2, 5);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_0locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 0);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_1locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 1);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_2locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 2);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_3locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 3);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_4locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 4);
}

static VALUE vm_call_iseq_setup_normal_0start_3params_5locals(
    rb_execution_context_t *ec, rb_control_frame_t *cfp,
    struct rb_calling_info *calling, const struct rb_call_info *ci,
    struct rb_call_cache *cc) {
  return vm_call_iseq_setup_normal(ec, cfp, calling, cc->me, 0, 3, 5);
}

static const vm_call_handler vm_call_iseq_handlers[][6] = {
    {vm_call_iseq_setup_normal_0start_0params_0locals,
     vm_call_iseq_setup_normal_0start_0params_1locals,
     vm_call_iseq_setup_normal_0start_0params_2locals,
     vm_call_iseq_setup_normal_0start_0params_3locals,
     vm_call_iseq_setup_normal_0start_0params_4locals,
     vm_call_iseq_setup_normal_0start_0params_5locals},
    {vm_call_iseq_setup_normal_0start_1params_0locals,
     vm_call_iseq_setup_normal_0start_1params_1locals,
     vm_call_iseq_setup_normal_0start_1params_2locals,
     vm_call_iseq_setup_normal_0start_1params_3locals,
     vm_call_iseq_setup_normal_0start_1params_4locals,
     vm_call_iseq_setup_normal_0start_1params_5locals},
    {vm_call_iseq_setup_normal_0start_2params_0locals,
     vm_call_iseq_setup_normal_0start_2params_1locals,
     vm_call_iseq_setup_normal_0start_2params_2locals,
     vm_call_iseq_setup_normal_0start_2params_3locals,
     vm_call_iseq_setup_normal_0start_2params_4locals,
     vm_call_iseq_setup_normal_0start_2params_5locals},
    {vm_call_iseq_setup_normal_0start_3params_0locals,
     vm_call_iseq_setup_normal_0start_3params_1locals,
     vm_call_iseq_setup_normal_0start_3params_2locals,
     vm_call_iseq_setup_normal_0start_3params_3locals,
     vm_call_iseq_setup_normal_0start_3params_4locals,
     vm_call_iseq_setup_normal_0start_3params_5locals}};

static inline vm_call_handler
vm_call_iseq_setup_func(const struct rb_call_info *ci, const int param_size,
                        const int local_size) {
  if ((__builtin_expect(!!(ci->flag & (0x01 << VM_CALL_TAILCALL_bit)), 0))) {
    return &vm_call_iseq_setup_tailcall_0start;
  } else if (0) {
    return &vm_call_iseq_setup_normal_0start;
  } else {
    if (param_size <= 3 && local_size <= 5) {
      ((void)0);
      return vm_call_iseq_handlers[param_size][local_size];
    }
    return &vm_call_iseq_setup_normal_0start;
  }
}
# 3449 "vm.c" 2
